!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ACLOCAL	doc/Makefile	/^ACLOCAL = ${SHELL} \/home\/dormando\/d\/p\/danga\/git\/memcached\/missing aclocal-1.15$/;"	m
ACLOCAL_M4	doc/Makefile	/^ACLOCAL_M4 = $(top_srcdir)\/aclocal.m4$/;"	m
ADD_STAT	memcached.h	/^typedef void (*ADD_STAT)(const char *key, const uint16_t klen,$/;"	t
AMTAR	doc/Makefile	/^AMTAR = $${TAR-tar}$/;"	m
AM_DEFAULT_VERBOSITY	doc/Makefile	/^AM_DEFAULT_VERBOSITY = 1$/;"	m
AM_V_GEN	doc/Makefile	/^AM_V_GEN = $(am__v_GEN_$(V))$/;"	m
AM_V_P	doc/Makefile	/^AM_V_P = $(am__v_P_$(V))$/;"	m
AM_V_at	doc/Makefile	/^AM_V_at = $(am__v_at_$(V))$/;"	m
APPEND_NUM_FMT_STAT	memcached.h	135;"	d
APPEND_NUM_STAT	memcached.h	141;"	d
APPEND_STAT	memcached.h	130;"	d
AUTOCONF	doc/Makefile	/^AUTOCONF = ${SHELL} \/home\/dormando\/d\/p\/danga\/git\/memcached\/missing autoconf$/;"	m
AUTOHEADER	doc/Makefile	/^AUTOHEADER = ${SHELL} \/home\/dormando\/d\/p\/danga\/git\/memcached\/missing autoheader$/;"	m
AUTOMAKE	doc/Makefile	/^AUTOMAKE = ${SHELL} \/home\/dormando\/d\/p\/danga\/git\/memcached\/missing automake-1.15$/;"	m
AWK	doc/Makefile	/^AWK = gawk$/;"	m
BIG_CONSTANT	murmur3_hash.c	25;"	d	file:
BIG_CONSTANT	murmur3_hash.c	40;"	d	file:
BIN_PKT_HDR_WORDS	memcached.h	69;"	d
BIN_REQ_MAGIC	t/udp.t	/^use constant BIN_REQ_MAGIC    => 0x80;$/;"	c
BIN_RES_MAGIC	t/udp.t	/^use constant BIN_RES_MAGIC    => 0x81;$/;"	c
BIPBUFFER_H	bipbuffer.h	2;"	d
BUILT_SOURCES	doc/Makefile	/^BUILT_SOURCES = $(am__append_1)$/;"	m
CACHE_H	cache.h	3;"	d
CC	doc/Makefile	/^CC = gcc$/;"	m
CCDEPMODE	doc/Makefile	/^CCDEPMODE = depmode=gcc3$/;"	m
CFLAGS	doc/Makefile	/^CFLAGS = -g -O2 -pthread -pthread -Wall -Werror -pedantic -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls$/;"	m
CHUNK_ALIGN_BYTES	memcached.h	91;"	d
CLEAR_LRU	items.h	6;"	d
CMD_ADD	t/binary-extstore.t	/^use constant CMD_ADD        => 0x02;$/;"	c
CMD_ADD	t/binary-sasl.t	/^use constant CMD_ADD        => 0x02;$/;"	c
CMD_ADD	t/binary.t	/^use constant CMD_ADD        => 0x02;$/;"	c
CMD_ADD	t/udp.t	/^use constant CMD_ADD          => 0x02;$/;"	c
CMD_ADDQ	t/binary-extstore.t	/^use constant CMD_ADDQ       => 0x12;$/;"	c
CMD_ADDQ	t/binary-sasl.t	/^use constant CMD_ADDQ       => 0x12;$/;"	c
CMD_ADDQ	t/binary.t	/^use constant CMD_ADDQ       => 0x12;$/;"	c
CMD_APPEND	t/binary-extstore.t	/^use constant CMD_APPEND     => 0x0E;$/;"	c
CMD_APPEND	t/binary-sasl.t	/^use constant CMD_APPEND     => 0x0E;$/;"	c
CMD_APPEND	t/binary.t	/^use constant CMD_APPEND     => 0x0E;$/;"	c
CMD_APPEND	t/udp.t	/^use constant CMD_APPEND       => 0x0E;$/;"	c
CMD_APPENDQ	t/binary-extstore.t	/^use constant CMD_APPENDQ    => 0x19;$/;"	c
CMD_APPENDQ	t/binary-sasl.t	/^use constant CMD_APPENDQ    => 0x19;$/;"	c
CMD_APPENDQ	t/binary.t	/^use constant CMD_APPENDQ    => 0x19;$/;"	c
CMD_DECR	t/binary-extstore.t	/^use constant CMD_DECR       => 0x06;$/;"	c
CMD_DECR	t/binary-sasl.t	/^use constant CMD_DECR       => 0x06;$/;"	c
CMD_DECR	t/binary.t	/^use constant CMD_DECR       => 0x06;$/;"	c
CMD_DECR	t/udp.t	/^use constant CMD_DECR         => 0x06;$/;"	c
CMD_DECREMENTQ	t/binary-extstore.t	/^use constant CMD_DECREMENTQ => 0x16;$/;"	c
CMD_DECREMENTQ	t/binary-sasl.t	/^use constant CMD_DECREMENTQ => 0x16;$/;"	c
CMD_DECREMENTQ	t/binary.t	/^use constant CMD_DECREMENTQ => 0x16;$/;"	c
CMD_DELETE	t/binary-extstore.t	/^use constant CMD_DELETE     => 0x04;$/;"	c
CMD_DELETE	t/binary-sasl.t	/^use constant CMD_DELETE     => 0x04;$/;"	c
CMD_DELETE	t/binary.t	/^use constant CMD_DELETE     => 0x04;$/;"	c
CMD_DELETE	t/udp.t	/^use constant CMD_DELETE       => 0x04;$/;"	c
CMD_DELETEQ	t/binary-extstore.t	/^use constant CMD_DELETEQ    => 0x14;$/;"	c
CMD_DELETEQ	t/binary-sasl.t	/^use constant CMD_DELETEQ    => 0x14;$/;"	c
CMD_DELETEQ	t/binary.t	/^use constant CMD_DELETEQ    => 0x14;$/;"	c
CMD_FLUSH	t/binary-extstore.t	/^use constant CMD_FLUSH      => 0x08;$/;"	c
CMD_FLUSH	t/binary-sasl.t	/^use constant CMD_FLUSH      => 0x08;$/;"	c
CMD_FLUSH	t/binary.t	/^use constant CMD_FLUSH      => 0x08;$/;"	c
CMD_FLUSHQ	t/binary-extstore.t	/^use constant CMD_FLUSHQ     => 0x18;$/;"	c
CMD_FLUSHQ	t/binary-sasl.t	/^use constant CMD_FLUSHQ     => 0x18;$/;"	c
CMD_FLUSHQ	t/binary.t	/^use constant CMD_FLUSHQ     => 0x18;$/;"	c
CMD_GAT	t/binary-extstore.t	/^use constant CMD_GAT        => 0x1D;$/;"	c
CMD_GAT	t/binary.t	/^use constant CMD_GAT        => 0x1D;$/;"	c
CMD_GATK	t/binary-extstore.t	/^use constant CMD_GATK       => 0x23;$/;"	c
CMD_GATK	t/binary.t	/^use constant CMD_GATK       => 0x23;$/;"	c
CMD_GATKQ	t/binary-extstore.t	/^use constant CMD_GATKQ      => 0x24;$/;"	c
CMD_GATKQ	t/binary.t	/^use constant CMD_GATKQ      => 0x24;$/;"	c
CMD_GATQ	t/binary-extstore.t	/^use constant CMD_GATQ       => 0x1E;$/;"	c
CMD_GATQ	t/binary.t	/^use constant CMD_GATQ       => 0x1E;$/;"	c
CMD_GET	t/binary-extstore.t	/^use constant CMD_GET        => 0x00;$/;"	c
CMD_GET	t/binary-sasl.t	/^use constant CMD_GET        => 0x00;$/;"	c
CMD_GET	t/binary.t	/^use constant CMD_GET        => 0x00;$/;"	c
CMD_GET	t/udp.t	/^use constant CMD_GET          => 0x00;$/;"	c
CMD_GETK	t/binary-extstore.t	/^use constant CMD_GETK       => 0x0C;$/;"	c
CMD_GETK	t/binary-sasl.t	/^use constant CMD_GETK       => 0x0C;$/;"	c
CMD_GETK	t/binary.t	/^use constant CMD_GETK       => 0x0C;$/;"	c
CMD_GETKQ	t/binary-extstore.t	/^use constant CMD_GETKQ      => 0x0D;$/;"	c
CMD_GETKQ	t/binary-sasl.t	/^use constant CMD_GETKQ      => 0x0D;$/;"	c
CMD_GETKQ	t/binary.t	/^use constant CMD_GETKQ      => 0x0D;$/;"	c
CMD_GETQ	t/binary-extstore.t	/^use constant CMD_GETQ       => 0x09;$/;"	c
CMD_GETQ	t/binary-sasl.t	/^use constant CMD_GETQ       => 0x09;$/;"	c
CMD_GETQ	t/binary.t	/^use constant CMD_GETQ       => 0x09;$/;"	c
CMD_INCR	t/binary-extstore.t	/^use constant CMD_INCR       => 0x05;$/;"	c
CMD_INCR	t/binary-sasl.t	/^use constant CMD_INCR       => 0x05;$/;"	c
CMD_INCR	t/binary.t	/^use constant CMD_INCR       => 0x05;$/;"	c
CMD_INCR	t/udp.t	/^use constant CMD_INCR         => 0x05;$/;"	c
CMD_INCREMENTQ	t/binary-extstore.t	/^use constant CMD_INCREMENTQ => 0x15;$/;"	c
CMD_INCREMENTQ	t/binary-sasl.t	/^use constant CMD_INCREMENTQ => 0x15;$/;"	c
CMD_INCREMENTQ	t/binary.t	/^use constant CMD_INCREMENTQ => 0x15;$/;"	c
CMD_NOOP	t/binary-extstore.t	/^use constant CMD_NOOP       => 0x0A;$/;"	c
CMD_NOOP	t/binary-sasl.t	/^use constant CMD_NOOP       => 0x0A;$/;"	c
CMD_NOOP	t/binary.t	/^use constant CMD_NOOP       => 0x0A;$/;"	c
CMD_PREPEND	t/binary-extstore.t	/^use constant CMD_PREPEND    => 0x0F;$/;"	c
CMD_PREPEND	t/binary-sasl.t	/^use constant CMD_PREPEND    => 0x0F;$/;"	c
CMD_PREPEND	t/binary.t	/^use constant CMD_PREPEND    => 0x0F;$/;"	c
CMD_PREPEND	t/udp.t	/^use constant CMD_PREPEND      => 0x0F;$/;"	c
CMD_PREPENDQ	t/binary-extstore.t	/^use constant CMD_PREPENDQ   => 0x1A;$/;"	c
CMD_PREPENDQ	t/binary-sasl.t	/^use constant CMD_PREPENDQ   => 0x1A;$/;"	c
CMD_PREPENDQ	t/binary.t	/^use constant CMD_PREPENDQ   => 0x1A;$/;"	c
CMD_QUIT	t/binary-extstore.t	/^use constant CMD_QUIT       => 0x07;$/;"	c
CMD_QUIT	t/binary-sasl.t	/^use constant CMD_QUIT       => 0x07;$/;"	c
CMD_QUIT	t/binary.t	/^use constant CMD_QUIT       => 0x07;$/;"	c
CMD_QUITQ	t/binary-extstore.t	/^use constant CMD_QUITQ      => 0x17;$/;"	c
CMD_QUITQ	t/binary-sasl.t	/^use constant CMD_QUITQ      => 0x17;$/;"	c
CMD_QUITQ	t/binary.t	/^use constant CMD_QUITQ      => 0x17;$/;"	c
CMD_REPLACE	t/binary-extstore.t	/^use constant CMD_REPLACE    => 0x03;$/;"	c
CMD_REPLACE	t/binary-sasl.t	/^use constant CMD_REPLACE    => 0x03;$/;"	c
CMD_REPLACE	t/binary.t	/^use constant CMD_REPLACE    => 0x03;$/;"	c
CMD_REPLACE	t/udp.t	/^use constant CMD_REPLACE      => 0x03;$/;"	c
CMD_REPLACEQ	t/binary-extstore.t	/^use constant CMD_REPLACEQ   => 0x13;$/;"	c
CMD_REPLACEQ	t/binary-sasl.t	/^use constant CMD_REPLACEQ   => 0x13;$/;"	c
CMD_REPLACEQ	t/binary.t	/^use constant CMD_REPLACEQ   => 0x13;$/;"	c
CMD_SASL_AUTH	t/binary-sasl.t	/^use constant CMD_SASL_AUTH          => 0x21;$/;"	c
CMD_SASL_LIST_MECHS	t/binary-sasl.t	/^use constant CMD_SASL_LIST_MECHS    => 0x20;$/;"	c
CMD_SASL_STEP	t/binary-sasl.t	/^use constant CMD_SASL_STEP          => 0x22;$/;"	c
CMD_SET	t/binary-extstore.t	/^use constant CMD_SET        => 0x01;$/;"	c
CMD_SET	t/binary-sasl.t	/^use constant CMD_SET        => 0x01;$/;"	c
CMD_SET	t/binary.t	/^use constant CMD_SET        => 0x01;$/;"	c
CMD_SET	t/udp.t	/^use constant CMD_SET          => 0x01;$/;"	c
CMD_SETQ	t/binary-extstore.t	/^use constant CMD_SETQ       => 0x11;$/;"	c
CMD_SETQ	t/binary-sasl.t	/^use constant CMD_SETQ       => 0x11;$/;"	c
CMD_SETQ	t/binary.t	/^use constant CMD_SETQ       => 0x11;$/;"	c
CMD_STAT	t/binary-extstore.t	/^use constant CMD_STAT       => 0x10;$/;"	c
CMD_STAT	t/binary-sasl.t	/^use constant CMD_STAT       => 0x10;$/;"	c
CMD_STAT	t/binary.t	/^use constant CMD_STAT       => 0x10;$/;"	c
CMD_TOUCH	t/binary-extstore.t	/^use constant CMD_TOUCH      => 0x1C;$/;"	c
CMD_TOUCH	t/binary.t	/^use constant CMD_TOUCH      => 0x1C;$/;"	c
CMD_VERSION	t/binary-extstore.t	/^use constant CMD_VERSION    => 0x0B;$/;"	c
CMD_VERSION	t/binary-sasl.t	/^use constant CMD_VERSION    => 0x0B;$/;"	c
CMD_VERSION	t/binary.t	/^use constant CMD_VERSION    => 0x0B;$/;"	c
COLD_LRU	items.h	3;"	d
COMMAND_TOKEN	memcached.c	2931;"	d	file:
CONFIG_CLEAN_FILES	doc/Makefile	/^CONFIG_CLEAN_FILES =$/;"	m
CONFIG_CLEAN_VPATH_FILES	doc/Makefile	/^CONFIG_CLEAN_VPATH_FILES =$/;"	m
CONFIG_HEADER	doc/Makefile	/^CONFIG_HEADER = $(top_builddir)\/config.h$/;"	m
CONNS_PER_SLICE	memcached.c	336;"	d	file:
CPP	doc/Makefile	/^CPP = gcc -E$/;"	m
CPPFLAGS	doc/Makefile	/^CPPFLAGS = $/;"	m
CQ	thread.c	/^typedef struct conn_queue CQ;$/;"	t	typeref:struct:conn_queue	file:
CQ_ITEM	thread.c	/^typedef struct conn_queue_item CQ_ITEM;$/;"	t	typeref:struct:conn_queue_item	file:
CRAWLER_AUTOEXPIRE	memcached.h	/^    CRAWLER_AUTOEXPIRE=0, CRAWLER_EXPIRED, CRAWLER_METADUMP$/;"	e	enum:crawler_run_type
CRAWLER_BADCLASS	crawler.h	/^    CRAWLER_OK=0, CRAWLER_RUNNING, CRAWLER_BADCLASS, CRAWLER_NOTSTARTED, CRAWLER_ERROR$/;"	e	enum:crawler_result_type
CRAWLER_ERROR	crawler.h	/^    CRAWLER_OK=0, CRAWLER_RUNNING, CRAWLER_BADCLASS, CRAWLER_NOTSTARTED, CRAWLER_ERROR$/;"	e	enum:crawler_result_type
CRAWLER_EXPIRED	memcached.h	/^    CRAWLER_AUTOEXPIRE=0, CRAWLER_EXPIRED, CRAWLER_METADUMP$/;"	e	enum:crawler_run_type
CRAWLER_H	crawler.h	2;"	d
CRAWLER_METADUMP	memcached.h	/^    CRAWLER_AUTOEXPIRE=0, CRAWLER_EXPIRED, CRAWLER_METADUMP$/;"	e	enum:crawler_run_type
CRAWLER_NOTSTARTED	crawler.h	/^    CRAWLER_OK=0, CRAWLER_RUNNING, CRAWLER_BADCLASS, CRAWLER_NOTSTARTED, CRAWLER_ERROR$/;"	e	enum:crawler_result_type
CRAWLER_OK	crawler.h	/^    CRAWLER_OK=0, CRAWLER_RUNNING, CRAWLER_BADCLASS, CRAWLER_NOTSTARTED, CRAWLER_ERROR$/;"	e	enum:crawler_result_type
CRAWLER_RUNNING	crawler.h	/^    CRAWLER_OK=0, CRAWLER_RUNNING, CRAWLER_BADCLASS, CRAWLER_NOTSTARTED, CRAWLER_ERROR$/;"	e	enum:crawler_result_type
CRC32CB	crc32c.c	122;"	d	file:
CRC32CH	crc32c.c	121;"	d	file:
CRC32CW	crc32c.c	120;"	d	file:
CRC32CX	crc32c.c	119;"	d	file:
CRC32C_H	crc32c.h	2;"	d
CYGPATH_W	doc/Makefile	/^CYGPATH_W = echo$/;"	m
DATA_BUFFER_SIZE	memcached.h	41;"	d
DEBUG_REFCNT	items.c	154;"	d	file:
DEFAULT_HASH_BULK_MOVE	assoc.c	196;"	d	file:
DEFAULT_SLAB_BULK_CHECK	slabs.c	672;"	d	file:
DEFS	doc/Makefile	/^DEFS = -DHAVE_CONFIG_H$/;"	m
DELTA_ITEM_CAS_MISMATCH	memcached.h	/^    OK, NON_NUMERIC, EOM, DELTA_ITEM_NOT_FOUND, DELTA_ITEM_CAS_MISMATCH$/;"	e	enum:delta_result_type
DELTA_ITEM_NOT_FOUND	memcached.h	/^    OK, NON_NUMERIC, EOM, DELTA_ITEM_NOT_FOUND, DELTA_ITEM_CAS_MISMATCH$/;"	e	enum:delta_result_type
DENY_ACTION	linux_priv.c	9;"	d	file:
DEPDIR	doc/Makefile	/^DEPDIR = .deps$/;"	m
DESTROY	t/lib/MemcachedTest.pm	/^sub DESTROY {$/;"	s
DISTFILES	doc/Makefile	/^DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)$/;"	m
DIST_COMMON	doc/Makefile	/^DIST_COMMON = $(srcdir)\/Makefile.am $(am__DIST_COMMON)$/;"	m
DIST_SOURCES	doc/Makefile	/^DIST_SOURCES =$/;"	m
DONT_UPDATE	memcached.h	733;"	d
DO_UPDATE	memcached.h	732;"	d
DTRACE	doc/Makefile	/^DTRACE = $/;"	m
DTRACEFLAGS	doc/Makefile	/^DTRACEFLAGS = $/;"	m
ECHO_C	doc/Makefile	/^ECHO_C = $/;"	m
ECHO_N	doc/Makefile	/^ECHO_N = -n$/;"	m
ECHO_T	doc/Makefile	/^ECHO_T = $/;"	m
EGREP	doc/Makefile	/^EGREP = \/bin\/grep -E$/;"	m
ENABLE_SASL	doc/Makefile	/^ENABLE_SASL = $/;"	m
ENTRY_EXISTS	t/udp.t	/^use constant ENTRY_EXISTS     => 0;$/;"	c
ENTRY_MISSING	t/udp.t	/^use constant ENTRY_MISSING    => 1;$/;"	c
EOM	memcached.h	/^    OK, NON_NUMERIC, EOM, DELTA_ITEM_NOT_FOUND, DELTA_ITEM_CAS_MISMATCH$/;"	e	enum:delta_result_type
ERR_AUTH_ERROR	t/binary-sasl.t	/^use constant ERR_AUTH_ERROR   => 0x20;$/;"	c
ERR_DELTA_BADVAL	t/binary-extstore.t	/^use constant ERR_DELTA_BADVAL => 0x6;$/;"	c
ERR_DELTA_BADVAL	t/binary-sasl.t	/^use constant ERR_DELTA_BADVAL => 0x6;$/;"	c
ERR_DELTA_BADVAL	t/binary.t	/^use constant ERR_DELTA_BADVAL => 0x6;$/;"	c
ERR_EINVAL	t/binary-extstore.t	/^use constant ERR_EINVAL       => 0x4;$/;"	c
ERR_EINVAL	t/binary-sasl.t	/^use constant ERR_EINVAL       => 0x4;$/;"	c
ERR_EINVAL	t/binary.t	/^use constant ERR_EINVAL       => 0x4;$/;"	c
ERR_EXISTS	t/binary-extstore.t	/^use constant ERR_EXISTS       => 0x2;$/;"	c
ERR_EXISTS	t/binary-sasl.t	/^use constant ERR_EXISTS       => 0x2;$/;"	c
ERR_EXISTS	t/binary.t	/^use constant ERR_EXISTS       => 0x2;$/;"	c
ERR_NOT_FOUND	t/binary-extstore.t	/^use constant ERR_NOT_FOUND    => 0x1;$/;"	c
ERR_NOT_FOUND	t/binary-sasl.t	/^use constant ERR_NOT_FOUND    => 0x1;$/;"	c
ERR_NOT_FOUND	t/binary.t	/^use constant ERR_NOT_FOUND    => 0x1;$/;"	c
ERR_NOT_STORED	t/binary-extstore.t	/^use constant ERR_NOT_STORED   => 0x5;$/;"	c
ERR_NOT_STORED	t/binary-sasl.t	/^use constant ERR_NOT_STORED   => 0x5;$/;"	c
ERR_NOT_STORED	t/binary.t	/^use constant ERR_NOT_STORED   => 0x5;$/;"	c
ERR_TOO_BIG	t/binary-extstore.t	/^use constant ERR_TOO_BIG      => 0x3;$/;"	c
ERR_TOO_BIG	t/binary-sasl.t	/^use constant ERR_TOO_BIG      => 0x3;$/;"	c
ERR_TOO_BIG	t/binary.t	/^use constant ERR_TOO_BIG      => 0x3;$/;"	c
ERR_UNKNOWN_CMD	t/binary-extstore.t	/^use constant ERR_UNKNOWN_CMD  => 0x81;$/;"	c
ERR_UNKNOWN_CMD	t/binary-sasl.t	/^use constant ERR_UNKNOWN_CMD  => 0x81;$/;"	c
ERR_UNKNOWN_CMD	t/binary.t	/^use constant ERR_UNKNOWN_CMD  => 0x81;$/;"	c
EXEEXT	doc/Makefile	/^EXEEXT = $/;"	m
EXISTS	memcached.h	/^    NOT_STORED=0, STORED, EXISTS, NOT_FOUND, TOO_LARGE, NO_MEMORY$/;"	e	enum:store_item_type
EXTRA_DIST	doc/Makefile	/^EXTRA_DIST = *.txt$/;"	m
EXTSTORE_H	extstore.h	2;"	d
EXTSTORE_INIT_BAD_WBUF_SIZE	extstore.h	/^    EXTSTORE_INIT_BAD_WBUF_SIZE = 1,$/;"	e	enum:extstore_res
EXTSTORE_INIT_NEED_MORE_BUCKETS	extstore.h	/^    EXTSTORE_INIT_NEED_MORE_BUCKETS,$/;"	e	enum:extstore_res
EXTSTORE_INIT_NEED_MORE_WBUF	extstore.h	/^    EXTSTORE_INIT_NEED_MORE_WBUF,$/;"	e	enum:extstore_res
EXTSTORE_INIT_OOM	extstore.h	/^    EXTSTORE_INIT_OOM,$/;"	e	enum:extstore_res
EXTSTORE_INIT_OPEN_FAIL	extstore.h	/^    EXTSTORE_INIT_OPEN_FAIL,$/;"	e	enum:extstore_res
EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT	extstore.h	/^    EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT,$/;"	e	enum:extstore_res
EXTSTORE_INIT_THREAD_FAIL	extstore.h	/^    EXTSTORE_INIT_THREAD_FAIL$/;"	e	enum:extstore_res
EXTSTORE_THREAD_STATS_FIELDS	memcached.h	277;"	d
E_DEBUG	extstore.c	22;"	d	file:
E_DEBUG	extstore.c	27;"	d	file:
FORCE_INLINE	murmur3_hash.c	19;"	d	file:
FORCE_INLINE	murmur3_hash.c	31;"	d	file:
GET_LOGGER	logger.h	11;"	d
GET_LRU	items.h	7;"	d
GREP	doc/Makefile	/^GREP = \/bin\/grep$/;"	m
HASHPOWER_DEFAULT	memcached.h	72;"	d
HASHPOWER_MAX	memcached.h	73;"	d
HASH_BIG_ENDIAN	jenkins_hash.c	22;"	d	file:
HASH_BIG_ENDIAN	jenkins_hash.c	26;"	d	file:
HASH_BIG_ENDIAN	jenkins_hash.c	29;"	d	file:
HASH_H	hash.h	2;"	d
HASH_LITTLE_ENDIAN	jenkins_hash.c	21;"	d	file:
HASH_LITTLE_ENDIAN	jenkins_hash.c	25;"	d	file:
HASH_LITTLE_ENDIAN	jenkins_hash.c	28;"	d	file:
HOT_LRU	items.h	1;"	d
HWCAP_CRC32	crc32c.c	125;"	d	file:
INCRDECR_PKT_FMT	t/binary-extstore.t	/^use constant INCRDECR_PKT_FMT => "NNNNN";$/;"	c
INCRDECR_PKT_FMT	t/binary-sasl.t	/^use constant INCRDECR_PKT_FMT => "NNNNN";$/;"	c
INCRDECR_PKT_FMT	t/binary.t	/^use constant INCRDECR_PKT_FMT => "NNNNN";$/;"	c
INCRDECR_PKT_FMT	t/udp.t	/^use constant INCRDECR_PKT_FMT => "NNNNN";$/;"	c
INCR_MAX_STORAGE_LEN	memcached.h	39;"	d
INSTALL	doc/Makefile	/^INSTALL = \/usr\/bin\/install -c$/;"	m
INSTALL_DATA	doc/Makefile	/^INSTALL_DATA = ${INSTALL} -m 644$/;"	m
INSTALL_HEADER	doc/Makefile	/^INSTALL_HEADER = $(INSTALL_DATA)$/;"	m
INSTALL_PROGRAM	doc/Makefile	/^INSTALL_PROGRAM = ${INSTALL}$/;"	m
INSTALL_SCRIPT	doc/Makefile	/^INSTALL_SCRIPT = ${INSTALL}$/;"	m
INSTALL_STRIP_PROGRAM	doc/Makefile	/^INSTALL_STRIP_PROGRAM = $(install_sh) -c -s$/;"	m
IOV_LIST_HIGHWAT	memcached.h	64;"	d
IOV_LIST_INITIAL	memcached.h	56;"	d
IOV_MAX	memcached.c	61;"	d	file:
IS_ASCII	t/udp.t	/^use constant IS_ASCII         => 0;$/;"	c
IS_BINARY	t/udp.t	/^use constant IS_BINARY        => 1;$/;"	c
IS_TCP	memcached.h	214;"	d
IS_UDP	memcached.h	215;"	d
ITEMS_PER_ALLOC	thread.c	20;"	d	file:
ITEM_ACTIVE	memcached.h	444;"	d
ITEM_CAS	memcached.h	436;"	d
ITEM_CHUNK	memcached.h	447;"	d
ITEM_CHUNKED	memcached.h	446;"	d
ITEM_FETCHED	memcached.h	442;"	d
ITEM_HDR	memcached.h	450;"	d
ITEM_LINKED	memcached.h	435;"	d
ITEM_LIST_HIGHWAT	memcached.h	63;"	d
ITEM_LIST_INITIAL	memcached.h	50;"	d
ITEM_SLABBED	memcached.h	439;"	d
ITEM_UPDATE_INTERVAL	memcached.h	80;"	d
ITEM_clsid	memcached.h	123;"	d
ITEM_data	memcached.h	115;"	d
ITEM_get_cas	memcached.h	100;"	d
ITEM_key	memcached.h	109;"	d
ITEM_lruid	memcached.h	124;"	d
ITEM_ntotal	memcached.h	119;"	d
ITEM_set_cas	memcached.h	103;"	d
ITEM_suffix	memcached.h	112;"	d
ITERATIONS	testapp.c	122;"	d	file:
ITERATIONS	testapp.c	135;"	d	file:
ITOA_LJUST_H	itoa_ljust.h	2;"	d
IT_REFCOUNT_LIMIT	memcached.c	3518;"	d	file:
JENKINS_HASH	hash.h	/^    JENKINS_HASH=0, MURMUR3_HASH$/;"	e	enum:hashfunc_type
JENKINS_HASH_H	jenkins_hash.h	2;"	d
KEY_MAX_LENGTH	memcached.h	36;"	d
KEY_TOKEN	memcached.c	2933;"	d	file:
LARGEST_ID	crawler.c	24;"	d	file:
LARGEST_ID	items.c	30;"	d	file:
LDFLAGS	doc/Makefile	/^LDFLAGS = $/;"	m
LIBEVENT_THREAD	memcached.h	/^} LIBEVENT_THREAD;$/;"	t	typeref:struct:__anon54
LIBOBJS	doc/Makefile	/^LIBOBJS = $/;"	m
LIBS	doc/Makefile	/^LIBS = -levent $/;"	m
LOGGER_ADD_WATCHER_FAILED	logger.h	/^    LOGGER_ADD_WATCHER_FAILED$/;"	e	enum:logger_add_watcher_ret
LOGGER_ADD_WATCHER_OK	logger.h	/^    LOGGER_ADD_WATCHER_OK,$/;"	e	enum:logger_add_watcher_ret
LOGGER_ADD_WATCHER_TOO_MANY	logger.h	/^    LOGGER_ADD_WATCHER_TOO_MANY = 0,$/;"	e	enum:logger_add_watcher_ret
LOGGER_ASCII_CMD	logger.h	/^    LOGGER_ASCII_CMD = 0,$/;"	e	enum:log_entry_type
LOGGER_BUF_SIZE	logger.h	8;"	d
LOGGER_COMPACT_ABORT	logger.h	/^    LOGGER_COMPACT_ABORT,$/;"	e	enum:log_entry_type
LOGGER_COMPACT_END	logger.h	/^    LOGGER_COMPACT_END,$/;"	e	enum:log_entry_type
LOGGER_COMPACT_FRAGINFO	logger.h	/^    LOGGER_COMPACT_FRAGINFO,$/;"	e	enum:log_entry_type
LOGGER_COMPACT_READ_END	logger.h	/^    LOGGER_COMPACT_READ_END,$/;"	e	enum:log_entry_type
LOGGER_COMPACT_READ_START	logger.h	/^    LOGGER_COMPACT_READ_START,$/;"	e	enum:log_entry_type
LOGGER_COMPACT_START	logger.h	/^    LOGGER_COMPACT_START,$/;"	e	enum:log_entry_type
LOGGER_CRAWLER_STATUS	logger.h	/^    LOGGER_CRAWLER_STATUS,$/;"	e	enum:log_entry_type
LOGGER_ENTRY_MAX_SIZE	logger.h	10;"	d
LOGGER_EVICTION	logger.h	/^    LOGGER_EVICTION,$/;"	e	enum:log_entry_type
LOGGER_EVICTION_ENTRY	logger.h	/^    LOGGER_EVICTION_ENTRY,$/;"	e	enum:log_entry_subtype
LOGGER_EXTSTORE_WRITE	logger.h	/^    LOGGER_EXTSTORE_WRITE,$/;"	e	enum:log_entry_type
LOGGER_EXT_WRITE_ENTRY	logger.h	/^    LOGGER_EXT_WRITE_ENTRY,$/;"	e	enum:log_entry_subtype
LOGGER_H	logger.h	3;"	d
LOGGER_ITEM_GET	logger.h	/^    LOGGER_ITEM_GET,$/;"	e	enum:log_entry_type
LOGGER_ITEM_GET_ENTRY	logger.h	/^    LOGGER_ITEM_GET_ENTRY,$/;"	e	enum:log_entry_subtype
LOGGER_ITEM_STORE	logger.h	/^    LOGGER_ITEM_STORE,$/;"	e	enum:log_entry_type
LOGGER_ITEM_STORE_ENTRY	logger.h	/^    LOGGER_ITEM_STORE_ENTRY,$/;"	e	enum:log_entry_subtype
LOGGER_LOG	logger.h	169;"	d
LOGGER_PARSE_ENTRY_FAILED	logger.h	/^    LOGGER_PARSE_ENTRY_FAILED$/;"	e	enum:logger_parse_entry_ret
LOGGER_PARSE_ENTRY_FULLBUF	logger.h	/^    LOGGER_PARSE_ENTRY_FULLBUF,$/;"	e	enum:logger_parse_entry_ret
LOGGER_PARSE_ENTRY_OK	logger.h	/^    LOGGER_PARSE_ENTRY_OK = 0,$/;"	e	enum:logger_parse_entry_ret
LOGGER_PARSE_SCRATCH	logger.c	171;"	d	file:
LOGGER_RET_ERR	logger.h	/^    LOGGER_RET_ERR$/;"	e	enum:logger_ret_type
LOGGER_RET_NOSPACE	logger.h	/^    LOGGER_RET_NOSPACE,$/;"	e	enum:logger_ret_type
LOGGER_RET_OK	logger.h	/^    LOGGER_RET_OK = 0,$/;"	e	enum:logger_ret_type
LOGGER_SLAB_MOVE	logger.h	/^    LOGGER_SLAB_MOVE,$/;"	e	enum:log_entry_type
LOGGER_TEXT_ENTRY	logger.h	/^    LOGGER_TEXT_ENTRY = 0,$/;"	e	enum:log_entry_subtype
LOGGER_WATCHER_BUF_SIZE	logger.h	9;"	d
LOGGER_WATCHER_CLIENT	logger.h	/^    LOGGER_WATCHER_CLIENT = 1$/;"	e	enum:logger_watcher_type
LOGGER_WATCHER_STDERR	logger.h	/^    LOGGER_WATCHER_STDERR = 0,$/;"	e	enum:logger_watcher_type
LOG_CONNEVENTS	logger.h	118;"	d
LOG_EVICTIONS	logger.h	119;"	d
LOG_FETCHERS	logger.h	115;"	d
LOG_MUTATIONS	logger.h	116;"	d
LOG_RAWCMDS	logger.h	121;"	d
LOG_STRICT	logger.h	120;"	d
LOG_SYSERRORS	logger.h	117;"	d
LOG_SYSEVENTS	logger.h	114;"	d
LONG	crc32c.c	266;"	d	file:
LONGx1	crc32c.c	267;"	d	file:
LONGx2	crc32c.c	268;"	d	file:
LRU_BUMP_BUF_SIZE	items.c	103;"	d	file:
LRU_CRAWLER_CAP_REMAINING	crawler.h	4;"	d
LRU_CRAWLER_WRITEBUF	crawler.c	109;"	d	file:
LRU_PULL_CRAWL_BLOCKS	items.h	37;"	d
LRU_PULL_EVICT	items.h	36;"	d
LRU_PULL_RETURN_ITEM	items.h	38;"	d
LTLIBOBJS	doc/Makefile	/^LTLIBOBJS = $/;"	m
L_DEBUG	logger.c	18;"	d	file:
L_DEBUG	logger.c	23;"	d	file:
MAKEINFO	doc/Makefile	/^MAKEINFO = ${SHELL} \/home\/dormando\/d\/p\/danga\/git\/memcached\/missing makeinfo$/;"	m
MANS	doc/Makefile	/^MANS = $(man_MANS)$/;"	m
MAXPATHLEN	memcached.c	65;"	d	file:
MAX_ENTRY_LEN	sasl_defs.c	26;"	d	file:
MAX_LOGGER_SLEEP	logger.c	500;"	d	file:
MAX_LRU_MAINTAINER_SLEEP	items.c	1532;"	d	file:
MAX_MAINTCRAWL_WAIT	crawler.c	105;"	d	file:
MAX_MAINTCRAWL_WAIT	items.c	1411;"	d	file:
MAX_NUMBER_OF_SLAB_CLASSES	memcached.h	93;"	d
MAX_SASL_MECH_LEN	sasl_defs.h	5;"	d
MAX_SENDBUF_SIZE	memcached.h	45;"	d
MAX_STORAGE_COMPACT_SLEEP	storage.c	202;"	d	file:
MAX_TOKENS	memcached.c	2935;"	d	file:
MAX_VERBOSITY_LEVEL	memcached.h	351;"	d
MC::Client	t/binary-extstore.t	/^package MC::Client;$/;"	p
MC::Client	t/binary-sasl.t	/^package MC::Client;$/;"	p
MC::Client	t/binary.t	/^package MC::Client;$/;"	p
MC::Client::ERR_AUTH_ERROR	t/binary-sasl.t	/^use constant ERR_AUTH_ERROR   => 0x20;$/;"	c
MC::Client::_append_prepend	t/binary-extstore.t	/^sub _append_prepend {$/;"	s
MC::Client::_append_prepend	t/binary-sasl.t	/^sub _append_prepend {$/;"	s
MC::Client::_append_prepend	t/binary.t	/^sub _append_prepend {$/;"	s
MC::Client::_do_command	t/binary-extstore.t	/^sub _do_command {$/;"	s
MC::Client::_do_command	t/binary-sasl.t	/^sub _do_command {$/;"	s
MC::Client::_do_command	t/binary.t	/^sub _do_command {$/;"	s
MC::Client::_handle_single_response	t/binary-extstore.t	/^sub _handle_single_response {$/;"	s
MC::Client::_handle_single_response	t/binary-sasl.t	/^sub _handle_single_response {$/;"	s
MC::Client::_handle_single_response	t/binary.t	/^sub _handle_single_response {$/;"	s
MC::Client::_incrdecr	t/binary-extstore.t	/^sub _incrdecr {$/;"	s
MC::Client::_incrdecr	t/binary-sasl.t	/^sub _incrdecr {$/;"	s
MC::Client::_incrdecr	t/binary.t	/^sub _incrdecr {$/;"	s
MC::Client::_incrdecr_cas	t/binary-extstore.t	/^sub _incrdecr_cas {$/;"	s
MC::Client::_incrdecr_cas	t/binary.t	/^sub _incrdecr_cas {$/;"	s
MC::Client::_incrdecr_header	t/binary-extstore.t	/^sub _incrdecr_header {$/;"	s
MC::Client::_incrdecr_header	t/binary-sasl.t	/^sub _incrdecr_header {$/;"	s
MC::Client::_incrdecr_header	t/binary.t	/^sub _incrdecr_header {$/;"	s
MC::Client::add	t/binary-extstore.t	/^sub add {$/;"	s
MC::Client::add	t/binary-sasl.t	/^sub add {$/;"	s
MC::Client::add	t/binary.t	/^sub add {$/;"	s
MC::Client::authenticate	t/binary-sasl.t	/^sub authenticate {$/;"	s
MC::Client::build_command	t/binary-extstore.t	/^sub build_command {$/;"	s
MC::Client::build_command	t/binary-sasl.t	/^sub build_command {$/;"	s
MC::Client::build_command	t/binary.t	/^sub build_command {$/;"	s
MC::Client::decr	t/binary-extstore.t	/^sub decr {$/;"	s
MC::Client::decr	t/binary-sasl.t	/^sub decr {$/;"	s
MC::Client::decr	t/binary.t	/^sub decr {$/;"	s
MC::Client::delete	t/binary-extstore.t	/^sub delete {$/;"	s
MC::Client::delete	t/binary-sasl.t	/^sub delete {$/;"	s
MC::Client::delete	t/binary.t	/^sub delete {$/;"	s
MC::Client::flush	t/binary-extstore.t	/^sub flush {$/;"	s
MC::Client::flush	t/binary-sasl.t	/^sub flush {$/;"	s
MC::Client::flush	t/binary.t	/^sub flush {$/;"	s
MC::Client::flush_socket	t/binary-extstore.t	/^sub flush_socket {$/;"	s
MC::Client::flush_socket	t/binary-sasl.t	/^sub flush_socket {$/;"	s
MC::Client::flush_socket	t/binary.t	/^sub flush_socket {$/;"	s
MC::Client::gat	t/binary-extstore.t	/^sub gat {$/;"	s
MC::Client::gat	t/binary.t	/^sub gat {$/;"	s
MC::Client::get	t/binary-extstore.t	/^sub get {$/;"	s
MC::Client::get	t/binary-sasl.t	/^sub get {$/;"	s
MC::Client::get	t/binary.t	/^sub get {$/;"	s
MC::Client::get_multi	t/binary-extstore.t	/^sub get_multi {$/;"	s
MC::Client::get_multi	t/binary-sasl.t	/^sub get_multi {$/;"	s
MC::Client::get_multi	t/binary.t	/^sub get_multi {$/;"	s
MC::Client::incr	t/binary-extstore.t	/^sub incr {$/;"	s
MC::Client::incr	t/binary-sasl.t	/^sub incr {$/;"	s
MC::Client::incr	t/binary.t	/^sub incr {$/;"	s
MC::Client::incr_cas	t/binary-extstore.t	/^sub incr_cas {$/;"	s
MC::Client::incr_cas	t/binary.t	/^sub incr_cas {$/;"	s
MC::Client::list_mechs	t/binary-sasl.t	/^sub list_mechs {$/;"	s
MC::Client::new	t/binary-extstore.t	/^sub new {$/;"	s
MC::Client::new	t/binary-sasl.t	/^sub new {$/;"	s
MC::Client::new	t/binary.t	/^sub new {$/;"	s
MC::Client::noop	t/binary-extstore.t	/^sub noop {$/;"	s
MC::Client::noop	t/binary-sasl.t	/^sub noop {$/;"	s
MC::Client::noop	t/binary.t	/^sub noop {$/;"	s
MC::Client::replace	t/binary-extstore.t	/^sub replace {$/;"	s
MC::Client::replace	t/binary-sasl.t	/^sub replace {$/;"	s
MC::Client::replace	t/binary.t	/^sub replace {$/;"	s
MC::Client::send_command	t/binary-extstore.t	/^sub send_command {$/;"	s
MC::Client::send_command	t/binary-sasl.t	/^sub send_command {$/;"	s
MC::Client::send_command	t/binary.t	/^sub send_command {$/;"	s
MC::Client::send_silent	t/binary-extstore.t	/^sub send_silent {$/;"	s
MC::Client::send_silent	t/binary-sasl.t	/^sub send_silent {$/;"	s
MC::Client::send_silent	t/binary.t	/^sub send_silent {$/;"	s
MC::Client::set	t/binary-extstore.t	/^sub set {$/;"	s
MC::Client::set	t/binary-sasl.t	/^sub set {$/;"	s
MC::Client::set	t/binary.t	/^sub set {$/;"	s
MC::Client::silent_incrdecr	t/binary-extstore.t	/^sub silent_incrdecr {$/;"	s
MC::Client::silent_incrdecr	t/binary-sasl.t	/^sub silent_incrdecr {$/;"	s
MC::Client::silent_incrdecr	t/binary.t	/^sub silent_incrdecr {$/;"	s
MC::Client::silent_mutation	t/binary-extstore.t	/^sub silent_mutation {$/;"	s
MC::Client::silent_mutation	t/binary-sasl.t	/^sub silent_mutation {$/;"	s
MC::Client::silent_mutation	t/binary.t	/^sub silent_mutation {$/;"	s
MC::Client::stats	t/binary-extstore.t	/^sub stats {$/;"	s
MC::Client::stats	t/binary-sasl.t	/^sub stats {$/;"	s
MC::Client::stats	t/binary.t	/^sub stats {$/;"	s
MC::Client::touch	t/binary-extstore.t	/^sub touch {$/;"	s
MC::Client::touch	t/binary.t	/^sub touch {$/;"	s
MC::Client::version	t/binary-extstore.t	/^sub version {$/;"	s
MC::Client::version	t/binary-sasl.t	/^sub version {$/;"	s
MC::Client::version	t/binary.t	/^sub version {$/;"	s
MC::Error	t/binary-extstore.t	/^package MC::Error;$/;"	p
MC::Error	t/binary-sasl.t	/^package MC::Error;$/;"	p
MC::Error	t/binary.t	/^package MC::Error;$/;"	p
MC::Error::ERR_AUTH_ERROR	t/binary-sasl.t	/^use constant ERR_AUTH_ERROR   => 0x20;$/;"	c
MC::Error::ERR_DELTA_BADVAL	t/binary-extstore.t	/^use constant ERR_DELTA_BADVAL => 0x6;$/;"	c
MC::Error::ERR_DELTA_BADVAL	t/binary-sasl.t	/^use constant ERR_DELTA_BADVAL => 0x6;$/;"	c
MC::Error::ERR_DELTA_BADVAL	t/binary.t	/^use constant ERR_DELTA_BADVAL => 0x6;$/;"	c
MC::Error::ERR_EINVAL	t/binary-extstore.t	/^use constant ERR_EINVAL       => 0x4;$/;"	c
MC::Error::ERR_EINVAL	t/binary-sasl.t	/^use constant ERR_EINVAL       => 0x4;$/;"	c
MC::Error::ERR_EINVAL	t/binary.t	/^use constant ERR_EINVAL       => 0x4;$/;"	c
MC::Error::ERR_EXISTS	t/binary-extstore.t	/^use constant ERR_EXISTS       => 0x2;$/;"	c
MC::Error::ERR_EXISTS	t/binary-sasl.t	/^use constant ERR_EXISTS       => 0x2;$/;"	c
MC::Error::ERR_EXISTS	t/binary.t	/^use constant ERR_EXISTS       => 0x2;$/;"	c
MC::Error::ERR_NOT_FOUND	t/binary-extstore.t	/^use constant ERR_NOT_FOUND    => 0x1;$/;"	c
MC::Error::ERR_NOT_FOUND	t/binary-sasl.t	/^use constant ERR_NOT_FOUND    => 0x1;$/;"	c
MC::Error::ERR_NOT_FOUND	t/binary.t	/^use constant ERR_NOT_FOUND    => 0x1;$/;"	c
MC::Error::ERR_NOT_STORED	t/binary-extstore.t	/^use constant ERR_NOT_STORED   => 0x5;$/;"	c
MC::Error::ERR_NOT_STORED	t/binary-sasl.t	/^use constant ERR_NOT_STORED   => 0x5;$/;"	c
MC::Error::ERR_NOT_STORED	t/binary.t	/^use constant ERR_NOT_STORED   => 0x5;$/;"	c
MC::Error::ERR_TOO_BIG	t/binary-extstore.t	/^use constant ERR_TOO_BIG      => 0x3;$/;"	c
MC::Error::ERR_TOO_BIG	t/binary-sasl.t	/^use constant ERR_TOO_BIG      => 0x3;$/;"	c
MC::Error::ERR_TOO_BIG	t/binary.t	/^use constant ERR_TOO_BIG      => 0x3;$/;"	c
MC::Error::ERR_UNKNOWN_CMD	t/binary-extstore.t	/^use constant ERR_UNKNOWN_CMD  => 0x81;$/;"	c
MC::Error::ERR_UNKNOWN_CMD	t/binary-sasl.t	/^use constant ERR_UNKNOWN_CMD  => 0x81;$/;"	c
MC::Error::ERR_UNKNOWN_CMD	t/binary.t	/^use constant ERR_UNKNOWN_CMD  => 0x81;$/;"	c
MC::Error::auth_error	t/binary-sasl.t	/^sub auth_error {$/;"	s
MC::Error::delta_badval	t/binary-extstore.t	/^sub delta_badval {$/;"	s
MC::Error::delta_badval	t/binary-sasl.t	/^sub delta_badval {$/;"	s
MC::Error::delta_badval	t/binary.t	/^sub delta_badval {$/;"	s
MC::Error::einval	t/binary-extstore.t	/^sub einval {$/;"	s
MC::Error::einval	t/binary.t	/^sub einval {$/;"	s
MC::Error::exists	t/binary-extstore.t	/^sub exists {$/;"	s
MC::Error::exists	t/binary-sasl.t	/^sub exists {$/;"	s
MC::Error::exists	t/binary.t	/^sub exists {$/;"	s
MC::Error::new	t/binary-extstore.t	/^sub new {$/;"	s
MC::Error::new	t/binary-sasl.t	/^sub new {$/;"	s
MC::Error::new	t/binary.t	/^sub new {$/;"	s
MC::Error::not_found	t/binary-extstore.t	/^sub not_found {$/;"	s
MC::Error::not_found	t/binary-sasl.t	/^sub not_found {$/;"	s
MC::Error::not_found	t/binary.t	/^sub not_found {$/;"	s
MC::Error::too_big	t/binary-extstore.t	/^sub too_big {$/;"	s
MC::Error::too_big	t/binary-sasl.t	/^sub too_big {$/;"	s
MC::Error::too_big	t/binary.t	/^sub too_big {$/;"	s
MEMCACHED_ASSOC_DELETE	trace.h	7;"	d
MEMCACHED_ASSOC_DELETE_ENABLED	trace.h	8;"	d
MEMCACHED_ASSOC_FIND	trace.h	9;"	d
MEMCACHED_ASSOC_FIND_ENABLED	trace.h	10;"	d
MEMCACHED_ASSOC_INSERT	trace.h	11;"	d
MEMCACHED_ASSOC_INSERT_ENABLED	trace.h	12;"	d
MEMCACHED_COMMAND_ADD	trace.h	13;"	d
MEMCACHED_COMMAND_ADD_ENABLED	trace.h	14;"	d
MEMCACHED_COMMAND_APPEND	trace.h	15;"	d
MEMCACHED_COMMAND_APPEND_ENABLED	trace.h	16;"	d
MEMCACHED_COMMAND_CAS	trace.h	17;"	d
MEMCACHED_COMMAND_CAS_ENABLED	trace.h	18;"	d
MEMCACHED_COMMAND_DECR	trace.h	19;"	d
MEMCACHED_COMMAND_DECR_ENABLED	trace.h	20;"	d
MEMCACHED_COMMAND_DELETE	trace.h	21;"	d
MEMCACHED_COMMAND_DELETE_ENABLED	trace.h	22;"	d
MEMCACHED_COMMAND_GET	trace.h	23;"	d
MEMCACHED_COMMAND_GET_ENABLED	trace.h	24;"	d
MEMCACHED_COMMAND_INCR	trace.h	27;"	d
MEMCACHED_COMMAND_INCR_ENABLED	trace.h	28;"	d
MEMCACHED_COMMAND_PREPEND	trace.h	29;"	d
MEMCACHED_COMMAND_PREPEND_ENABLED	trace.h	30;"	d
MEMCACHED_COMMAND_REPLACE	trace.h	31;"	d
MEMCACHED_COMMAND_REPLACE_ENABLED	trace.h	32;"	d
MEMCACHED_COMMAND_SET	trace.h	33;"	d
MEMCACHED_COMMAND_SET_ENABLED	trace.h	34;"	d
MEMCACHED_COMMAND_TOUCH	trace.h	25;"	d
MEMCACHED_COMMAND_TOUCH_ENABLED	trace.h	26;"	d
MEMCACHED_CONN_ALLOCATE	trace.h	35;"	d
MEMCACHED_CONN_ALLOCATE_ENABLED	trace.h	36;"	d
MEMCACHED_CONN_CREATE	trace.h	37;"	d
MEMCACHED_CONN_CREATE_ENABLED	trace.h	38;"	d
MEMCACHED_CONN_DESTROY	trace.h	39;"	d
MEMCACHED_CONN_DESTROY_ENABLED	trace.h	40;"	d
MEMCACHED_CONN_DISPATCH	trace.h	41;"	d
MEMCACHED_CONN_DISPATCH_ENABLED	trace.h	42;"	d
MEMCACHED_CONN_RELEASE	trace.h	43;"	d
MEMCACHED_CONN_RELEASE_ENABLED	trace.h	44;"	d
MEMCACHED_ITEM_LINK	trace.h	45;"	d
MEMCACHED_ITEM_LINK_ENABLED	trace.h	46;"	d
MEMCACHED_ITEM_REMOVE	trace.h	47;"	d
MEMCACHED_ITEM_REMOVE_ENABLED	trace.h	48;"	d
MEMCACHED_ITEM_REPLACE	trace.h	49;"	d
MEMCACHED_ITEM_REPLACE_ENABLED	trace.h	50;"	d
MEMCACHED_ITEM_UNLINK	trace.h	51;"	d
MEMCACHED_ITEM_UNLINK_ENABLED	trace.h	52;"	d
MEMCACHED_ITEM_UPDATE	trace.h	53;"	d
MEMCACHED_ITEM_UPDATE_ENABLED	trace.h	54;"	d
MEMCACHED_PROCESS_COMMAND_END	trace.h	55;"	d
MEMCACHED_PROCESS_COMMAND_END_ENABLED	trace.h	56;"	d
MEMCACHED_PROCESS_COMMAND_START	trace.h	57;"	d
MEMCACHED_PROCESS_COMMAND_START_ENABLED	trace.h	58;"	d
MEMCACHED_SLABS_ALLOCATE	trace.h	59;"	d
MEMCACHED_SLABS_ALLOCATE_ENABLED	trace.h	60;"	d
MEMCACHED_SLABS_ALLOCATE_FAILED	trace.h	61;"	d
MEMCACHED_SLABS_ALLOCATE_FAILED_ENABLED	trace.h	62;"	d
MEMCACHED_SLABS_FREE	trace.h	63;"	d
MEMCACHED_SLABS_FREE_ENABLED	trace.h	64;"	d
MEMCACHED_SLABS_SLABCLASS_ALLOCATE	trace.h	65;"	d
MEMCACHED_SLABS_SLABCLASS_ALLOCATE_ENABLED	trace.h	66;"	d
MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED	trace.h	67;"	d
MEMCACHED_SLABS_SLABCLASS_ALLOCATE_FAILED_ENABLED	trace.h	68;"	d
MEMCHECK_PERIOD	slab_automove_extstore.c	16;"	d	file:
MIN_BIN_PKT_LENGTH	memcached.h	68;"	d
MIN_LOGGER_SLEEP	logger.c	501;"	d	file:
MIN_LRU_MAINTAINER_SLEEP	items.c	1533;"	d	file:
MIN_PAGES_FOR_RECLAIM	slab_automove.c	14;"	d	file:
MIN_PAGES_FOR_RECLAIM	slab_automove_extstore.c	14;"	d	file:
MIN_PAGES_FOR_SOURCE	slab_automove.c	13;"	d	file:
MIN_PAGES_FOR_SOURCE	slab_automove_extstore.c	13;"	d	file:
MIN_PAGES_FREE	slab_automove_extstore.c	15;"	d	file:
MIN_RECV_BYTES	t/binary-extstore.t	/^use constant MIN_RECV_BYTES   => length(pack(RES_PKT_FMT));$/;"	c
MIN_RECV_BYTES	t/binary-sasl.t	/^use constant MIN_RECV_BYTES   => length(pack(RES_PKT_FMT));$/;"	c
MIN_RECV_BYTES	t/binary.t	/^use constant MIN_RECV_BYTES   => length(pack(RES_PKT_FMT));$/;"	c
MIN_RECV_BYTES	t/udp.t	/^use constant MIN_RECV_BYTES   => length(pack(RES_PKT_FMT));$/;"	c
MIN_STORAGE_COMPACT_SLEEP	storage.c	201;"	d	file:
MKDIR_P	doc/Makefile	/^MKDIR_P = \/bin\/mkdir -p$/;"	m
MOVE_BUSY	slabs.c	/^    MOVE_PASS=0, MOVE_FROM_SLAB, MOVE_FROM_LRU, MOVE_BUSY, MOVE_LOCKED$/;"	e	enum:move_status	file:
MOVE_FROM_LRU	slabs.c	/^    MOVE_PASS=0, MOVE_FROM_SLAB, MOVE_FROM_LRU, MOVE_BUSY, MOVE_LOCKED$/;"	e	enum:move_status	file:
MOVE_FROM_SLAB	slabs.c	/^    MOVE_PASS=0, MOVE_FROM_SLAB, MOVE_FROM_LRU, MOVE_BUSY, MOVE_LOCKED$/;"	e	enum:move_status	file:
MOVE_LOCKED	slabs.c	/^    MOVE_PASS=0, MOVE_FROM_SLAB, MOVE_FROM_LRU, MOVE_BUSY, MOVE_LOCKED$/;"	e	enum:move_status	file:
MOVE_PASS	slabs.c	/^    MOVE_PASS=0, MOVE_FROM_SLAB, MOVE_FROM_LRU, MOVE_BUSY, MOVE_LOCKED$/;"	e	enum:move_status	file:
MSG_LIST_HIGHWAT	memcached.h	65;"	d
MSG_LIST_INITIAL	memcached.h	59;"	d
MURMUR3_HASH	hash.h	/^    JENKINS_HASH=0, MURMUR3_HASH$/;"	e	enum:hashfunc_type
MURMURHASH3_H	murmur3_hash.h	6;"	d
Memcached::Handle	t/lib/MemcachedTest.pm	/^package Memcached::Handle;$/;"	p
Memcached::Handle::DESTROY	t/lib/MemcachedTest.pm	/^sub DESTROY {$/;"	s
Memcached::Handle::host	t/lib/MemcachedTest.pm	/^sub host { $_[0]{host} }$/;"	s
Memcached::Handle::new	t/lib/MemcachedTest.pm	/^sub new {$/;"	s
Memcached::Handle::new_sock	t/lib/MemcachedTest.pm	/^sub new_sock {$/;"	s
Memcached::Handle::new_udp_sock	t/lib/MemcachedTest.pm	/^sub new_udp_sock {$/;"	s
Memcached::Handle::port	t/lib/MemcachedTest.pm	/^sub port { $_[0]{port} }$/;"	s
Memcached::Handle::sock	t/lib/MemcachedTest.pm	/^sub sock {$/;"	s
Memcached::Handle::stop	t/lib/MemcachedTest.pm	/^sub stop {$/;"	s
Memcached::Handle::udpport	t/lib/MemcachedTest.pm	/^sub udpport { $_[0]{udpport} }$/;"	s
MemcachedTest	t/lib/MemcachedTest.pm	/^package MemcachedTest;$/;"	p
MemcachedTest::free_port	t/lib/MemcachedTest.pm	/^sub free_port {$/;"	s
MemcachedTest::mem_get_is	t/lib/MemcachedTest.pm	/^sub mem_get_is {$/;"	s
MemcachedTest::mem_gets	t/lib/MemcachedTest.pm	/^sub mem_gets {$/;"	s
MemcachedTest::mem_gets_is	t/lib/MemcachedTest.pm	/^sub mem_gets_is {$/;"	s
MemcachedTest::mem_stats	t/lib/MemcachedTest.pm	/^sub mem_stats {$/;"	s
MemcachedTest::new_memcached	t/lib/MemcachedTest.pm	/^sub new_memcached {$/;"	s
MemcachedTest::sleep	t/lib/MemcachedTest.pm	/^sub sleep {$/;"	s
MemcachedTest::supports_drop_priv	t/lib/MemcachedTest.pm	/^sub supports_drop_priv {$/;"	s
MemcachedTest::supports_extstore	t/lib/MemcachedTest.pm	/^sub supports_extstore {$/;"	s
MemcachedTest::supports_sasl	t/lib/MemcachedTest.pm	/^sub supports_sasl {$/;"	s
MemcachedTest::supports_udp	t/lib/MemcachedTest.pm	/^sub supports_udp {$/;"	s
MurmurHash3_x86_32	murmur3_hash.c	/^uint32_t MurmurHash3_x86_32 ( const void * key, size_t length)$/;"	f	signature:( const void * key, size_t length)
MurmurHash3_x86_32	murmur3_hash.h	/^uint32_t MurmurHash3_x86_32(const void *key, size_t length);$/;"	p	signature:(const void *key, size_t length)
NDEBUG	testapp.c	2;"	d	file:
NON_NUMERIC	memcached.h	/^    OK, NON_NUMERIC, EOM, DELTA_ITEM_NOT_FOUND, DELTA_ITEM_CAS_MISMATCH$/;"	e	enum:delta_result_type
NORMAL_INSTALL	doc/Makefile	/^NORMAL_INSTALL = :$/;"	m
NORMAL_UNINSTALL	doc/Makefile	/^NORMAL_UNINSTALL = :$/;"	m
NOT_FOUND	memcached.h	/^    NOT_STORED=0, STORED, EXISTS, NOT_FOUND, TOO_LARGE, NO_MEMORY$/;"	e	enum:store_item_type
NOT_STORED	memcached.h	/^    NOT_STORED=0, STORED, EXISTS, NOT_FOUND, TOO_LARGE, NO_MEMORY$/;"	e	enum:store_item_type
NO_MEMORY	memcached.h	/^    NOT_STORED=0, STORED, EXISTS, NOT_FOUND, TOO_LARGE, NO_MEMORY$/;"	e	enum:store_item_type
NREAD_ADD	memcached.h	217;"	d
NREAD_APPEND	memcached.h	220;"	d
NREAD_CAS	memcached.h	222;"	d
NREAD_PREPEND	memcached.h	221;"	d
NREAD_REPLACE	memcached.h	219;"	d
NREAD_SET	memcached.h	218;"	d
NROFF	doc/Makefile	/^NROFF = nroff$/;"	m
OBJEXT	doc/Makefile	/^OBJEXT = o$/;"	m
OBJ_IO_READ	extstore.h	/^    OBJ_IO_READ = 0,$/;"	e	enum:obj_io_mode
OBJ_IO_WRITE	extstore.h	/^    OBJ_IO_WRITE,$/;"	e	enum:obj_io_mode
OK	memcached.h	/^    OK, NON_NUMERIC, EOM, DELTA_ITEM_NOT_FOUND, DELTA_ITEM_CAS_MISMATCH$/;"	e	enum:delta_result_type
PACKAGE	doc/Makefile	/^PACKAGE = memcached$/;"	m
PACKAGE_BUGREPORT	doc/Makefile	/^PACKAGE_BUGREPORT = memcached@googlegroups.com$/;"	m
PACKAGE_NAME	doc/Makefile	/^PACKAGE_NAME = memcached$/;"	m
PACKAGE_STRING	doc/Makefile	/^PACKAGE_STRING = memcached 1.5.8$/;"	m
PACKAGE_TARNAME	doc/Makefile	/^PACKAGE_TARNAME = memcached$/;"	m
PACKAGE_URL	doc/Makefile	/^PACKAGE_URL = $/;"	m
PACKAGE_VERSION	doc/Makefile	/^PACKAGE_VERSION = 1.5.8$/;"	m
PAGE_BUCKET_CHUNKED	storage.c	12;"	d	file:
PAGE_BUCKET_COMPACT	storage.c	11;"	d	file:
PAGE_BUCKET_DEFAULT	storage.c	10;"	d	file:
PAGE_BUCKET_LOWTTL	storage.c	13;"	d	file:
PATH_SEPARATOR	doc/Makefile	/^PATH_SEPARATOR = :$/;"	m
PAUSE_ALL_THREADS	memcached.h	/^    PAUSE_ALL_THREADS,$/;"	e	enum:pause_thread_types
PAUSE_WORKER_THREADS	memcached.h	/^    PAUSE_WORKER_THREADS = 0,$/;"	e	enum:pause_thread_types
POLY	crc32c.c	50;"	d	file:
POST_INSTALL	doc/Makefile	/^POST_INSTALL = :$/;"	m
POST_UNINSTALL	doc/Makefile	/^POST_UNINSTALL = :$/;"	m
POWER_LARGEST	memcached.h	89;"	d
POWER_SMALLEST	memcached.h	88;"	d
PREFIX_HASH_SIZE	stats.c	32;"	d	file:
PREFIX_STATS	stats.c	/^typedef struct _prefix_stats PREFIX_STATS;$/;"	t	typeref:struct:_prefix_stats	file:
PRE_INSTALL	doc/Makefile	/^PRE_INSTALL = :$/;"	m
PRE_UNINSTALL	doc/Makefile	/^PRE_UNINSTALL = :$/;"	m
PROFILER	doc/Makefile	/^PROFILER = \/usr\/bin\/gcov$/;"	m
PROFILER_FLAGS	doc/Makefile	/^PROFILER_FLAGS = -fprofile-arcs -ftest-coverage$/;"	m
PROFILER_LDFLAGS	doc/Makefile	/^PROFILER_LDFLAGS = -lgcov$/;"	m
PROTOCOL_BINARY_CMD_ADD	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_ADD = 0x02,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_ADDQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_ADDQ = 0x12,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_APPEND	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_APPEND = 0x0e,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_APPENDQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_APPENDQ = 0x19,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_DECREMENT	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_DECREMENT = 0x06,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_DECREMENTQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_DECREMENTQ = 0x16,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_DELETE	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_DELETE = 0x04,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_DELETEQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_DELETEQ = 0x14,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_FLUSH	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_FLUSH = 0x08,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_FLUSHQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_FLUSHQ = 0x18,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_GAT	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_GAT = 0x1d,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_GATK	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_GATK = 0x23,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_GATKQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_GATKQ = 0x24,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_GATQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_GATQ = 0x1e,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_GET	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_GET = 0x00,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_GETK	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_GETK = 0x0c,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_GETKQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_GETKQ = 0x0d,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_GETQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_GETQ = 0x09,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_INCREMENT	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_INCREMENT = 0x05,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_INCREMENTQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_INCREMENTQ = 0x15,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_NOOP	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_NOOP = 0x0a,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_PREPEND	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_PREPEND = 0x0f,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_PREPENDQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_PREPENDQ = 0x1a,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_QUIT	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_QUIT = 0x07,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_QUITQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_QUITQ = 0x17,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RAPPEND	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RAPPEND   = 0x33,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RAPPENDQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RAPPENDQ  = 0x34,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RDECR	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RDECR     = 0x3b,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RDECRQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RDECRQ    = 0x3c$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RDELETE	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RDELETE   = 0x37,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RDELETEQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RDELETEQ  = 0x38,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_REPLACE	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_REPLACE = 0x03,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_REPLACEQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_REPLACEQ = 0x13,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RGET	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RGET      = 0x30,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RINCR	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RINCR     = 0x39,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RINCRQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RINCRQ    = 0x3a,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RPREPEND	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RPREPEND  = 0x35,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RPREPENDQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RPREPENDQ = 0x36,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RSET	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RSET      = 0x31,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_RSETQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_RSETQ     = 0x32,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_SASL_AUTH	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_SASL_AUTH = 0x21,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_SASL_LIST_MECHS	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_SASL_LIST_MECHS = 0x20,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_SASL_STEP	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_SASL_STEP = 0x22,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_SET	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_SET = 0x01,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_SETQ	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_SETQ = 0x11,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_STAT	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_STAT = 0x10,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_TOUCH	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_TOUCH = 0x1c,$/;"	e	enum:__anon7
PROTOCOL_BINARY_CMD_VERSION	protocol_binary.h	/^        PROTOCOL_BINARY_CMD_VERSION = 0x0b,$/;"	e	enum:__anon7
PROTOCOL_BINARY_H	protocol_binary.h	36;"	d
PROTOCOL_BINARY_RAW_BYTES	protocol_binary.h	/^        PROTOCOL_BINARY_RAW_BYTES = 0x00$/;"	e	enum:__anon8
PROTOCOL_BINARY_REQ	protocol_binary.h	/^        PROTOCOL_BINARY_REQ = 0x80,$/;"	e	enum:__anon5
PROTOCOL_BINARY_RES	protocol_binary.h	/^        PROTOCOL_BINARY_RES = 0x81$/;"	e	enum:__anon5
PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE	protocol_binary.h	/^        PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE = 0x21,$/;"	e	enum:__anon6
PROTOCOL_BINARY_RESPONSE_AUTH_ERROR	protocol_binary.h	/^        PROTOCOL_BINARY_RESPONSE_AUTH_ERROR = 0x20,$/;"	e	enum:__anon6
PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL	protocol_binary.h	/^        PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL = 0x06,$/;"	e	enum:__anon6
PROTOCOL_BINARY_RESPONSE_E2BIG	protocol_binary.h	/^        PROTOCOL_BINARY_RESPONSE_E2BIG = 0x03,$/;"	e	enum:__anon6
PROTOCOL_BINARY_RESPONSE_EINVAL	protocol_binary.h	/^        PROTOCOL_BINARY_RESPONSE_EINVAL = 0x04,$/;"	e	enum:__anon6
PROTOCOL_BINARY_RESPONSE_ENOMEM	protocol_binary.h	/^        PROTOCOL_BINARY_RESPONSE_ENOMEM = 0x82$/;"	e	enum:__anon6
PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS	protocol_binary.h	/^        PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS = 0x02,$/;"	e	enum:__anon6
PROTOCOL_BINARY_RESPONSE_KEY_ENOENT	protocol_binary.h	/^        PROTOCOL_BINARY_RESPONSE_KEY_ENOENT = 0x01,$/;"	e	enum:__anon6
PROTOCOL_BINARY_RESPONSE_NOT_STORED	protocol_binary.h	/^        PROTOCOL_BINARY_RESPONSE_NOT_STORED = 0x05,$/;"	e	enum:__anon6
PROTOCOL_BINARY_RESPONSE_SUCCESS	protocol_binary.h	/^        PROTOCOL_BINARY_RESPONSE_SUCCESS = 0x00,$/;"	e	enum:__anon6
PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND	protocol_binary.h	/^        PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND = 0x81,$/;"	e	enum:__anon6
READ_BUFFER_HIGHWAT	memcached.h	62;"	d
READ_DATA_RECEIVED	memcached.c	/^    READ_DATA_RECEIVED,$/;"	e	enum:try_read_result	file:
READ_ERROR	memcached.c	/^    READ_ERROR,            \/** an error occurred (on the socket) (or client closed connection) *\/$/;"	e	enum:try_read_result	file:
READ_MEMORY_ERROR	memcached.c	/^    READ_MEMORY_ERROR      \/** failed to allocate more memory *\/$/;"	e	enum:try_read_result	file:
READ_NO_DATA_RECEIVED	memcached.c	/^    READ_NO_DATA_RECEIVED,$/;"	e	enum:try_read_result	file:
REALTIME_MAXDELTA	memcached.c	172;"	d	file:
REASSIGN_BADCLASS	slabs.h	/^    REASSIGN_OK=0, REASSIGN_RUNNING, REASSIGN_BADCLASS, REASSIGN_NOSPARE,$/;"	e	enum:reassign_result_type
REASSIGN_NOSPARE	slabs.h	/^    REASSIGN_OK=0, REASSIGN_RUNNING, REASSIGN_BADCLASS, REASSIGN_NOSPARE,$/;"	e	enum:reassign_result_type
REASSIGN_OK	slabs.h	/^    REASSIGN_OK=0, REASSIGN_RUNNING, REASSIGN_BADCLASS, REASSIGN_NOSPARE,$/;"	e	enum:reassign_result_type
REASSIGN_RUNNING	slabs.h	/^    REASSIGN_OK=0, REASSIGN_RUNNING, REASSIGN_BADCLASS, REASSIGN_NOSPARE,$/;"	e	enum:reassign_result_type
REASSIGN_SRC_DST_SAME	slabs.h	/^    REASSIGN_SRC_DST_SAME$/;"	e	enum:reassign_result_type
REQ_MAGIC	t/binary-extstore.t	/^use constant REQ_MAGIC        => 0x80;$/;"	c
REQ_MAGIC	t/binary-sasl.t	/^use constant REQ_MAGIC        => 0x80;$/;"	c
REQ_MAGIC	t/binary.t	/^use constant REQ_MAGIC        => 0x80;$/;"	c
REQ_PKT_FMT	t/binary-extstore.t	/^use constant REQ_PKT_FMT      => "CCnCCnNNNN";$/;"	c
REQ_PKT_FMT	t/binary-sasl.t	/^use constant REQ_PKT_FMT      => "CCnCCnNNNN";$/;"	c
REQ_PKT_FMT	t/binary.t	/^use constant REQ_PKT_FMT      => "CCnCCnNNNN";$/;"	c
REQ_PKT_FMT	t/udp.t	/^use constant REQ_PKT_FMT      => "CCnCCnNNNN";$/;"	c
RESUME_ALL_THREADS	memcached.h	/^    RESUME_ALL_THREADS,$/;"	e	enum:pause_thread_types
RESUME_WORKER_THREADS	memcached.h	/^    RESUME_WORKER_THREADS$/;"	e	enum:pause_thread_types
RES_MAGIC	t/binary-extstore.t	/^use constant RES_MAGIC        => 0x81;$/;"	c
RES_MAGIC	t/binary-sasl.t	/^use constant RES_MAGIC        => 0x81;$/;"	c
RES_MAGIC	t/binary.t	/^use constant RES_MAGIC        => 0x81;$/;"	c
RES_PKT_FMT	t/binary-extstore.t	/^use constant RES_PKT_FMT      => "CCnCCnNNNN";$/;"	c
RES_PKT_FMT	t/binary-sasl.t	/^use constant RES_PKT_FMT      => "CCnCCnNNNN";$/;"	c
RES_PKT_FMT	t/binary.t	/^use constant RES_PKT_FMT      => "CCnCCnNNNN";$/;"	c
RES_PKT_FMT	t/udp.t	/^use constant RES_PKT_FMT      => "CCnCCnNNNN";$/;"	c
ROTL32	murmur3_hash.c	23;"	d	file:
ROTL32	murmur3_hash.c	38;"	d	file:
SASL_CONTINUE	sasl_defs.h	27;"	d
SASL_DEFS_H	sasl_defs.h	2;"	d
SASL_OK	sasl_defs.h	26;"	d
SET_MAKE	doc/Makefile	/^SET_MAKE = $/;"	m
SHELL	doc/Makefile	/^SHELL = \/bin\/bash$/;"	m
SHORT	crc32c.c	269;"	d	file:
SHORTx1	crc32c.c	270;"	d	file:
SHORTx2	crc32c.c	271;"	d	file:
SKIP	t/stats-conns.t	/^SKIP: {$/;"	l
SLABS_ALLOC_NO_NEWPAGE	slabs.h	24;"	d
SLABS_H	slabs.h	3;"	d
SLAB_AUTOMOVE_EXTSTORE_H	slab_automove_extstore.h	2;"	d
SLAB_AUTOMOVE_H	slab_automove.h	2;"	d
SLAB_GLOBAL_PAGE_POOL	memcached.h	90;"	d
SLAB_MOVE_MAX_LOOPS	slabs.c	780;"	d	file:
SLAB_STATS_FIELDS	memcached.h	240;"	d
SOURCES	doc/Makefile	/^SOURCES =$/;"	m
SSE42	crc32c.c	379;"	d	file:
STATS_LOCK	memcached.h	/^void STATS_LOCK(void);$/;"	p	signature:(void)
STATS_LOCK	thread.c	/^void STATS_LOCK() {$/;"	f
STATS_UNLOCK	memcached.h	/^void STATS_UNLOCK(void);$/;"	p	signature:(void)
STATS_UNLOCK	thread.c	/^void STATS_UNLOCK() {$/;"	f
STAT_DECR	extstore.c	38;"	d	file:
STAT_INCR	extstore.c	32;"	d	file:
STAT_KEY_LEN	memcached.h	126;"	d
STAT_L	extstore.c	30;"	d	file:
STAT_UL	extstore.c	31;"	d	file:
STAT_VAL_LEN	memcached.h	127;"	d
STORAGE_H	storage.h	2;"	d
STORAGE_delete	items.h	86;"	d
STORAGE_delete	items.h	95;"	d
STORED	memcached.h	/^    NOT_STORED=0, STORED, EXISTS, NOT_FOUND, TOO_LARGE, NO_MEMORY$/;"	e	enum:store_item_type
STORE_OFFSET	storage.h	10;"	d
STRIP	doc/Makefile	/^STRIP = $/;"	m
SUBCOMMAND_TOKEN	memcached.c	2932;"	d	file:
SUFFIX_LIST_INITIAL	memcached.h	53;"	d
SUFFIX_SIZE	memcached.h	47;"	d
TAIL_REPAIR_TIME_DEFAULT	memcached.h	97;"	d
TEMP_LRU	items.h	4;"	d
TEST_FAIL	testapp.c	/^enum test_return { TEST_SKIP, TEST_PASS, TEST_FAIL };$/;"	e	enum:test_return	file:
TEST_FUNC	testapp.c	/^typedef enum test_return (*TEST_FUNC)(void);$/;"	t	typeref:enum:TEST_FUNC	file:
TEST_PASS	testapp.c	/^enum test_return { TEST_SKIP, TEST_PASS, TEST_FAIL };$/;"	e	enum:test_return	file:
TEST_SKIP	testapp.c	/^enum test_return { TEST_SKIP, TEST_PASS, TEST_FAIL };$/;"	e	enum:test_return	file:
THREAD_STATS_FIELDS	memcached.h	257;"	d
TIMEOUT_MSG_SIZE	memcached.c	337;"	d	file:
TMP_TEMPLATE	testapp.c	26;"	d	file:
TOO_LARGE	memcached.h	/^    NOT_STORED=0, STORED, EXISTS, NOT_FOUND, TOO_LARGE, NO_MEMORY$/;"	e	enum:store_item_type
TRACE_H	trace.h	2;"	d
TRANSMIT_COMPLETE	memcached.c	/^    TRANSMIT_COMPLETE,   \/** All done writing. *\/$/;"	e	enum:transmit_result	file:
TRANSMIT_HARD_ERROR	memcached.c	/^    TRANSMIT_HARD_ERROR  \/** Can't write (c->state is set to conn_closing) *\/$/;"	e	enum:transmit_result	file:
TRANSMIT_INCOMPLETE	memcached.c	/^    TRANSMIT_INCOMPLETE, \/** More data remaining to write. *\/$/;"	e	enum:transmit_result	file:
TRANSMIT_SOFT_ERROR	memcached.c	/^    TRANSMIT_SOFT_ERROR, \/** Can't write any more right now. *\/$/;"	e	enum:transmit_result	file:
UDP_HEADER_SIZE	memcached.h	44;"	d
UDP_MAX_PAYLOAD_SIZE	memcached.h	43;"	d
UDP_READ_BUFFER_SIZE	memcached.h	42;"	d
VERSION	doc/Makefile	/^VERSION = 1.5.8$/;"	m
WARM_LRU	items.h	2;"	d
WATCHER_ALL	logger.c	81;"	d	file:
WATCHER_LIMIT	logger.c	41;"	d	file:
X	memcached.h	252;"	d
X	memcached.h	254;"	d
X	memcached.h	290;"	d
X	memcached.h	295;"	d
X	thread.c	696;"	d	file:
X	thread.c	701;"	d	file:
X	thread.c	721;"	d	file:
X	thread.c	726;"	d	file:
X	thread.c	729;"	d	file:
X	thread.c	732;"	d	file:
X	thread.c	752;"	d	file:
X	thread.c	754;"	d	file:
XML2RFC	doc/Makefile	/^XML2RFC = \/usr\/bin\/xml2rfc$/;"	m
XSLTPROC	doc/Makefile	/^XSLTPROC = no$/;"	m
_P1003_1B_VISIBLE	memcached.c	33;"	d	file:
__anon11::__anon12::bodylen	protocol_binary.h	/^            uint32_t bodylen;$/;"	m	struct:__anon11::__anon12	access:public
__anon11::__anon12::cas	protocol_binary.h	/^            uint64_t cas;$/;"	m	struct:__anon11::__anon12	access:public
__anon11::__anon12::datatype	protocol_binary.h	/^            uint8_t datatype;$/;"	m	struct:__anon11::__anon12	access:public
__anon11::__anon12::extlen	protocol_binary.h	/^            uint8_t extlen;$/;"	m	struct:__anon11::__anon12	access:public
__anon11::__anon12::keylen	protocol_binary.h	/^            uint16_t keylen;$/;"	m	struct:__anon11::__anon12	access:public
__anon11::__anon12::magic	protocol_binary.h	/^            uint8_t magic;$/;"	m	struct:__anon11::__anon12	access:public
__anon11::__anon12::opaque	protocol_binary.h	/^            uint32_t opaque;$/;"	m	struct:__anon11::__anon12	access:public
__anon11::__anon12::opcode	protocol_binary.h	/^            uint8_t opcode;$/;"	m	struct:__anon11::__anon12	access:public
__anon11::__anon12::status	protocol_binary.h	/^            uint16_t status;$/;"	m	struct:__anon11::__anon12	access:public
__anon11::bytes	protocol_binary.h	/^        uint8_t bytes[24];$/;"	m	union:__anon11	access:public
__anon11::response	protocol_binary.h	/^        } response;$/;"	m	union:__anon11	typeref:struct:__anon11::__anon12	access:public
__anon13::__anon14::header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon13::__anon14	access:public
__anon13::bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header)];$/;"	m	union:__anon13	access:public
__anon13::message	protocol_binary.h	/^        } message;$/;"	m	union:__anon13	typeref:struct:__anon13::__anon14	access:public
__anon15::__anon16::header	protocol_binary.h	/^            protocol_binary_response_header header;$/;"	m	struct:__anon15::__anon16	access:public
__anon15::bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_response_header)];$/;"	m	union:__anon15	access:public
__anon15::message	protocol_binary.h	/^        } message;$/;"	m	union:__anon15	typeref:struct:__anon15::__anon16	access:public
__anon17::__anon18::__anon19::flags	protocol_binary.h	/^                uint32_t flags;$/;"	m	struct:__anon17::__anon18::__anon19	access:public
__anon17::__anon18::body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon17::__anon18	typeref:struct:__anon17::__anon18::__anon19	access:public
__anon17::__anon18::header	protocol_binary.h	/^            protocol_binary_response_header header;$/;"	m	struct:__anon17::__anon18	access:public
__anon17::bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_response_header) + 4];$/;"	m	union:__anon17	access:public
__anon17::message	protocol_binary.h	/^        } message;$/;"	m	union:__anon17	typeref:struct:__anon17::__anon18	access:public
__anon1::list_size	slabs.c	/^    unsigned int list_size; \/* size of prev array *\/$/;"	m	struct:__anon1	file:	access:public
__anon1::perslab	slabs.c	/^    unsigned int perslab;   \/* how many items per slab *\/$/;"	m	struct:__anon1	file:	access:public
__anon1::requested	slabs.c	/^    size_t requested; \/* The number of requested bytes *\/$/;"	m	struct:__anon1	file:	access:public
__anon1::size	slabs.c	/^    unsigned int size;      \/* sizes of items *\/$/;"	m	struct:__anon1	file:	access:public
__anon1::sl_curr	slabs.c	/^    unsigned int sl_curr;   \/* total free items in list *\/$/;"	m	struct:__anon1	file:	access:public
__anon1::slab_list	slabs.c	/^    void **slab_list;       \/* array of slab pointers *\/$/;"	m	struct:__anon1	file:	access:public
__anon1::slabs	slabs.c	/^    unsigned int slabs;     \/* how many slabs were allocated for this class *\/$/;"	m	struct:__anon1	file:	access:public
__anon1::slots	slabs.c	/^    void *slots;           \/* list of item ptrs *\/$/;"	m	struct:__anon1	file:	access:public
__anon20::__anon21::__anon22::expiration	protocol_binary.h	/^                uint32_t expiration;$/;"	m	struct:__anon20::__anon21::__anon22	access:public
__anon20::__anon21::body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon20::__anon21	typeref:struct:__anon20::__anon21::__anon22	access:public
__anon20::__anon21::header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon20::__anon21	access:public
__anon20::bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];$/;"	m	union:__anon20	access:public
__anon20::message	protocol_binary.h	/^        } message;$/;"	m	union:__anon20	typeref:struct:__anon20::__anon21	access:public
__anon23::__anon24::__anon25::expiration	protocol_binary.h	/^                uint32_t expiration;$/;"	m	struct:__anon23::__anon24::__anon25	access:public
__anon23::__anon24::__anon25::flags	protocol_binary.h	/^                uint32_t flags;$/;"	m	struct:__anon23::__anon24::__anon25	access:public
__anon23::__anon24::body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon23::__anon24	typeref:struct:__anon23::__anon24::__anon25	access:public
__anon23::__anon24::header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon23::__anon24	access:public
__anon23::bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 8];$/;"	m	union:__anon23	access:public
__anon23::message	protocol_binary.h	/^        } message;$/;"	m	union:__anon23	typeref:struct:__anon23::__anon24	access:public
__anon26::__anon27::__anon28::delta	protocol_binary.h	/^                uint64_t delta;$/;"	m	struct:__anon26::__anon27::__anon28	access:public
__anon26::__anon27::__anon28::expiration	protocol_binary.h	/^                uint32_t expiration;$/;"	m	struct:__anon26::__anon27::__anon28	access:public
__anon26::__anon27::__anon28::initial	protocol_binary.h	/^                uint64_t initial;$/;"	m	struct:__anon26::__anon27::__anon28	access:public
__anon26::__anon27::body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon26::__anon27	typeref:struct:__anon26::__anon27::__anon28	access:public
__anon26::__anon27::header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon26::__anon27	access:public
__anon26::bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 20];$/;"	m	union:__anon26	access:public
__anon26::message	protocol_binary.h	/^        } message;$/;"	m	union:__anon26	typeref:struct:__anon26::__anon27	access:public
__anon29::__anon30::__anon31::value	protocol_binary.h	/^                uint64_t value;$/;"	m	struct:__anon29::__anon30::__anon31	access:public
__anon29::__anon30::body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon29::__anon30	typeref:struct:__anon29::__anon30::__anon31	access:public
__anon29::__anon30::header	protocol_binary.h	/^            protocol_binary_response_header header;$/;"	m	struct:__anon29::__anon30	access:public
__anon29::bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_response_header) + 8];$/;"	m	union:__anon29	access:public
__anon29::message	protocol_binary.h	/^        } message;$/;"	m	union:__anon29	typeref:struct:__anon29::__anon30	access:public
__anon2::free	slab_automove.h	/^    slab_automove_free_func free;$/;"	m	struct:__anon2	access:public
__anon2::init	slab_automove.h	/^    slab_automove_init_func init;$/;"	m	struct:__anon2	access:public
__anon2::run	slab_automove.h	/^    slab_automove_run_func run;$/;"	m	struct:__anon2	access:public
__anon32::__anon33::__anon34::expiration	protocol_binary.h	/^                uint32_t expiration;$/;"	m	struct:__anon32::__anon33::__anon34	access:public
__anon32::__anon33::body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon32::__anon33	typeref:struct:__anon32::__anon33::__anon34	access:public
__anon32::__anon33::header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon32::__anon33	access:public
__anon32::bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];$/;"	m	union:__anon32	access:public
__anon32::message	protocol_binary.h	/^        } message;$/;"	m	union:__anon32	typeref:struct:__anon32::__anon33	access:public
__anon35::__anon36::__anon37::expiration	protocol_binary.h	/^                uint32_t expiration;$/;"	m	struct:__anon35::__anon36::__anon37	access:public
__anon35::__anon36::body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon35::__anon36	typeref:struct:__anon35::__anon36::__anon37	access:public
__anon35::__anon36::header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon35::__anon36	access:public
__anon35::bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];$/;"	m	union:__anon35	access:public
__anon35::message	protocol_binary.h	/^        } message;$/;"	m	union:__anon35	typeref:struct:__anon35::__anon36	access:public
__anon38::__anon39::__anon40::flags	protocol_binary.h	/^                uint8_t  flags;$/;"	m	struct:__anon38::__anon39::__anon40	access:public
__anon38::__anon39::__anon40::max_results	protocol_binary.h	/^                uint32_t max_results;$/;"	m	struct:__anon38::__anon39::__anon40	access:public
__anon38::__anon39::__anon40::reserved	protocol_binary.h	/^                uint8_t  reserved;$/;"	m	struct:__anon38::__anon39::__anon40	access:public
__anon38::__anon39::__anon40::size	protocol_binary.h	/^                uint16_t size;$/;"	m	struct:__anon38::__anon39::__anon40	access:public
__anon38::__anon39::body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon38::__anon39	typeref:struct:__anon38::__anon39::__anon40	access:public
__anon38::__anon39::header	protocol_binary.h	/^            protocol_binary_response_header header;$/;"	m	struct:__anon38::__anon39	access:public
__anon38::bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];$/;"	m	union:__anon38	access:public
__anon38::message	protocol_binary.h	/^        } message;$/;"	m	union:__anon38	typeref:struct:__anon38::__anon39	access:public
__anon3::age	items.h	/^    uint32_t age;$/;"	m	struct:__anon3	access:public
__anon3::evicted	items.h	/^    int64_t evicted;$/;"	m	struct:__anon3	access:public
__anon3::outofmemory	items.h	/^    int64_t outofmemory;$/;"	m	struct:__anon3	access:public
__anon41::bufsize	cache.h	/^    size_t bufsize;$/;"	m	struct:__anon41	access:public
__anon41::constructor	cache.h	/^    cache_constructor_t* constructor;$/;"	m	struct:__anon41	access:public
__anon41::destructor	cache.h	/^    cache_destructor_t* destructor;$/;"	m	struct:__anon41	access:public
__anon41::freecurr	cache.h	/^    int freecurr;$/;"	m	struct:__anon41	access:public
__anon41::freetotal	cache.h	/^    int freetotal;$/;"	m	struct:__anon41	access:public
__anon41::mutex	cache.h	/^    pthread_mutex_t mutex;$/;"	m	struct:__anon41	access:public
__anon41::name	cache.h	/^    char *name;$/;"	m	struct:__anon41	access:public
__anon41::ptr	cache.h	/^    void **ptr;$/;"	m	struct:__anon41	access:public
__anon42::chunk_size	slabs.h	/^    unsigned int chunk_size;$/;"	m	struct:__anon42	access:public
__anon42::chunks_per_page	slabs.h	/^    unsigned int chunks_per_page;$/;"	m	struct:__anon42	access:public
__anon42::free_chunks	slabs.h	/^    long int free_chunks;$/;"	m	struct:__anon42	access:public
__anon42::total_pages	slabs.h	/^    long int total_pages;$/;"	m	struct:__anon42	access:public
__anon43::cond	extstore.c	/^    pthread_cond_t cond;$/;"	m	struct:__anon43	file:	access:public
__anon43::e	extstore.c	/^    store_engine *e;$/;"	m	struct:__anon43	file:	access:public
__anon43::mutex	extstore.c	/^    pthread_mutex_t mutex;$/;"	m	struct:__anon43	file:	access:public
__anon43::queue	extstore.c	/^    obj_io *queue;$/;"	m	struct:__anon43	file:	access:public
__anon44::cond	extstore.c	/^    pthread_cond_t cond;$/;"	m	struct:__anon44	file:	access:public
__anon44::e	extstore.c	/^    store_engine *e;$/;"	m	struct:__anon44	file:	access:public
__anon44::mutex	extstore.c	/^    pthread_mutex_t mutex;$/;"	m	struct:__anon44	file:	access:public
__anon45::crawler_items_checked	items.c	/^    uint64_t crawler_items_checked;$/;"	m	struct:__anon45	file:	access:public
__anon45::crawler_reclaimed	items.c	/^    uint64_t crawler_reclaimed;$/;"	m	struct:__anon45	file:	access:public
__anon45::direct_reclaims	items.c	/^    uint64_t direct_reclaims;$/;"	m	struct:__anon45	file:	access:public
__anon45::evicted	items.c	/^    uint64_t evicted;$/;"	m	struct:__anon45	file:	access:public
__anon45::evicted_active	items.c	/^    uint64_t evicted_active; \/* items evicted that should have been shuffled *\/$/;"	m	struct:__anon45	file:	access:public
__anon45::evicted_nonzero	items.c	/^    uint64_t evicted_nonzero;$/;"	m	struct:__anon45	file:	access:public
__anon45::evicted_time	items.c	/^    rel_time_t evicted_time;$/;"	m	struct:__anon45	file:	access:public
__anon45::evicted_unfetched	items.c	/^    uint64_t evicted_unfetched; \/* items evicted but never touched *\/$/;"	m	struct:__anon45	file:	access:public
__anon45::expired_unfetched	items.c	/^    uint64_t expired_unfetched; \/* items reclaimed but never touched *\/$/;"	m	struct:__anon45	file:	access:public
__anon45::hits_to_cold	items.c	/^    uint64_t hits_to_cold;$/;"	m	struct:__anon45	file:	access:public
__anon45::hits_to_hot	items.c	/^    uint64_t hits_to_hot;$/;"	m	struct:__anon45	file:	access:public
__anon45::hits_to_temp	items.c	/^    uint64_t hits_to_temp;$/;"	m	struct:__anon45	file:	access:public
__anon45::hits_to_warm	items.c	/^    uint64_t hits_to_warm;$/;"	m	struct:__anon45	file:	access:public
__anon45::lrutail_reflocked	items.c	/^    uint64_t lrutail_reflocked;$/;"	m	struct:__anon45	file:	access:public
__anon45::moves_to_cold	items.c	/^    uint64_t moves_to_cold;$/;"	m	struct:__anon45	file:	access:public
__anon45::moves_to_warm	items.c	/^    uint64_t moves_to_warm;$/;"	m	struct:__anon45	file:	access:public
__anon45::moves_within_lru	items.c	/^    uint64_t moves_within_lru;$/;"	m	struct:__anon45	file:	access:public
__anon45::outofmemory	items.c	/^    uint64_t outofmemory;$/;"	m	struct:__anon45	file:	access:public
__anon45::reclaimed	items.c	/^    uint64_t reclaimed;$/;"	m	struct:__anon45	file:	access:public
__anon45::tailrepairs	items.c	/^    uint64_t tailrepairs;$/;"	m	struct:__anon45	file:	access:public
__anon46::hv	items.c	/^    uint32_t hv;$/;"	m	struct:__anon46	file:	access:public
__anon46::it	items.c	/^    item *it;$/;"	m	struct:__anon46	file:	access:public
__anon47::a_end	bipbuffer.h	/^    unsigned int a_start, a_end;$/;"	m	struct:__anon47	access:public
__anon47::a_start	bipbuffer.h	/^    unsigned int a_start, a_end;$/;"	m	struct:__anon47	access:public
__anon47::b_end	bipbuffer.h	/^    unsigned int b_end;$/;"	m	struct:__anon47	access:public
__anon47::b_inuse	bipbuffer.h	/^    int b_inuse;$/;"	m	struct:__anon47	access:public
__anon47::data	bipbuffer.h	/^    unsigned char data[];$/;"	m	struct:__anon47	access:public
__anon47::size	bipbuffer.h	/^    unsigned long int size;$/;"	m	struct:__anon47	access:public
__anon48::iam_after	slab_automove.c	/^    item_stats_automove iam_after[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon48	file:	access:public
__anon48::iam_before	slab_automove.c	/^    item_stats_automove iam_before[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon48	file:	access:public
__anon48::max_age_ratio	slab_automove.c	/^    double max_age_ratio;$/;"	m	struct:__anon48	file:	access:public
__anon48::sam_after	slab_automove.c	/^    slab_stats_automove sam_after[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon48	file:	access:public
__anon48::sam_before	slab_automove.c	/^    slab_stats_automove sam_before[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon48	file:	access:public
__anon48::window_cur	slab_automove.c	/^    uint32_t window_cur;$/;"	m	struct:__anon48	file:	access:public
__anon48::window_data	slab_automove.c	/^    struct window_data *window_data;$/;"	m	struct:__anon48	typeref:struct:__anon48::window_data	file:	access:public
__anon48::window_size	slab_automove.c	/^    uint32_t window_size;$/;"	m	struct:__anon48	file:	access:public
__anon49::buf	crawler.c	/^    bipbuf_t *buf; \/* output buffer *\/$/;"	m	struct:__anon49	file:	access:public
__anon49::c	crawler.c	/^    void *c; \/* original connection structure. still with source thread attached. *\/$/;"	m	struct:__anon49	file:	access:public
__anon49::cbuf	crawler.c	/^    char *cbuf; \/* current buffer *\/$/;"	m	struct:__anon49	file:	access:public
__anon49::sfd	crawler.c	/^    int sfd; \/* client fd. *\/$/;"	m	struct:__anon49	file:	access:public
__anon4::end_time	crawler.h	/^    rel_time_t end_time;$/;"	m	struct:__anon4	access:public
__anon4::histo	crawler.h	/^    uint64_t histo[61];$/;"	m	struct:__anon4	access:public
__anon4::noexp	crawler.h	/^    uint64_t noexp;$/;"	m	struct:__anon4	access:public
__anon4::reclaimed	crawler.h	/^    uint64_t reclaimed;$/;"	m	struct:__anon4	access:public
__anon4::run_complete	crawler.h	/^    bool run_complete;$/;"	m	struct:__anon4	access:public
__anon4::seen	crawler.h	/^    uint64_t seen;$/;"	m	struct:__anon4	access:public
__anon4::start_time	crawler.h	/^    rel_time_t start_time;$/;"	m	struct:__anon4	access:public
__anon4::ttl_hourplus	crawler.h	/^    uint64_t ttl_hourplus;$/;"	m	struct:__anon4	access:public
__anon50::doneclass	crawler.c	/^    crawler_doneclass_func doneclass; \/* runs once per sub-crawler completion. *\/$/;"	m	struct:__anon50	file:	access:public
__anon50::eval	crawler.c	/^    crawler_eval_func eval; \/* runs on an item. *\/$/;"	m	struct:__anon50	file:	access:public
__anon50::finalize	crawler.c	/^    crawler_finalize_func finalize; \/* runs once when all sub-crawlers are done. *\/$/;"	m	struct:__anon50	file:	access:public
__anon50::init	crawler.c	/^    crawler_init_func init; \/* run before crawl starts *\/$/;"	m	struct:__anon50	file:	access:public
__anon50::needs_client	crawler.c	/^    bool needs_client; \/* whether or not to grab onto the remote client *\/$/;"	m	struct:__anon50	file:	access:public
__anon50::needs_lock	crawler.c	/^    bool needs_lock; \/* whether or not we need the LRU lock held when eval is called *\/$/;"	m	struct:__anon50	file:	access:public
__anon52::checked	memcached.h	/^    uint64_t        checked;    \/* items examined during this crawl. *\/$/;"	m	struct:__anon52	access:public
__anon52::exptime	memcached.h	/^    rel_time_t      exptime;    \/* expire time *\/$/;"	m	struct:__anon52	access:public
__anon52::h_next	memcached.h	/^    struct _stritem *h_next;    \/* hash chain next *\/$/;"	m	struct:__anon52	typeref:struct:__anon52::_stritem	access:public
__anon52::it_flags	memcached.h	/^    uint8_t         it_flags;   \/* ITEM_* above *\/$/;"	m	struct:__anon52	access:public
__anon52::nbytes	memcached.h	/^    int             nbytes;     \/* size of data *\/$/;"	m	struct:__anon52	access:public
__anon52::next	memcached.h	/^    struct _stritem *next;$/;"	m	struct:__anon52	typeref:struct:__anon52::_stritem	access:public
__anon52::nkey	memcached.h	/^    uint8_t         nkey;       \/* key length, w\/terminating null and padding *\/$/;"	m	struct:__anon52	access:public
__anon52::nsuffix	memcached.h	/^    uint8_t         nsuffix;    \/* length of flags-and-length string *\/$/;"	m	struct:__anon52	access:public
__anon52::prev	memcached.h	/^    struct _stritem *prev;$/;"	m	struct:__anon52	typeref:struct:__anon52::_stritem	access:public
__anon52::reclaimed	memcached.h	/^    uint64_t        reclaimed;  \/* items reclaimed during this crawl. *\/$/;"	m	struct:__anon52	access:public
__anon52::refcount	memcached.h	/^    unsigned short  refcount;$/;"	m	struct:__anon52	access:public
__anon52::remaining	memcached.h	/^    uint32_t        remaining;  \/* Max keys to crawl per slab per invocation *\/$/;"	m	struct:__anon52	access:public
__anon52::slabs_clsid	memcached.h	/^    uint8_t         slabs_clsid;\/* which slab class we're in *\/$/;"	m	struct:__anon52	access:public
__anon52::time	memcached.h	/^    rel_time_t      time;       \/* least recent access *\/$/;"	m	struct:__anon52	access:public
__anon52::unfetched	memcached.h	/^    uint64_t        unfetched;  \/* items reclaimed unfetched during this crawl. *\/$/;"	m	struct:__anon52	access:public
__anon53::offset	memcached.h	/^    unsigned int offset; \/* from IO header *\/$/;"	m	struct:__anon53	access:public
__anon53::page_id	memcached.h	/^    unsigned short page_id; \/* from IO header *\/$/;"	m	struct:__anon53	access:public
__anon53::page_version	memcached.h	/^    unsigned int page_version; \/* from IO header *\/$/;"	m	struct:__anon53	access:public
__anon54::base	memcached.h	/^    struct event_base *base;    \/* libevent handle this thread uses 该线程关联的event_base实例 *\/$/;"	m	struct:__anon54	typeref:struct:__anon54::event_base	access:public
__anon54::io_cache	memcached.h	/^    cache_t *io_cache;          \/* IO objects *\/$/;"	m	struct:__anon54	access:public
__anon54::l	memcached.h	/^    logger *l;                  \/* logger buffer *\/$/;"	m	struct:__anon54	access:public
__anon54::lru_bump_buf	memcached.h	/^    void *lru_bump_buf;         \/* async LRU bump buffer *\/$/;"	m	struct:__anon54	access:public
__anon54::new_conn_queue	memcached.h	/^    struct conn_queue *new_conn_queue; \/* queue of new connections to handle 指向该线程关联的连接队列 *\/$/;"	m	struct:__anon54	typeref:struct:__anon54::conn_queue	access:public
__anon54::notify_event	memcached.h	/^    struct event notify_event;  \/* listen event for notify pipe  该线程用于监听管道读事件的event实例 *\/$/;"	m	struct:__anon54	typeref:struct:__anon54::event	access:public
__anon54::notify_receive_fd	memcached.h	/^    int notify_receive_fd;      \/* receiving end of notify pipe  记录了管道的接收端fd *\/$/;"	m	struct:__anon54	access:public
__anon54::notify_send_fd	memcached.h	/^    int notify_send_fd;         \/* sending end of notify pipe  记录了管道的发生端fd *\/$/;"	m	struct:__anon54	access:public
__anon54::stats	memcached.h	/^    struct thread_stats stats;  \/* Stats generated by this thread  记录了该线程的统计信息 *\/$/;"	m	struct:__anon54	typeref:struct:__anon54::thread_stats	access:public
__anon54::storage	memcached.h	/^    void *storage;              \/* data object for storage system *\/$/;"	m	struct:__anon54	access:public
__anon54::suffix_cache	memcached.h	/^    cache_t *suffix_cache;      \/* suffix cache *\/$/;"	m	struct:__anon54	access:public
__anon54::thread_id	memcached.h	/^    pthread_t thread_id;        \/* unique ID of this thread  该线程ID *\/$/;"	m	struct:__anon54	access:public
__anon56::free_mem	slab_automove_extstore.c	/^    unsigned int free_mem[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon56	file:	access:public
__anon56::free_ratio	slab_automove_extstore.c	/^    double free_ratio;$/;"	m	struct:__anon56	file:	access:public
__anon56::iam_after	slab_automove_extstore.c	/^    item_stats_automove iam_after[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon56	file:	access:public
__anon56::iam_before	slab_automove_extstore.c	/^    item_stats_automove iam_before[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon56	file:	access:public
__anon56::item_size	slab_automove_extstore.c	/^    uint32_t item_size;$/;"	m	struct:__anon56	file:	access:public
__anon56::last_memcheck_run	slab_automove_extstore.c	/^    rel_time_t last_memcheck_run;$/;"	m	struct:__anon56	file:	access:public
__anon56::max_age_ratio	slab_automove_extstore.c	/^    double max_age_ratio;$/;"	m	struct:__anon56	file:	access:public
__anon56::pool_filled_once	slab_automove_extstore.c	/^    bool pool_filled_once;$/;"	m	struct:__anon56	file:	access:public
__anon56::sam_after	slab_automove_extstore.c	/^    slab_stats_automove sam_after[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon56	file:	access:public
__anon56::sam_before	slab_automove_extstore.c	/^    slab_stats_automove sam_before[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon56	file:	access:public
__anon56::settings	slab_automove_extstore.c	/^    struct settings *settings;$/;"	m	struct:__anon56	typeref:struct:__anon56::settings	file:	access:public
__anon56::window_cur	slab_automove_extstore.c	/^    uint32_t window_cur;$/;"	m	struct:__anon56	file:	access:public
__anon56::window_data	slab_automove_extstore.c	/^    struct window_data *window_data;$/;"	m	struct:__anon56	typeref:struct:__anon56::window_data	file:	access:public
__anon56::window_global	slab_automove_extstore.c	/^    struct window_global *window_global;$/;"	m	struct:__anon56	typeref:struct:__anon56::window_global	file:	access:public
__anon56::window_size	slab_automove_extstore.c	/^    uint32_t window_size;$/;"	m	struct:__anon56	file:	access:public
__anon57::eflags	logger.h	/^    uint16_t eflags;$/;"	m	struct:__anon57	access:public
__anon57::format	logger.h	/^    char *format;$/;"	m	struct:__anon57	access:public
__anon57::reqlen	logger.h	/^    int reqlen;$/;"	m	struct:__anon57	access:public
__anon57::subtype	logger.h	/^    enum log_entry_subtype subtype;$/;"	m	struct:__anon57	typeref:enum:__anon57::log_entry_subtype	access:public
__anon59::buf	logger.h	/^    bipbuf_t *buf; \/* per-watcher output buffer *\/$/;"	m	struct:__anon59	access:public
__anon59::c	logger.h	/^    void *c; \/* original connection structure. still with source thread attached *\/$/;"	m	struct:__anon59	access:public
__anon59::eflags	logger.h	/^    uint16_t eflags; \/* flags we are interested in *\/$/;"	m	struct:__anon59	access:public
__anon59::failed_flush	logger.h	/^    bool failed_flush; \/* recently failed to write out (EAGAIN), wait before retry *\/$/;"	m	struct:__anon59	access:public
__anon59::id	logger.h	/^    int id; \/* id number for watcher list *\/$/;"	m	struct:__anon59	access:public
__anon59::sfd	logger.h	/^    int sfd; \/* client fd *\/$/;"	m	struct:__anon59	access:public
__anon59::skipped	logger.h	/^    uint64_t skipped; \/* lines skipped since last successful print *\/$/;"	m	struct:__anon59	access:public
__anon59::t	logger.h	/^    enum logger_watcher_type t; \/* stderr, client, syslog, etc *\/$/;"	m	struct:__anon59	typeref:enum:__anon59::logger_watcher_type	access:public
__anon9::__anon10::bodylen	protocol_binary.h	/^            uint32_t bodylen;$/;"	m	struct:__anon9::__anon10	access:public
__anon9::__anon10::cas	protocol_binary.h	/^            uint64_t cas;$/;"	m	struct:__anon9::__anon10	access:public
__anon9::__anon10::datatype	protocol_binary.h	/^            uint8_t datatype;$/;"	m	struct:__anon9::__anon10	access:public
__anon9::__anon10::extlen	protocol_binary.h	/^            uint8_t extlen;$/;"	m	struct:__anon9::__anon10	access:public
__anon9::__anon10::keylen	protocol_binary.h	/^            uint16_t keylen;$/;"	m	struct:__anon9::__anon10	access:public
__anon9::__anon10::magic	protocol_binary.h	/^            uint8_t magic;$/;"	m	struct:__anon9::__anon10	access:public
__anon9::__anon10::opaque	protocol_binary.h	/^            uint32_t opaque;$/;"	m	struct:__anon9::__anon10	access:public
__anon9::__anon10::opcode	protocol_binary.h	/^            uint8_t opcode;$/;"	m	struct:__anon9::__anon10	access:public
__anon9::__anon10::reserved	protocol_binary.h	/^            uint16_t reserved;$/;"	m	struct:__anon9::__anon10	access:public
__anon9::bytes	protocol_binary.h	/^        uint8_t bytes[24];$/;"	m	union:__anon9	access:public
__anon9::request	protocol_binary.h	/^        } request;$/;"	m	union:__anon9	typeref:struct:__anon9::__anon10	access:public
__builtin_expect	memcached.h	774;"	d
__check_for_switch_to_b	bipbuffer.c	/^static void __check_for_switch_to_b(bipbuf_t* me)$/;"	f	file:	signature:(bipbuf_t* me)
__gcc_attribute__	util.h	26;"	d
__gcc_attribute__	util.h	28;"	d
__need_IOV_MAX	memcached.c	37;"	d	file:
__store_wbuf	extstore.c	/^typedef struct __store_wbuf {$/;"	s	file:
__store_wbuf::buf	extstore.c	/^    char *buf;$/;"	m	struct:__store_wbuf	file:	access:public
__store_wbuf::buf_pos	extstore.c	/^    char *buf_pos;$/;"	m	struct:__store_wbuf	file:	access:public
__store_wbuf::flushed	extstore.c	/^    bool flushed; \/* whether wbuf has been flushed to disk *\/$/;"	m	struct:__store_wbuf	file:	access:public
__store_wbuf::free	extstore.c	/^    unsigned int free;$/;"	m	struct:__store_wbuf	file:	access:public
__store_wbuf::full	extstore.c	/^    bool full; \/* done writing to this page *\/$/;"	m	struct:__store_wbuf	file:	access:public
__store_wbuf::next	extstore.c	/^    struct __store_wbuf *next;$/;"	m	struct:__store_wbuf	typeref:struct:__store_wbuf::__store_wbuf	file:	access:public
__store_wbuf::offset	extstore.c	/^    unsigned int offset; \/* offset into page this write starts at *\/$/;"	m	struct:__store_wbuf	file:	access:public
__store_wbuf::size	extstore.c	/^    unsigned int size;$/;"	m	struct:__store_wbuf	file:	access:public
_allocate_page	extstore.c	/^static store_page *_allocate_page(store_engine *e, unsigned int bucket) {$/;"	f	file:	signature:(store_engine *e, unsigned int bucket)
_allocate_wbuf	extstore.c	/^static void _allocate_wbuf(store_engine *e, store_page *p) {$/;"	f	file:	signature:(store_engine *e, store_page *p)
_append_prepend	t/binary-extstore.t	/^sub _append_prepend {$/;"	s
_append_prepend	t/binary-sasl.t	/^sub _append_prepend {$/;"	s
_append_prepend	t/binary.t	/^sub _append_prepend {$/;"	s
_ascii_get_expand_ilist	memcached.c	/^static inline int _ascii_get_expand_ilist(conn *c, int i) {$/;"	f	file:	signature:(conn *c, int i)
_ascii_get_suffix_buf	memcached.c	/^static inline char *_ascii_get_suffix_buf(conn *c, int i) {$/;"	f	file:	signature:(conn *c, int i)
_crawler_module_t	crawler.c	/^struct _crawler_module_t {$/;"	s	file:
_crawler_module_t::c	crawler.c	/^    crawler_client_t c;$/;"	m	struct:_crawler_module_t	file:	access:public
_crawler_module_t::data	crawler.c	/^    void *data; \/* opaque data pointer *\/$/;"	m	struct:_crawler_module_t	file:	access:public
_crawler_module_t::mod	crawler.c	/^    crawler_module_reg_t *mod;$/;"	m	struct:_crawler_module_t	file:	access:public
_do_command	t/binary-extstore.t	/^sub _do_command {$/;"	s
_do_command	t/binary-sasl.t	/^sub _do_command {$/;"	s
_do_command	t/binary.t	/^sub _do_command {$/;"	s
_free_page	extstore.c	/^static void _free_page(store_engine *e, store_page *p) {$/;"	f	file:	signature:(store_engine *e, store_page *p)
_get_extstore	memcached.c	/^static inline int _get_extstore(conn *c, item *it, int iovst, int iovcnt) {$/;"	f	file:	signature:(conn *c, item *it, int iovst, int iovcnt)
_get_extstore	memcached.c	/^static inline int _get_extstore(conn *c, item *it, int iovst, int iovcnt);$/;"	p	file:	signature:(conn *c, item *it, int iovst, int iovcnt)
_get_extstore_cb	memcached.c	/^static void _get_extstore_cb(void *e, obj_io *io, int ret) {$/;"	f	file:	signature:(void *e, obj_io *io, int ret)
_get_extstore_cb	memcached.c	/^static void _get_extstore_cb(void *e, obj_io *io, int ret);$/;"	p	file:	signature:(void *e, obj_io *io, int ret)
_get_io_thread	extstore.c	/^static store_io_thread *_get_io_thread(store_engine *e) {$/;"	f	file:	signature:(store_engine *e)
_handle_single_response	t/binary-extstore.t	/^sub _handle_single_response {$/;"	s
_handle_single_response	t/binary-sasl.t	/^sub _handle_single_response {$/;"	s
_handle_single_response	t/binary.t	/^sub _handle_single_response {$/;"	s
_hashitem_before	assoc.c	/^static item** _hashitem_before (const char *key, const size_t nkey, const uint32_t hv) {$/;"	f	file:	signature:(const char *key, const size_t nkey, const uint32_t hv)
_incrdecr	t/binary-extstore.t	/^sub _incrdecr {$/;"	s
_incrdecr	t/binary-sasl.t	/^sub _incrdecr {$/;"	s
_incrdecr	t/binary.t	/^sub _incrdecr {$/;"	s
_incrdecr_cas	t/binary-extstore.t	/^sub _incrdecr_cas {$/;"	s
_incrdecr_cas	t/binary.t	/^sub _incrdecr_cas {$/;"	s
_incrdecr_header	t/binary-extstore.t	/^sub _incrdecr_header {$/;"	s
_incrdecr_header	t/binary-sasl.t	/^sub _incrdecr_header {$/;"	s
_incrdecr_header	t/binary.t	/^sub _incrdecr_header {$/;"	s
_io_wrap	memcached.h	/^typedef struct _io_wrap {$/;"	s
_io_wrap::active	memcached.h	/^    bool active; \/\/ FIXME: canary for test. remove$/;"	m	struct:_io_wrap	access:public
_io_wrap::badcrc	memcached.h	/^    bool badcrc;              \/* signal a crc failure *\/$/;"	m	struct:_io_wrap	access:public
_io_wrap::c	memcached.h	/^    conn *c;$/;"	m	struct:_io_wrap	access:public
_io_wrap::hdr_it	memcached.h	/^    item *hdr_it;             \/* original header item. *\/$/;"	m	struct:_io_wrap	access:public
_io_wrap::io	memcached.h	/^    obj_io io;$/;"	m	struct:_io_wrap	access:public
_io_wrap::iovec_count	memcached.h	/^    unsigned int iovec_count; \/* total number of iovecs *\/$/;"	m	struct:_io_wrap	access:public
_io_wrap::iovec_data	memcached.h	/^    unsigned int iovec_data;  \/* specific index of data iovec *\/$/;"	m	struct:_io_wrap	access:public
_io_wrap::iovec_start	memcached.h	/^    unsigned int iovec_start; \/* start of the iovecs for this IO *\/$/;"	m	struct:_io_wrap	access:public
_io_wrap::miss	memcached.h	/^    bool miss;                \/* signal a miss to unlink hdr_it *\/$/;"	m	struct:_io_wrap	access:public
_io_wrap::next	memcached.h	/^    struct _io_wrap *next;$/;"	m	struct:_io_wrap	typeref:struct:_io_wrap::_io_wrap	access:public
_logentry	logger.h	/^typedef struct _logentry {$/;"	s
_logentry::__anon58::end	logger.h	/^        char end;$/;"	m	union:_logentry::__anon58	access:public
_logentry::__anon58::entry	logger.h	/^        void *entry; \/* probably an item *\/$/;"	m	union:_logentry::__anon58	access:public
_logentry::data	logger.h	/^    } data[];$/;"	m	struct:_logentry	typeref:union:_logentry::__anon58	access:public
_logentry::eflags	logger.h	/^    uint16_t eflags;$/;"	m	struct:_logentry	access:public
_logentry::event	logger.h	/^    enum log_entry_subtype event;$/;"	m	struct:_logentry	typeref:enum:_logentry::log_entry_subtype	access:public
_logentry::gid	logger.h	/^    uint64_t gid;$/;"	m	struct:_logentry	access:public
_logentry::pad	logger.h	/^    uint8_t pad;$/;"	m	struct:_logentry	access:public
_logentry::size	logger.h	/^    int size;$/;"	m	struct:_logentry	access:public
_logentry::tv	logger.h	/^    struct timeval tv; \/* not monotonic! *\/$/;"	m	struct:_logentry	typeref:struct:_logentry::timeval	access:public
_logger	logger.h	/^typedef struct _logger {$/;"	s
_logger::blocked	logger.h	/^    uint64_t blocked; \/* times blocked instead of dropped *\/$/;"	m	struct:_logger	access:public
_logger::buf	logger.h	/^    bipbuf_t *buf;$/;"	m	struct:_logger	access:public
_logger::dropped	logger.h	/^    uint64_t dropped; \/* entries dropped *\/$/;"	m	struct:_logger	access:public
_logger::eflags	logger.h	/^    uint16_t eflags; \/* flags this logger should log *\/$/;"	m	struct:_logger	access:public
_logger::entry_map	logger.h	/^    const entry_details *entry_map;$/;"	m	struct:_logger	access:public
_logger::fetcher_ratio	logger.h	/^    uint16_t fetcher_ratio; \/* log one out of every N fetches *\/$/;"	m	struct:_logger	access:public
_logger::mutation_ratio	logger.h	/^    uint16_t mutation_ratio; \/* log one out of every N mutations *\/$/;"	m	struct:_logger	access:public
_logger::mutex	logger.h	/^    pthread_mutex_t mutex; \/* guard for this + *buf *\/$/;"	m	struct:_logger	access:public
_logger::next	logger.h	/^    struct _logger *next;$/;"	m	struct:_logger	typeref:struct:_logger::_logger	access:public
_logger::prev	logger.h	/^    struct _logger *prev;$/;"	m	struct:_logger	typeref:struct:_logger::_logger	access:public
_logger::written	logger.h	/^    uint64_t written; \/* entries written to the buffer *\/$/;"	m	struct:_logger	access:public
_logger_log_evictions	logger.c	/^static void _logger_log_evictions(logentry *e, item *it) {$/;"	f	file:	signature:(logentry *e, item *it)
_logger_log_ext_write	logger.c	/^static void _logger_log_ext_write(logentry *e, item *it, uint8_t bucket) {$/;"	f	file:	signature:(logentry *e, item *it, uint8_t bucket)
_logger_log_item_get	logger.c	/^static void _logger_log_item_get(logentry *e, const int was_found, const char *key,$/;"	f	file:	signature:(logentry *e, const int was_found, const char *key, const int nkey, const uint8_t clsid)
_logger_log_item_store	logger.c	/^static void _logger_log_item_store(logentry *e, const enum store_item_type status,$/;"	f	file:	signature:(logentry *e, const enum store_item_type status, const int comm, char *key, const int nkey, rel_time_t ttl, const uint8_t clsid)
_logger_thread_parse_ee	logger.c	/^static int _logger_thread_parse_ee(logentry *e, char *scratch) {$/;"	f	file:	signature:(logentry *e, char *scratch)
_logger_thread_parse_extw	logger.c	/^static int _logger_thread_parse_extw(logentry *e, char *scratch) {$/;"	f	file:	signature:(logentry *e, char *scratch)
_logger_thread_parse_ige	logger.c	/^static int _logger_thread_parse_ige(logentry *e, char *scratch) {$/;"	f	file:	signature:(logentry *e, char *scratch)
_logger_thread_parse_ise	logger.c	/^static int _logger_thread_parse_ise(logentry *e, char *scratch) {$/;"	f	file:	signature:(logentry *e, char *scratch)
_lru_bump_buf	items.c	/^typedef struct _lru_bump_buf {$/;"	s	file:
_lru_bump_buf::buf	items.c	/^    bipbuf_t *buf;$/;"	m	struct:_lru_bump_buf	file:	access:public
_lru_bump_buf::dropped	items.c	/^    uint64_t dropped;$/;"	m	struct:_lru_bump_buf	file:	access:public
_lru_bump_buf::mutex	items.c	/^    pthread_mutex_t mutex;$/;"	m	struct:_lru_bump_buf	file:	access:public
_lru_bump_buf::next	items.c	/^    struct _lru_bump_buf *next;$/;"	m	struct:_lru_bump_buf	typeref:struct:_lru_bump_buf::_lru_bump_buf	file:	access:public
_lru_bump_buf::prev	items.c	/^    struct _lru_bump_buf *prev;$/;"	m	struct:_lru_bump_buf	typeref:struct:_lru_bump_buf::_lru_bump_buf	file:	access:public
_next_version	extstore.c	/^static uint64_t _next_version(store_engine *e) {$/;"	f	file:	signature:(store_engine *e)
_obj_io	extstore.h	/^struct _obj_io {$/;"	s
_obj_io::buf	extstore.h	/^    char *buf;  \/* buffer of data to read or write to *\/$/;"	m	struct:_obj_io	access:public
_obj_io::cb	extstore.h	/^    obj_io_cb cb;$/;"	m	struct:_obj_io	access:public
_obj_io::data	extstore.h	/^    void *data; \/* user supplied data pointer *\/$/;"	m	struct:_obj_io	access:public
_obj_io::iov	extstore.h	/^    struct iovec *iov; \/* alternatively, use this iovec *\/$/;"	m	struct:_obj_io	typeref:struct:_obj_io::iovec	access:public
_obj_io::iovcnt	extstore.h	/^    unsigned int iovcnt; \/* number of IOV's *\/$/;"	m	struct:_obj_io	access:public
_obj_io::len	extstore.h	/^    unsigned int len;     \/* for both modes *\/$/;"	m	struct:_obj_io	access:public
_obj_io::mode	extstore.h	/^    enum obj_io_mode mode;$/;"	m	struct:_obj_io	typeref:enum:_obj_io::obj_io_mode	access:public
_obj_io::next	extstore.h	/^    struct _obj_io *next;$/;"	m	struct:_obj_io	typeref:struct:_obj_io::_obj_io	access:public
_obj_io::offset	extstore.h	/^    unsigned int offset;  \/* for read mode *\/$/;"	m	struct:_obj_io	access:public
_obj_io::page_id	extstore.h	/^    unsigned short page_id; \/* for read mode *\/$/;"	m	struct:_obj_io	access:public
_obj_io::page_version	extstore.h	/^    unsigned int page_version;     \/* page version for read mode *\/$/;"	m	struct:_obj_io	access:public
_parse_slab_sizes	memcached.c	/^static bool _parse_slab_sizes(char *s, uint32_t *slab_sizes) {$/;"	f	file:	signature:(char *s, uint32_t *slab_sizes)
_prefix_stats	stats.c	/^struct _prefix_stats {$/;"	s	file:
_prefix_stats::next	stats.c	/^    PREFIX_STATS *next;$/;"	m	struct:_prefix_stats	file:	access:public
_prefix_stats::num_deletes	stats.c	/^    uint64_t      num_deletes;$/;"	m	struct:_prefix_stats	file:	access:public
_prefix_stats::num_gets	stats.c	/^    uint64_t      num_gets;$/;"	m	struct:_prefix_stats	file:	access:public
_prefix_stats::num_hits	stats.c	/^    uint64_t      num_hits;$/;"	m	struct:_prefix_stats	file:	access:public
_prefix_stats::num_sets	stats.c	/^    uint64_t      num_sets;$/;"	m	struct:_prefix_stats	file:	access:public
_prefix_stats::prefix	stats.c	/^    char         *prefix;$/;"	m	struct:_prefix_stats	file:	access:public
_prefix_stats::prefix_len	stats.c	/^    size_t        prefix_len;$/;"	m	struct:_prefix_stats	file:	access:public
_read_from_wbuf	extstore.c	/^static inline int _read_from_wbuf(store_page *p, obj_io *io) {$/;"	f	file:	signature:(store_page *p, obj_io *io)
_storage_compact_cb	storage.c	/^static void _storage_compact_cb(void *e, obj_io *io, int ret) {$/;"	f	file:	signature:(void *e, obj_io *io, int ret)
_store_item_copy_chunks	memcached.c	/^static int _store_item_copy_chunks(item *d_it, item *s_it, const int len) {$/;"	f	file:	signature:(item *d_it, item *s_it, const int len)
_store_item_copy_data	memcached.c	/^static int _store_item_copy_data(int comm, item *old_it, item *new_it, item *add_it) {$/;"	f	file:	signature:(int comm, item *old_it, item *new_it, item *add_it)
_store_page	extstore.c	/^typedef struct _store_page {$/;"	s	file:
_store_page::active	extstore.c	/^    bool active; \/* actively being written to *\/$/;"	m	struct:_store_page	file:	access:public
_store_page::allocated	extstore.c	/^    unsigned int allocated;$/;"	m	struct:_store_page	file:	access:public
_store_page::bucket	extstore.c	/^    unsigned int bucket; \/* which bucket the page is linked into *\/$/;"	m	struct:_store_page	file:	access:public
_store_page::bytes_used	extstore.c	/^    uint64_t bytes_used; \/* _delete can decrease post-closing *\/$/;"	m	struct:_store_page	file:	access:public
_store_page::closed	extstore.c	/^    bool closed; \/* closed and draining before free *\/$/;"	m	struct:_store_page	file:	access:public
_store_page::fd	extstore.c	/^    int fd;$/;"	m	struct:_store_page	file:	access:public
_store_page::free	extstore.c	/^    bool free; \/* on freelist *\/$/;"	m	struct:_store_page	file:	access:public
_store_page::id	extstore.c	/^    unsigned short id;$/;"	m	struct:_store_page	file:	access:public
_store_page::mutex	extstore.c	/^    pthread_mutex_t mutex; \/* Need to be held for most operations *\/$/;"	m	struct:_store_page	file:	access:public
_store_page::next	extstore.c	/^    struct _store_page *next;$/;"	m	struct:_store_page	typeref:struct:_store_page::_store_page	file:	access:public
_store_page::obj_count	extstore.c	/^    uint64_t obj_count; \/* _delete can decrease post-closing *\/$/;"	m	struct:_store_page	file:	access:public
_store_page::offset	extstore.c	/^    uint64_t offset; \/* starting address of page within fd *\/$/;"	m	struct:_store_page	file:	access:public
_store_page::refcount	extstore.c	/^    unsigned int refcount;$/;"	m	struct:_store_page	file:	access:public
_store_page::version	extstore.c	/^    unsigned int version;$/;"	m	struct:_store_page	file:	access:public
_store_page::wbuf	extstore.c	/^    _store_wbuf *wbuf; \/* currently active wbuf from the stack *\/$/;"	m	struct:_store_page	file:	access:public
_store_page::written	extstore.c	/^    unsigned int written; \/* item offsets can be past written if wbuf not flushed *\/$/;"	m	struct:_store_page	file:	access:public
_store_wbuf	extstore.c	/^} _store_wbuf;$/;"	t	typeref:struct:__store_wbuf	file:
_strchunk	memcached.h	/^typedef struct _strchunk {$/;"	s
_strchunk::data	memcached.h	/^    char data[];$/;"	m	struct:_strchunk	access:public
_strchunk::head	memcached.h	/^    struct _stritem  *head;     \/* always points to the owner chunk *\/$/;"	m	struct:_strchunk	typeref:struct:_strchunk::_stritem	access:public
_strchunk::it_flags	memcached.h	/^    uint8_t          it_flags;  \/* ITEM_* above. *\/$/;"	m	struct:_strchunk	access:public
_strchunk::nbytes	memcached.h	/^    int              nbytes;    \/* used. *\/$/;"	m	struct:_strchunk	access:public
_strchunk::next	memcached.h	/^    struct _strchunk *next;     \/* points within its own chain. *\/$/;"	m	struct:_strchunk	typeref:struct:_strchunk::_strchunk	access:public
_strchunk::orig_clsid	memcached.h	/^    uint8_t          orig_clsid; \/* For obj hdr chunks slabs_clsid is fake. *\/$/;"	m	struct:_strchunk	access:public
_strchunk::prev	memcached.h	/^    struct _strchunk *prev;     \/* can potentially point to the head. *\/$/;"	m	struct:_strchunk	typeref:struct:_strchunk::_strchunk	access:public
_strchunk::refcount	memcached.h	/^    unsigned short   refcount;  \/* used? *\/$/;"	m	struct:_strchunk	access:public
_strchunk::size	memcached.h	/^    int              size;      \/* available chunk space in bytes *\/$/;"	m	struct:_strchunk	access:public
_strchunk::slabs_clsid	memcached.h	/^    uint8_t          slabs_clsid; \/* Same as above. *\/$/;"	m	struct:_strchunk	access:public
_strchunk::used	memcached.h	/^    int              used;      \/* chunk space used *\/$/;"	m	struct:_strchunk	access:public
_stritem	memcached.h	/^typedef struct _stritem {$/;"	s
_stritem::__anon51::cas	memcached.h	/^        uint64_t cas;$/;"	m	union:_stritem::__anon51	access:public
_stritem::__anon51::end	memcached.h	/^        char end;$/;"	m	union:_stritem::__anon51	access:public
_stritem::data	memcached.h	/^    } data[];$/;"	m	struct:_stritem	typeref:union:_stritem::__anon51	access:public
_stritem::exptime	memcached.h	/^    rel_time_t      exptime;    \/* expire time *\/$/;"	m	struct:_stritem	access:public
_stritem::h_next	memcached.h	/^    struct _stritem *h_next;    \/* hash chain next *\/$/;"	m	struct:_stritem	typeref:struct:_stritem::_stritem	access:public
_stritem::it_flags	memcached.h	/^    uint8_t         it_flags;   \/* ITEM_* above *\/$/;"	m	struct:_stritem	access:public
_stritem::nbytes	memcached.h	/^    int             nbytes;     \/* size of data *\/$/;"	m	struct:_stritem	access:public
_stritem::next	memcached.h	/^    struct _stritem *next;$/;"	m	struct:_stritem	typeref:struct:_stritem::_stritem	access:public
_stritem::nkey	memcached.h	/^    uint8_t         nkey;       \/* key length, w\/terminating null and padding *\/$/;"	m	struct:_stritem	access:public
_stritem::nsuffix	memcached.h	/^    uint8_t         nsuffix;    \/* length of flags-and-length string *\/$/;"	m	struct:_stritem	access:public
_stritem::prev	memcached.h	/^    struct _stritem *prev;$/;"	m	struct:_stritem	typeref:struct:_stritem::_stritem	access:public
_stritem::refcount	memcached.h	/^    unsigned short  refcount;$/;"	m	struct:_stritem	access:public
_stritem::slabs_clsid	memcached.h	/^    uint8_t         slabs_clsid;\/* which slab class we're in *\/$/;"	m	struct:_stritem	access:public
_stritem::time	memcached.h	/^    rel_time_t      time;       \/* least recent access *\/$/;"	m	struct:_stritem	access:public
_submit_wbuf	extstore.c	/^static void _submit_wbuf(store_engine *e, store_page *p) {$/;"	f	file:	signature:(store_engine *e, store_page *p)
_wbuf_cb	extstore.c	/^static void _wbuf_cb(void *ep, obj_io *io, int ret) {$/;"	f	file:	signature:(void *ep, obj_io *io, int ret)
a_end	bipbuffer.h	/^    unsigned int a_start, a_end;$/;"	m	struct:__anon47	access:public
a_start	bipbuffer.h	/^    unsigned int a_start, a_end;$/;"	m	struct:__anon47	access:public
abs_builddir	doc/Makefile	/^abs_builddir = \/home\/dormando\/d\/p\/danga\/git\/memcached\/doc$/;"	m
abs_srcdir	doc/Makefile	/^abs_srcdir = \/home\/dormando\/d\/p\/danga\/git\/memcached\/doc$/;"	m
abs_top_builddir	doc/Makefile	/^abs_top_builddir = \/home\/dormando\/d\/p\/danga\/git\/memcached$/;"	m
abs_top_srcdir	doc/Makefile	/^abs_top_srcdir = \/home\/dormando\/d\/p\/danga\/git\/memcached$/;"	m
ac_ct_CC	doc/Makefile	/^ac_ct_CC = gcc$/;"	m
ac_fn_c_check_decl	configure	/^ac_fn_c_check_decl ()$/;"	f
ac_fn_c_check_func	configure	/^ac_fn_c_check_func ()$/;"	f
ac_fn_c_check_header_compile	configure	/^ac_fn_c_check_header_compile ()$/;"	f
ac_fn_c_check_header_mongrel	configure	/^ac_fn_c_check_header_mongrel ()$/;"	f
ac_fn_c_check_type	configure	/^ac_fn_c_check_type ()$/;"	f
ac_fn_c_try_compile	configure	/^ac_fn_c_try_compile ()$/;"	f
ac_fn_c_try_cpp	configure	/^ac_fn_c_try_cpp ()$/;"	f
ac_fn_c_try_link	configure	/^ac_fn_c_try_link ()$/;"	f
ac_fn_c_try_run	configure	/^ac_fn_c_try_run ()$/;"	f
accept_new_conns	memcached.h	/^void accept_new_conns(const bool do_accept);$/;"	p	signature:(const bool do_accept)
accept_new_conns	thread.c	/^void accept_new_conns(const bool do_accept) {$/;"	f	signature:(const bool do_accept)
accepting_conns	memcached.h	/^    bool          accepting_conns;  \/* whether we are currently accepting  标识我们当前是否处于listen状态 *\/$/;"	m	struct:stats_state	access:public
access	memcached.h	/^    int access;  \/* access mask (a la chmod) for unix domain socket *\/$/;"	m	struct:settings	access:public
active	extstore.c	/^    bool active; \/* actively being written to *\/$/;"	m	struct:_store_page	file:	access:public
active	memcached.h	/^    bool active; \/\/ FIXME: canary for test. remove$/;"	m	struct:_io_wrap	access:public
active_crawler_mod	crawler.c	/^crawler_module_t active_crawler_mod;$/;"	v
active_crawler_type	crawler.c	/^enum crawler_run_type active_crawler_type;$/;"	v	typeref:enum:crawler_run_type
add	t/binary-extstore.t	/^sub add {$/;"	s
add	t/binary-sasl.t	/^sub add {$/;"	s
add	t/binary.t	/^sub add {$/;"	s
add_bin_header	memcached.c	/^static void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {$/;"	f	file:	signature:(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len)
add_chunked_item_iovs	memcached.c	/^static int add_chunked_item_iovs(conn *c, item *it, int len) {$/;"	f	file:	signature:(conn *c, item *it, int len)
add_chunked_item_iovs	memcached.c	/^static int add_chunked_item_iovs(conn *c, item *it, int len);$/;"	p	file:	signature:(conn *c, item *it, int len)
add_delta	memcached.h	/^enum delta_result_type add_delta(conn *c, const char *key,$/;"	p	signature:(conn *c, const char *key, const size_t nkey, bool incr, const int64_t delta, char *buf, uint64_t *cas)
add_delta	thread.c	/^enum delta_result_type add_delta(conn *c, const char *key,$/;"	f	signature:(conn *c, const char *key, const size_t nkey, bool incr, const int64_t delta, char *buf, uint64_t *cas)
add_iov	memcached.c	/^static int add_iov(conn *c, const void *buf, int len) {$/;"	f	file:	signature:(conn *c, const void *buf, int len)
add_iov	memcached.c	/^static int add_iov(conn *c, const void *buf, int len);$/;"	p	file:	signature:(conn *c, const void *buf, int len)
add_msghdr	memcached.c	/^static int add_msghdr(conn *c)$/;"	f	file:	signature:(conn *c)
add_msghdr	memcached.c	/^static int add_msghdr(conn *c);$/;"	p	file:	signature:(conn *c)
age	items.h	/^    uint32_t age;$/;"	m	struct:__anon3	access:public
age	slab_automove.c	/^    uint64_t age;$/;"	m	struct:window_data	file:	access:public
age	slab_automove_extstore.c	/^    uint64_t age;$/;"	m	struct:window_data	file:	access:public
aix_post_process_depfile	depcomp	/^aix_post_process_depfile ()$/;"	f
allocated	extstore.c	/^    unsigned int allocated;$/;"	m	struct:_store_page	file:	access:public
allow_closed_read	testapp.c	/^static bool allow_closed_read = false;$/;"	v	file:
allow_new_conns	memcached.c	/^static volatile bool allow_new_conns = true;$/;"	v	file:
am__DIST_COMMON	doc/Makefile	/^am__DIST_COMMON = $(srcdir)\/Makefile.in$/;"	m
am__aclocal_m4_deps	doc/Makefile	/^am__aclocal_m4_deps = $(top_srcdir)\/version.m4 \\$/;"	m
am__base_list	doc/Makefile	/^am__base_list = \\$/;"	m
am__can_run_installinfo	doc/Makefile	/^am__can_run_installinfo = \\$/;"	m
am__cd	doc/Makefile	/^am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd$/;"	m
am__configure_deps	doc/Makefile	/^am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\$/;"	m
am__include	doc/Makefile	/^am__include = include$/;"	m
am__install_max	doc/Makefile	/^am__install_max = 40$/;"	m
am__installdirs	doc/Makefile	/^am__installdirs = "$(DESTDIR)$(man1dir)"$/;"	m
am__is_gnu_make	doc/Makefile	/^am__is_gnu_make = { \\$/;"	m
am__leading_dot	doc/Makefile	/^am__leading_dot = .$/;"	m
am__make_dryrun	doc/Makefile	/^am__make_dryrun = (target_option=n; $(am__make_running_with_option))$/;"	m
am__make_keepgoing	doc/Makefile	/^am__make_keepgoing = (target_option=k; $(am__make_running_with_option))$/;"	m
am__make_running_with_option	doc/Makefile	/^am__make_running_with_option = \\$/;"	m
am__nobase_list	doc/Makefile	/^am__nobase_list = $(am__nobase_strip_setup); \\$/;"	m
am__nobase_strip	doc/Makefile	/^am__nobase_strip = \\$/;"	m
am__nobase_strip_setup	doc/Makefile	/^am__nobase_strip_setup = \\$/;"	m
am__quote	doc/Makefile	/^am__quote = $/;"	m
am__strip_dir	doc/Makefile	/^am__strip_dir = f=`echo $$p | sed -e 's|^.*\/||'`;$/;"	m
am__tagged_files	doc/Makefile	/^am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)$/;"	m
am__tar	doc/Makefile	/^am__tar = $${TAR-tar} chof - "$$tardir"$/;"	m
am__uninstall_files_from_dir	doc/Makefile	/^am__uninstall_files_from_dir = { \\$/;"	m
am__untar	doc/Makefile	/^am__untar = $${TAR-tar} xf -$/;"	m
am__v_GEN_	doc/Makefile	/^am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_GEN_0	doc/Makefile	/^am__v_GEN_0 = @echo "  GEN     " $@;$/;"	m
am__v_GEN_1	doc/Makefile	/^am__v_GEN_1 = $/;"	m
am__v_P_	doc/Makefile	/^am__v_P_ = $(am__v_P_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_P_0	doc/Makefile	/^am__v_P_0 = false$/;"	m
am__v_P_1	doc/Makefile	/^am__v_P_1 = :$/;"	m
am__v_at_	doc/Makefile	/^am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))$/;"	m
am__v_at_0	doc/Makefile	/^am__v_at_0 = @$/;"	m
am__v_at_1	doc/Makefile	/^am__v_at_1 = $/;"	m
am__vpath_adj	doc/Makefile	/^am__vpath_adj = case $$p in \\$/;"	m
am__vpath_adj_setup	doc/Makefile	/^am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;$/;"	m
append_ascii_stats	memcached.c	/^static void append_ascii_stats(const char *key, const uint16_t klen,$/;"	f	file:	signature:(const char *key, const uint16_t klen, const char *val, const uint32_t vlen, conn *c)
append_bin_stats	memcached.c	/^static void append_bin_stats(const char *key, const uint16_t klen,$/;"	f	file:	signature:(const char *key, const uint16_t klen, const char *val, const uint32_t vlen, conn *c)
append_stat	memcached.c	/^void append_stat(const char *name, ADD_STAT add_stats, conn *c,$/;"	f	signature:(const char *name, ADD_STAT add_stats, conn *c, const char *fmt, ...)
append_stat	memcached.h	/^void append_stat(const char *name, ADD_STAT add_stats, conn *c,$/;"	p	signature:(const char *name, ADD_STAT add_stats, conn *c, const char *fmt, ...)
append_stats	memcached.c	/^static void append_stats(const char *key, const uint16_t klen,$/;"	f	file:	signature:(const char *key, const uint16_t klen, const char *val, const uint32_t vlen, const void *cookie)
arithmetic_command	testapp.c	/^static off_t arithmetic_command(char* buf,$/;"	f	file:	signature:(char* buf, size_t bufsz, uint8_t cmd, const void* key, size_t keylen, uint64_t delta, uint64_t initial, uint32_t exp)
as_fn_append	configure	/^  as_fn_append ()$/;"	f
as_fn_arith	configure	/^  as_fn_arith ()$/;"	f
as_fn_error	configure	/^as_fn_error ()$/;"	f
as_fn_executable_p	configure	/^as_fn_executable_p ()$/;"	f
as_fn_exit	configure	/^as_fn_exit ()$/;"	f
as_fn_failure	configure	/^as_fn_failure () { as_fn_return 1; }$/;"	f
as_fn_mkdir_p	configure	/^as_fn_mkdir_p ()$/;"	f
as_fn_ret_failure	configure	/^as_fn_ret_failure () { return 1; }$/;"	f
as_fn_ret_success	configure	/^as_fn_ret_success () { return 0; }$/;"	f
as_fn_set_status	configure	/^as_fn_set_status ()$/;"	f
as_fn_success	configure	/^as_fn_success () { as_fn_return 0; }$/;"	f
as_fn_unset	configure	/^as_fn_unset ()$/;"	f
ascii_prot	memcached.h	/^    ascii_prot = 3, \/* arbitrary value. *\/$/;"	e	enum:protocol
assoc_delete	assoc.c	/^void assoc_delete(const char *key, const size_t nkey, const uint32_t hv) {$/;"	f	signature:(const char *key, const size_t nkey, const uint32_t hv)
assoc_delete	assoc.h	/^void assoc_delete(const char *key, const size_t nkey, const uint32_t hv);$/;"	p	signature:(const char *key, const size_t nkey, const uint32_t hv)
assoc_expand	assoc.c	/^static void assoc_expand(void) {$/;"	f	file:	signature:(void)
assoc_find	assoc.c	/^item *assoc_find(const char *key, const size_t nkey, const uint32_t hv) {$/;"	f	signature:(const char *key, const size_t nkey, const uint32_t hv)
assoc_find	assoc.h	/^item *assoc_find(const char *key, const size_t nkey, const uint32_t hv);$/;"	p	signature:(const char *key, const size_t nkey, const uint32_t hv)
assoc_init	assoc.c	/^void assoc_init(const int hashtable_init) {$/;"	f	signature:(const int hashtable_init)
assoc_init	assoc.h	/^void assoc_init(const int hashpower_init);$/;"	p	signature:(const int hashpower_init)
assoc_insert	assoc.c	/^int assoc_insert(item *it, const uint32_t hv) {$/;"	f	signature:(item *it, const uint32_t hv)
assoc_insert	assoc.h	/^int assoc_insert(item *item, const uint32_t hv);$/;"	p	signature:(item *item, const uint32_t hv)
assoc_maintenance_thread	assoc.c	/^static void *assoc_maintenance_thread(void *arg) {$/;"	f	file:	signature:(void *arg)
assoc_start_expand	assoc.c	/^void assoc_start_expand(uint64_t curr_items) {$/;"	f	signature:(uint64_t curr_items)
assoc_start_expand	assoc.h	/^void assoc_start_expand(uint64_t curr_items);$/;"	p	signature:(uint64_t curr_items)
atomics_mutex	thread.c	/^pthread_mutex_t atomics_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
auth_error	t/binary-sasl.t	/^sub auth_error {$/;"	s
authenticate	t/binary-sasl.t	/^sub authenticate {$/;"	s
authenticated	memcached.c	/^static bool authenticated(conn *c) {$/;"	f	file:	signature:(conn *c)
authenticated	memcached.h	/^    bool authenticated;$/;"	m	struct:conn	access:public
b_end	bipbuffer.h	/^    unsigned int b_end;$/;"	m	struct:__anon47	access:public
b_inuse	bipbuffer.h	/^    int b_inuse;$/;"	m	struct:__anon47	access:public
backlog	memcached.h	/^    int backlog;$/;"	m	struct:settings	access:public
badcrc	memcached.h	/^    bool badcrc;              \/* signal a crc failure *\/$/;"	m	struct:_io_wrap	access:public
base	memcached.h	/^    struct event_base *base;    \/* libevent handle this thread uses 该线程关联的event_base实例 *\/$/;"	m	struct:__anon54	typeref:struct:__anon54::event_base	access:public
bin_list_sasl_mechs	memcached.c	/^static void bin_list_sasl_mechs(conn *c) {$/;"	f	file:	signature:(conn *c)
bin_no_state	memcached.h	/^    bin_no_state,$/;"	e	enum:bin_substates
bin_read_flush_exptime	memcached.h	/^    bin_read_flush_exptime,$/;"	e	enum:bin_substates
bin_read_key	memcached.c	/^static void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {$/;"	f	file:	signature:(conn *c, enum bin_substates next_substate, int extra)
bin_read_set_value	memcached.h	/^    bin_read_set_value,$/;"	e	enum:bin_substates
bin_reading_cas_header	memcached.h	/^    bin_reading_cas_header,$/;"	e	enum:bin_substates
bin_reading_del_header	memcached.h	/^    bin_reading_del_header,$/;"	e	enum:bin_substates
bin_reading_get_key	memcached.h	/^    bin_reading_get_key,$/;"	e	enum:bin_substates
bin_reading_incr_header	memcached.h	/^    bin_reading_incr_header,$/;"	e	enum:bin_substates
bin_reading_sasl_auth	memcached.h	/^    bin_reading_sasl_auth,$/;"	e	enum:bin_substates
bin_reading_sasl_auth_data	memcached.h	/^    bin_reading_sasl_auth_data,$/;"	e	enum:bin_substates
bin_reading_set_header	memcached.h	/^    bin_reading_set_header,$/;"	e	enum:bin_substates
bin_reading_stat	memcached.h	/^    bin_reading_stat,$/;"	e	enum:bin_substates
bin_reading_touch_key	memcached.h	/^    bin_reading_touch_key,$/;"	e	enum:bin_substates
bin_substates	memcached.h	/^enum bin_substates {$/;"	g
binary_get_key	memcached.c	/^static char* binary_get_key(conn *c) {$/;"	f	file:	signature:(conn *c)
binary_get_request	memcached.c	/^static void* binary_get_request(conn *c) {$/;"	f	file:	signature:(conn *c)
binary_header	memcached.h	/^    protocol_binary_request_header binary_header;$/;"	m	struct:conn	access:public
binary_hickup_recv_verification_thread	testapp.c	/^static void *binary_hickup_recv_verification_thread(void *arg) {$/;"	f	file:	signature:(void *arg)
binary_prot	memcached.h	/^    binary_prot,$/;"	e	enum:protocol
binding_protocol	memcached.h	/^    enum protocol binding_protocol; \/\/ sasl功能关联的协议类型$/;"	m	struct:settings	typeref:enum:settings::protocol	access:public
bindir	doc/Makefile	/^bindir = ${exec_prefix}\/bin$/;"	m
bipbuf_free	bipbuffer.c	/^void bipbuf_free(bipbuf_t* me)$/;"	f	signature:(bipbuf_t* me)
bipbuf_free	bipbuffer.h	/^void bipbuf_free(bipbuf_t *me);$/;"	p	signature:(bipbuf_t *me)
bipbuf_init	bipbuffer.c	/^void bipbuf_init(bipbuf_t* me, const unsigned int size)$/;"	f	signature:(bipbuf_t* me, const unsigned int size)
bipbuf_init	bipbuffer.h	/^void bipbuf_init(bipbuf_t* me, const unsigned int size);$/;"	p	signature:(bipbuf_t* me, const unsigned int size)
bipbuf_is_empty	bipbuffer.c	/^int bipbuf_is_empty(const bipbuf_t* me)$/;"	f	signature:(const bipbuf_t* me)
bipbuf_is_empty	bipbuffer.h	/^int bipbuf_is_empty(const bipbuf_t* me);$/;"	p	signature:(const bipbuf_t* me)
bipbuf_new	bipbuffer.c	/^bipbuf_t *bipbuf_new(const unsigned int size)$/;"	f	signature:(const unsigned int size)
bipbuf_new	bipbuffer.h	/^bipbuf_t *bipbuf_new(const unsigned int size);$/;"	p	signature:(const unsigned int size)
bipbuf_offer	bipbuffer.c	/^int bipbuf_offer(bipbuf_t* me, const unsigned char *data, const int size)$/;"	f	signature:(bipbuf_t* me, const unsigned char *data, const int size)
bipbuf_offer	bipbuffer.h	/^int bipbuf_offer(bipbuf_t *me, const unsigned char *data, const int size);$/;"	p	signature:(bipbuf_t *me, const unsigned char *data, const int size)
bipbuf_peek	bipbuffer.c	/^unsigned char *bipbuf_peek(const bipbuf_t* me, const unsigned int size)$/;"	f	signature:(const bipbuf_t* me, const unsigned int size)
bipbuf_peek	bipbuffer.h	/^unsigned char *bipbuf_peek(const bipbuf_t* me, const unsigned int len);$/;"	p	signature:(const bipbuf_t* me, const unsigned int len)
bipbuf_peek_all	bipbuffer.c	/^unsigned char *bipbuf_peek_all(const bipbuf_t* me, unsigned int *size)$/;"	f	signature:(const bipbuf_t* me, unsigned int *size)
bipbuf_peek_all	bipbuffer.h	/^unsigned char *bipbuf_peek_all(const bipbuf_t* me, unsigned int *len);$/;"	p	signature:(const bipbuf_t* me, unsigned int *len)
bipbuf_poll	bipbuffer.c	/^unsigned char *bipbuf_poll(bipbuf_t* me, const unsigned int size)$/;"	f	signature:(bipbuf_t* me, const unsigned int size)
bipbuf_poll	bipbuffer.h	/^unsigned char *bipbuf_poll(bipbuf_t* me, const unsigned int size);$/;"	p	signature:(bipbuf_t* me, const unsigned int size)
bipbuf_push	bipbuffer.c	/^int bipbuf_push(bipbuf_t* me, const int size)$/;"	f	signature:(bipbuf_t* me, const int size)
bipbuf_push	bipbuffer.h	/^int bipbuf_push(bipbuf_t* me, const int size);$/;"	p	signature:(bipbuf_t* me, const int size)
bipbuf_request	bipbuffer.c	/^unsigned char *bipbuf_request(bipbuf_t* me, const int size)$/;"	f	signature:(bipbuf_t* me, const int size)
bipbuf_request	bipbuffer.h	/^unsigned char *bipbuf_request(bipbuf_t* me, const int size);$/;"	p	signature:(bipbuf_t* me, const int size)
bipbuf_size	bipbuffer.c	/^int bipbuf_size(const bipbuf_t* me)$/;"	f	signature:(const bipbuf_t* me)
bipbuf_size	bipbuffer.h	/^int bipbuf_size(const bipbuf_t* me);$/;"	p	signature:(const bipbuf_t* me)
bipbuf_sizeof	bipbuffer.c	/^static size_t bipbuf_sizeof(const unsigned int size)$/;"	f	file:	signature:(const unsigned int size)
bipbuf_t	bipbuffer.h	/^} bipbuf_t;$/;"	t	typeref:struct:__anon47
bipbuf_unused	bipbuffer.c	/^int bipbuf_unused(const bipbuf_t* me)$/;"	f	signature:(const bipbuf_t* me)
bipbuf_unused	bipbuffer.h	/^int bipbuf_unused(const bipbuf_t* me);$/;"	p	signature:(const bipbuf_t* me)
bipbuf_used	bipbuffer.c	/^int bipbuf_used(const bipbuf_t* me)$/;"	f	signature:(const bipbuf_t* me)
bipbuf_used	bipbuffer.h	/^int bipbuf_used(const bipbuf_t* cb);$/;"	p	signature:(const bipbuf_t* cb)
blocked	logger.h	/^    uint64_t blocked; \/* times blocked instead of dropped *\/$/;"	m	struct:_logger	access:public
body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon17::__anon18	typeref:struct:__anon17::__anon18::__anon19	access:public
body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon20::__anon21	typeref:struct:__anon20::__anon21::__anon22	access:public
body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon23::__anon24	typeref:struct:__anon23::__anon24::__anon25	access:public
body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon26::__anon27	typeref:struct:__anon26::__anon27::__anon28	access:public
body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon29::__anon30	typeref:struct:__anon29::__anon30::__anon31	access:public
body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon32::__anon33	typeref:struct:__anon32::__anon33::__anon34	access:public
body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon35::__anon36	typeref:struct:__anon35::__anon36::__anon37	access:public
body	protocol_binary.h	/^            } body;$/;"	m	struct:__anon38::__anon39	typeref:struct:__anon38::__anon39::__anon40	access:public
bodylen	protocol_binary.h	/^            uint32_t bodylen;$/;"	m	struct:__anon11::__anon12	access:public
bodylen	protocol_binary.h	/^            uint32_t bodylen;$/;"	m	struct:__anon9::__anon10	access:public
bucket	extstore.c	/^    unsigned int bucket; \/* which bucket the page is linked into *\/$/;"	m	struct:_store_page	file:	access:public
bucket	extstore.h	/^    unsigned int bucket;$/;"	m	struct:extstore_page_data	access:public
bucket	logger.h	/^    uint8_t bucket;$/;"	m	struct:logentry_ext_write	access:public
buf	crawler.c	/^    bipbuf_t *buf; \/* output buffer *\/$/;"	m	struct:__anon49	file:	access:public
buf	extstore.c	/^    char *buf;$/;"	m	struct:__store_wbuf	file:	access:public
buf	extstore.h	/^    char *buf;  \/* buffer of data to read or write to *\/$/;"	m	struct:_obj_io	access:public
buf	items.c	/^    bipbuf_t *buf;$/;"	m	struct:_lru_bump_buf	file:	access:public
buf	logger.h	/^    bipbuf_t *buf; \/* per-watcher output buffer *\/$/;"	m	struct:__anon59	access:public
buf	logger.h	/^    bipbuf_t *buf;$/;"	m	struct:_logger	access:public
buf_pos	extstore.c	/^    char *buf_pos;$/;"	m	struct:__store_wbuf	file:	access:public
buffer	memcached.h	/^        char *buffer;$/;"	m	struct:conn::__anon55	access:public
bufsize	cache.h	/^    size_t bufsize;$/;"	m	struct:__anon41	access:public
build	doc/Makefile	/^build = x86_64-pc-linux-gnu$/;"	m
build_alias	doc/Makefile	/^build_alias = $/;"	m
build_command	t/binary-extstore.t	/^sub build_command {$/;"	s
build_command	t/binary-sasl.t	/^sub build_command {$/;"	s
build_command	t/binary.t	/^sub build_command {$/;"	s
build_cpu	doc/Makefile	/^build_cpu = x86_64$/;"	m
build_os	doc/Makefile	/^build_os = linux-gnu$/;"	m
build_triplet	doc/Makefile	/^build_triplet = x86_64-pc-linux-gnu$/;"	m
build_udp_headers	memcached.c	/^static int build_udp_headers(conn *c) {$/;"	f	file:	signature:(conn *c)
build_vendor	doc/Makefile	/^build_vendor = pc$/;"	m
builddir	doc/Makefile	/^builddir = .$/;"	m
bump_buf_head	items.c	/^static lru_bump_buf *bump_buf_head = NULL;$/;"	v	file:
bump_buf_lock	items.c	/^static pthread_mutex_t bump_buf_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
bump_buf_tail	items.c	/^static lru_bump_buf *bump_buf_tail = NULL;$/;"	v	file:
busy_deletes	memcached.h	/^    uint32_t busy_deletes;$/;"	m	struct:slab_rebalance	access:public
busy_items	memcached.h	/^    uint32_t busy_items;$/;"	m	struct:slab_rebalance	access:public
busy_loops	memcached.h	/^    uint32_t busy_loops;$/;"	m	struct:slab_rebalance	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[24];$/;"	m	union:__anon11	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[24];$/;"	m	union:__anon9	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 20];$/;"	m	union:__anon26	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];$/;"	m	union:__anon20	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];$/;"	m	union:__anon32	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];$/;"	m	union:__anon35	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 4];$/;"	m	union:__anon38	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header) + 8];$/;"	m	union:__anon23	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_request_header)];$/;"	m	union:__anon13	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_response_header) + 4];$/;"	m	union:__anon17	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_response_header) + 8];$/;"	m	union:__anon29	access:public
bytes	protocol_binary.h	/^        uint8_t bytes[sizeof(protocol_binary_response_header)];$/;"	m	union:__anon15	access:public
bytes_evicted	extstore.h	/^    uint64_t bytes_evicted;$/;"	m	struct:extstore_stats	access:public
bytes_fragmented	extstore.h	/^    uint64_t bytes_fragmented; \/* see above comment *\/$/;"	m	struct:extstore_stats	access:public
bytes_read	extstore.h	/^    uint64_t bytes_read; \/* wbuf - read -> bytes read from storage *\/$/;"	m	struct:extstore_stats	access:public
bytes_used	extstore.c	/^    uint64_t bytes_used; \/* _delete can decrease post-closing *\/$/;"	m	struct:_store_page	file:	access:public
bytes_used	extstore.h	/^    uint64_t bytes_used; \/* total number of bytes stored *\/$/;"	m	struct:extstore_stats	access:public
bytes_used	extstore.h	/^    uint64_t bytes_used;$/;"	m	struct:extstore_page_data	access:public
bytes_written	extstore.h	/^    uint64_t bytes_written;$/;"	m	struct:extstore_stats	access:public
c	crawler.c	/^    crawler_client_t c;$/;"	m	struct:_crawler_module_t	file:	access:public
c	crawler.c	/^    void *c; \/* original connection structure. still with source thread attached. *\/$/;"	m	struct:__anon49	file:	access:public
c	logger.h	/^    void *c; \/* original connection structure. still with source thread attached *\/$/;"	m	struct:__anon59	access:public
c	memcached.h	/^    conn *c;$/;"	m	struct:_io_wrap	access:public
c	thread.c	/^    conn *c;$/;"	m	struct:conn_queue_item	file:	access:public
cache_alloc	cache.c	/^void* cache_alloc(cache_t *cache) {$/;"	f	signature:(cache_t *cache)
cache_alloc	cache.h	/^void* cache_alloc(cache_t* handle);$/;"	p	signature:(cache_t* handle)
cache_alloc	cache.h	9;"	d
cache_bulkalloc	testapp.c	/^static enum test_return cache_bulkalloc(size_t datasize)$/;"	f	file:	signature:(size_t datasize)
cache_constructor	testapp.c	/^static int cache_constructor(void *buffer, void *notused1, int notused2) {$/;"	f	file:	signature:(void *buffer, void *notused1, int notused2)
cache_constructor_t	cache.h	/^typedef int cache_constructor_t(void* obj, void* notused1, int notused2);$/;"	t
cache_constructor_test	testapp.c	/^static enum test_return cache_constructor_test(void)$/;"	f	file:	signature:(void)
cache_create	cache.c	/^cache_t* cache_create(const char *name, size_t bufsize, size_t align,$/;"	f	signature:(const char *name, size_t bufsize, size_t align, cache_constructor_t* constructor, cache_destructor_t* destructor)
cache_create	cache.h	/^cache_t* cache_create(const char* name, size_t bufsize, size_t align,$/;"	p	signature:(const char* name, size_t bufsize, size_t align, cache_constructor_t* constructor, cache_destructor_t* destructor)
cache_create	cache.h	13;"	d
cache_create_test	testapp.c	/^static enum test_return cache_create_test(void)$/;"	f	file:	signature:(void)
cache_destroy	cache.c	/^void cache_destroy(cache_t *cache) {$/;"	f	signature:(cache_t *cache)
cache_destroy	cache.h	/^void cache_destroy(cache_t* handle);$/;"	p	signature:(cache_t* handle)
cache_destroy	cache.h	14;"	d
cache_destructor	testapp.c	/^static void cache_destructor(void *buffer, void *notused) {$/;"	f	file:	signature:(void *buffer, void *notused)
cache_destructor_t	cache.h	/^typedef void cache_destructor_t(void* obj, void* notused);$/;"	t
cache_destructor_test	testapp.c	/^static enum test_return cache_destructor_test(void)$/;"	f	file:	signature:(void)
cache_error	cache.c	/^int cache_error = 0;$/;"	v
cache_fail_constructor	testapp.c	/^static int cache_fail_constructor(void *buffer, void *notused1, int notused2) {$/;"	f	file:	signature:(void *buffer, void *notused1, int notused2)
cache_fail_constructor_test	testapp.c	/^static enum test_return cache_fail_constructor_test(void)$/;"	f	file:	signature:(void)
cache_free	cache.c	/^void cache_free(cache_t *cache, void *ptr) {$/;"	f	signature:(cache_t *cache, void *ptr)
cache_free	cache.h	/^void cache_free(cache_t* handle, void* ptr);$/;"	p	signature:(cache_t* handle, void* ptr)
cache_free	cache.h	11;"	d
cache_redzone_test	testapp.c	/^static enum test_return cache_redzone_test(void)$/;"	f	file:	signature:(void)
cache_reuse_test	testapp.c	/^static enum test_return cache_reuse_test(void)$/;"	f	file:	signature:(void)
cache_t	cache.h	/^} cache_t;$/;"	t	typeref:struct:__anon41
cache_t	cache.h	8;"	d
call_stats	scripts/damemtop	/^sub call_stats {$/;"	s
cas	memcached.h	/^        uint64_t cas;$/;"	m	union:_stritem::__anon51	access:public
cas	memcached.h	/^    uint64_t cas; \/* the cas to return *\/$/;"	m	struct:conn	access:public
cas	protocol_binary.h	/^            uint64_t cas;$/;"	m	struct:__anon11::__anon12	access:public
cas	protocol_binary.h	/^            uint64_t cas;$/;"	m	struct:__anon9::__anon10	access:public
cas_id_lock	items.c	/^static pthread_mutex_t cas_id_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
caught	timedrun.c	/^static int caught = 0;$/;"	v	file:
caught_signal	timedrun.c	/^static void caught_signal(int which)$/;"	f	file:	signature:(int which)
cb	extstore.h	/^    obj_io_cb cb;$/;"	m	struct:_obj_io	access:public
cbuf	crawler.c	/^    char *cbuf; \/* current buffer *\/$/;"	m	struct:__anon49	file:	access:public
check_cas_stats	t/stats.t	/^sub check_cas_stats {$/;"	s
check_incr_stats	t/stats.t	/^sub check_incr_stats {$/;"	s
checked	memcached.h	/^    uint64_t        checked;    \/* items examined during this crawl. *\/$/;"	m	struct:__anon52	access:public
chunk_rescues	memcached.h	/^    uint32_t chunk_rescues;$/;"	m	struct:slab_rebalance	access:public
chunk_size	memcached.h	/^    int chunk_size;$/;"	m	struct:settings	access:public
chunk_size	slabs.h	/^    unsigned int chunk_size;$/;"	m	struct:__anon42	access:public
chunks_per_page	slabs.h	/^    unsigned int chunks_per_page;$/;"	m	struct:__anon42	access:public
clear_screen	scripts/damemtop	/^sub clear_screen {$/;"	s
clock_handler	memcached.c	/^static void clock_handler(const int fd, const short which, void *arg) {$/;"	f	file:	signature:(const int fd, const short which, void *arg)
clockevent	memcached.c	/^static struct event clockevent;     \/\/ 定义了时钟模块的event$/;"	v	typeref:struct:event	file:
closed	extstore.c	/^    bool closed; \/* closed and draining before free *\/$/;"	m	struct:_store_page	file:	access:public
clsid	logger.h	/^    uint8_t clsid;$/;"	m	struct:logentry_eviction	access:public
clsid	logger.h	/^    uint8_t clsid;$/;"	m	struct:logentry_ext_write	access:public
clsid	logger.h	/^    uint8_t clsid;$/;"	m	struct:logentry_item_get	access:public
clsid	logger.h	/^    uint8_t clsid;$/;"	m	struct:logentry_item_store	access:public
cmd	logger.h	/^    int cmd;$/;"	m	struct:logentry_item_store	access:public
cmd	memcached.h	/^    short cmd; \/* current command being processed *\/$/;"	m	struct:conn	access:public
column_can_total	scripts/damemtop	/^sub column_can_total {$/;"	s
complete_incr_bin	memcached.c	/^static void complete_incr_bin(conn *c) {$/;"	f	file:	signature:(conn *c)
complete_nread	memcached.c	/^static void complete_nread(conn *c) {$/;"	f	file:	signature:(conn *c)
complete_nread	memcached.c	/^static void complete_nread(conn *c);$/;"	p	file:	signature:(conn *c)
complete_nread_ascii	memcached.c	/^static void complete_nread_ascii(conn *c) {$/;"	f	file:	signature:(conn *c)
complete_nread_binary	memcached.c	/^static void complete_nread_binary(conn *c) {$/;"	f	file:	signature:(conn *c)
complete_update_bin	memcached.c	/^static void complete_update_bin(conn *c) {$/;"	f	file:	signature:(conn *c)
compute_column	scripts/damemtop	/^sub compute_column {$/;"	s
compute_fill_rate	scripts/damemtop	/^sub compute_fill_rate {$/;"	s
compute_hit_rate	scripts/damemtop	/^sub compute_hit_rate {$/;"	s
compute_hostname	scripts/damemtop	/^sub compute_hostname {$/;"	s
cond	extstore.c	/^    pthread_cond_t cond;$/;"	m	struct:__anon43	file:	access:public
cond	extstore.c	/^    pthread_cond_t cond;$/;"	m	struct:__anon44	file:	access:public
conn	memcached.h	/^struct conn {$/;"	s
conn	memcached.h	/^typedef struct conn conn;$/;"	t	typeref:struct:conn
conn::__anon55::buffer	memcached.h	/^        char *buffer;$/;"	m	struct:conn::__anon55	access:public
conn::__anon55::offset	memcached.h	/^        size_t offset;$/;"	m	struct:conn::__anon55	access:public
conn::__anon55::size	memcached.h	/^        size_t size;$/;"	m	struct:conn::__anon55	access:public
conn::authenticated	memcached.h	/^    bool authenticated;$/;"	m	struct:conn	access:public
conn::binary_header	memcached.h	/^    protocol_binary_request_header binary_header;$/;"	m	struct:conn	access:public
conn::cas	memcached.h	/^    uint64_t cas; \/* the cas to return *\/$/;"	m	struct:conn	access:public
conn::cmd	memcached.h	/^    short cmd; \/* current command being processed *\/$/;"	m	struct:conn	access:public
conn::ev_flags	memcached.h	/^    short  ev_flags;    \/\/ 该连接session关联的event的标志集合        $/;"	m	struct:conn	access:public
conn::event	memcached.h	/^    struct event event; \/\/ 该连接session关联的event$/;"	m	struct:conn	typeref:struct:conn::event	access:public
conn::hdrbuf	memcached.h	/^    unsigned char *hdrbuf; \/* udp packet headers *\/$/;"	m	struct:conn	access:public
conn::hdrsize	memcached.h	/^    int    hdrsize;   \/* number of headers' worth of space is allocated *\/$/;"	m	struct:conn	access:public
conn::icurr	memcached.h	/^    item   **icurr;$/;"	m	struct:conn	access:public
conn::ileft	memcached.h	/^    int    ileft;$/;"	m	struct:conn	access:public
conn::ilist	memcached.h	/^    item   **ilist;   \/* list of items to write out *\/$/;"	m	struct:conn	access:public
conn::io_queued	memcached.h	/^    bool io_queued; \/* FIXME: debugging flag *\/$/;"	m	struct:conn	access:public
conn::io_wrapleft	memcached.h	/^    int io_wrapleft;$/;"	m	struct:conn	access:public
conn::io_wraplist	memcached.h	/^    io_wrap *io_wraplist; \/* linked list of io_wraps *\/$/;"	m	struct:conn	access:public
conn::iov	memcached.h	/^    struct iovec *iov;$/;"	m	struct:conn	typeref:struct:conn::iovec	access:public
conn::iovsize	memcached.h	/^    int    iovsize;   \/* number of elements allocated in iov[] *\/$/;"	m	struct:conn	access:public
conn::iovused	memcached.h	/^    int    iovused;   \/* number of elements used in iov[] *\/$/;"	m	struct:conn	access:public
conn::isize	memcached.h	/^    int    isize;$/;"	m	struct:conn	access:public
conn::item	memcached.h	/^    void   *item;     \/* for commands set\/add\/replace  *\/$/;"	m	struct:conn	access:public
conn::keylen	memcached.h	/^    int keylen;$/;"	m	struct:conn	access:public
conn::last_cmd_time	memcached.h	/^    rel_time_t last_cmd_time;$/;"	m	struct:conn	access:public
conn::msgbytes	memcached.h	/^    int    msgbytes;  \/* number of bytes in current msg *\/$/;"	m	struct:conn	access:public
conn::msgcurr	memcached.h	/^    int    msgcurr;   \/* element in msglist[] being transmitted now *\/$/;"	m	struct:conn	access:public
conn::msglist	memcached.h	/^    struct msghdr *msglist;$/;"	m	struct:conn	typeref:struct:conn::msghdr	access:public
conn::msgsize	memcached.h	/^    int    msgsize;   \/* number of elements allocated in msglist[] *\/$/;"	m	struct:conn	access:public
conn::msgused	memcached.h	/^    int    msgused;   \/* number of elements used in msglist[] *\/$/;"	m	struct:conn	access:public
conn::next	memcached.h	/^    conn   *next;     \/* Used for generating a list of conn structures *\/$/;"	m	struct:conn	access:public
conn::noreply	memcached.h	/^    bool   noreply;   \/* True if the reply should not be sent. *\/$/;"	m	struct:conn	access:public
conn::opaque	memcached.h	/^    int opaque;$/;"	m	struct:conn	access:public
conn::protocol	memcached.h	/^    enum protocol protocol;   \/* which protocol this connection speaks  该连接session使用的数据格式 *\/$/;"	m	struct:conn	typeref:enum:conn::protocol	access:public
conn::rbuf	memcached.h	/^    char   *rbuf;   \/** buffer to read commands into  指向一片读缓冲区 *\/$/;"	m	struct:conn	access:public
conn::rbytes	memcached.h	/^    int    rbytes;  \/** how much data, starting from rcur, do we have unparsed  读缓冲区中尚未读取的数据长度 *\/$/;"	m	struct:conn	access:public
conn::rcurr	memcached.h	/^    char   *rcurr;  \/** but if we parsed some already, this is where we stopped  读指针 *\/$/;"	m	struct:conn	access:public
conn::recache_counter	memcached.h	/^    unsigned int recache_counter;$/;"	m	struct:conn	access:public
conn::request_addr	memcached.h	/^    struct sockaddr_in6 request_addr; \/* udp: Who sent the most recent request  记录对端地址 *\/$/;"	m	struct:conn	typeref:struct:conn::sockaddr_in6	access:public
conn::request_addr_size	memcached.h	/^    socklen_t request_addr_size;    \/\/ 记录对端地址长度$/;"	m	struct:conn	access:public
conn::request_id	memcached.h	/^    int    request_id; \/* Incoming UDP request ID, if this is a UDP "connection" *\/$/;"	m	struct:conn	access:public
conn::ritem	memcached.h	/^    char   *ritem;  \/** when we read in an item's value, it goes here *\/$/;"	m	struct:conn	access:public
conn::rlbytes	memcached.h	/^    int    rlbytes;$/;"	m	struct:conn	access:public
conn::rsize	memcached.h	/^    int    rsize;   \/** total allocated size of rbuf  读缓冲区长度 *\/$/;"	m	struct:conn	access:public
conn::sasl_conn	memcached.h	/^    sasl_conn_t *sasl_conn;$/;"	m	struct:conn	access:public
conn::sbytes	memcached.h	/^    int    sbytes;    \/* how many bytes to swallow *\/$/;"	m	struct:conn	access:public
conn::sfd	memcached.h	/^    int    sfd;     \/\/ 该连接session关联的fd$/;"	m	struct:conn	access:public
conn::state	memcached.h	/^    enum conn_states  state;    \/\/ 该链接session当前状态$/;"	m	struct:conn	typeref:enum:conn::conn_states	access:public
conn::stats	memcached.h	/^    } stats;$/;"	m	struct:conn	typeref:struct:conn::__anon55	access:public
conn::substate	memcached.h	/^    enum bin_substates substate;$/;"	m	struct:conn	typeref:enum:conn::bin_substates	access:public
conn::suffixcurr	memcached.h	/^    char   **suffixcurr;$/;"	m	struct:conn	access:public
conn::suffixleft	memcached.h	/^    int    suffixleft;$/;"	m	struct:conn	access:public
conn::suffixlist	memcached.h	/^    char   **suffixlist;$/;"	m	struct:conn	access:public
conn::suffixsize	memcached.h	/^    int    suffixsize;$/;"	m	struct:conn	access:public
conn::thread	memcached.h	/^    LIBEVENT_THREAD *thread; \/* Pointer to the thread object serving this connection *\/$/;"	m	struct:conn	access:public
conn::transport	memcached.h	/^    enum network_transport transport; \/* what transport is used by this connection  该连接session使用的协议类型 *\/$/;"	m	struct:conn	typeref:enum:conn::network_transport	access:public
conn::wbuf	memcached.h	/^    char   *wbuf;   \/\/指向一片写缓冲区$/;"	m	struct:conn	access:public
conn::wbytes	memcached.h	/^    int    wbytes;  \/\/ 写缓冲区中已经写入的数据长度?$/;"	m	struct:conn	access:public
conn::wcurr	memcached.h	/^    char   *wcurr;  \/\/ 写指针$/;"	m	struct:conn	access:public
conn::which	memcached.h	/^    short  which;   \/** which events were just triggered *\/$/;"	m	struct:conn	access:public
conn::write_and_free	memcached.h	/^    void   *write_and_free; \/** free this memory after finishing writing *\/$/;"	m	struct:conn	access:public
conn::write_and_go	memcached.h	/^    enum conn_states  write_and_go;$/;"	m	struct:conn	typeref:enum:conn::conn_states	access:public
conn::wsize	memcached.h	/^    int    wsize;   \/\/ 写缓冲区长度$/;"	m	struct:conn	access:public
conn_add_to_freelist	memcached.h	/^bool  conn_add_to_freelist(conn *c);$/;"	p	signature:(conn *c)
conn_cleanup	memcached.c	/^static void conn_cleanup(conn *c) {$/;"	f	file:	signature:(conn *c)
conn_close	memcached.c	/^static void conn_close(conn *c) {$/;"	f	file:	signature:(conn *c)
conn_close	memcached.c	/^static void conn_close(conn *c);$/;"	p	file:	signature:(conn *c)
conn_close_idle	memcached.c	/^void conn_close_idle(conn *c) {$/;"	f	signature:(conn *c)
conn_close_idle	memcached.h	/^void  conn_close_idle(conn *c);$/;"	p	signature:(conn *c)
conn_closed	memcached.h	/^    conn_closed,     \/**< connection is closed *\/$/;"	e	enum:conn_states
conn_closing	memcached.h	/^    conn_closing,    \/**< closing this connection *\/$/;"	e	enum:conn_states
conn_free	memcached.c	/^static void conn_free(conn *c);$/;"	p	file:	signature:(conn *c)
conn_free	memcached.c	/^void conn_free(conn *c) {$/;"	f	signature:(conn *c)
conn_from_freelist	memcached.h	/^conn *conn_from_freelist(void);$/;"	p	signature:(void)
conn_init	memcached.c	/^static void conn_init(void) {$/;"	f	file:	signature:(void)
conn_init	memcached.c	/^static void conn_init(void);$/;"	p	file:	signature:(void)
conn_listening	memcached.h	/^    conn_listening,  \/**< the socket which listens for connections *\/$/;"	e	enum:conn_states
conn_lock	thread.c	/^pthread_mutex_t conn_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
conn_max_state	memcached.h	/^    conn_max_state   \/**< Max state value (used for assertion) *\/$/;"	e	enum:conn_states
conn_mwrite	memcached.h	/^    conn_mwrite,     \/**< writing out many items sequentially *\/$/;"	e	enum:conn_states
conn_new	memcached.c	/^conn *conn_new(const int sfd, enum conn_states init_state,$/;"	f	signature:(const int sfd, enum conn_states init_state, const int event_flags, const int read_buffer_size, enum network_transport transport, struct event_base *base)
conn_new	memcached.h	/^conn *conn_new(const int sfd, const enum conn_states init_state, const int event_flags, const int read_buffer_size, enum network_transport transport, struct event_base *base);$/;"	p	signature:(const int sfd, const enum conn_states init_state, const int event_flags, const int read_buffer_size, enum network_transport transport, struct event_base *base)
conn_new_cmd	memcached.h	/^    conn_new_cmd,    \/**< Prepare connection for next command  收到一个新的连接请求 *\/$/;"	e	enum:conn_states
conn_nread	memcached.h	/^    conn_nread,      \/**< reading in a fixed number of bytes *\/$/;"	e	enum:conn_states
conn_parse_cmd	memcached.h	/^    conn_parse_cmd,  \/**< try to parse a command from the input buffer *\/$/;"	e	enum:conn_states
conn_queue	thread.c	/^struct conn_queue {$/;"	s	file:
conn_queue::head	thread.c	/^    CQ_ITEM *head;$/;"	m	struct:conn_queue	file:	access:public
conn_queue::lock	thread.c	/^    pthread_mutex_t lock;$/;"	m	struct:conn_queue	file:	access:public
conn_queue::tail	thread.c	/^    CQ_ITEM *tail;$/;"	m	struct:conn_queue	file:	access:public
conn_queue_item	thread.c	/^struct conn_queue_item {$/;"	s	file:
conn_queue_item::c	thread.c	/^    conn *c;$/;"	m	struct:conn_queue_item	file:	access:public
conn_queue_item::event_flags	thread.c	/^    int               event_flags;$/;"	m	struct:conn_queue_item	file:	access:public
conn_queue_item::init_state	thread.c	/^    enum conn_states  init_state;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::conn_states	file:	access:public
conn_queue_item::mode	thread.c	/^    enum conn_queue_item_modes mode;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::conn_queue_item_modes	file:	access:public
conn_queue_item::next	thread.c	/^    CQ_ITEM          *next;$/;"	m	struct:conn_queue_item	file:	access:public
conn_queue_item::read_buffer_size	thread.c	/^    int               read_buffer_size;$/;"	m	struct:conn_queue_item	file:	access:public
conn_queue_item::sfd	thread.c	/^    int               sfd;$/;"	m	struct:conn_queue_item	file:	access:public
conn_queue_item::transport	thread.c	/^    enum network_transport     transport;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::network_transport	file:	access:public
conn_queue_item_modes	thread.c	/^enum conn_queue_item_modes {$/;"	g	file:
conn_read	memcached.h	/^    conn_read,       \/**< reading in a command line *\/$/;"	e	enum:conn_states
conn_release_items	memcached.c	/^static void conn_release_items(conn *c) {$/;"	f	file:	signature:(conn *c)
conn_set_state	memcached.c	/^static void conn_set_state(conn *c, enum conn_states state) {$/;"	f	file:	signature:(conn *c, enum conn_states state)
conn_set_state	memcached.c	/^static void conn_set_state(conn *c, enum conn_states state);$/;"	p	file:	signature:(conn *c, enum conn_states state)
conn_shrink	memcached.c	/^static void conn_shrink(conn *c) {$/;"	f	file:	signature:(conn *c)
conn_states	memcached.h	/^enum conn_states {$/;"	g
conn_structs	memcached.h	/^    unsigned int  conn_structs;     \/\/ 记录了已经创建的连接session数量$/;"	m	struct:stats_state	access:public
conn_swallow	memcached.h	/^    conn_swallow,    \/**< swallowing unnecessary bytes w\/o storing *\/$/;"	e	enum:conn_states
conn_timeout_thread	memcached.c	/^static void *conn_timeout_thread(void *arg) {$/;"	f	file:	signature:(void *arg)
conn_timeout_tid	memcached.c	/^static pthread_t conn_timeout_tid;$/;"	v	file:
conn_to_str	memcached.c	/^static void conn_to_str(const conn *c, char *buf) {$/;"	f	file:	signature:(const conn *c, char *buf)
conn_to_str	memcached.c	/^static void conn_to_str(const conn *c, char *buf);$/;"	p	file:	signature:(const conn *c, char *buf)
conn_waiting	memcached.h	/^    conn_waiting,    \/**< waiting for a readable socket *\/$/;"	e	enum:conn_states
conn_watch	memcached.h	/^    conn_watch,      \/**< held by the logger thread as a watcher *\/$/;"	e	enum:conn_states
conn_worker_readd	memcached.c	/^void conn_worker_readd(conn *c) {$/;"	f	signature:(conn *c)
conn_worker_readd	memcached.h	/^void conn_worker_readd(conn *c);$/;"	p	signature:(conn *c)
conn_write	memcached.h	/^    conn_write,      \/**< writing out a simple response *\/$/;"	e	enum:conn_states
connect_memcached	scripts/damemtop	/^sub connect_memcached {$/;"	s
connect_server	testapp.c	/^static int connect_server(const char *hostname, in_port_t port, bool nonblock)$/;"	f	file:	signature:(const char *hostname, in_port_t port, bool nonblock)
conns	memcached.c	/^conn **conns;           \/\/ 定义了一个全局的连接池$/;"	v
construct_udp_message	t/udp.t	/^sub construct_udp_message {$/;"	s
constructor	cache.h	/^    cache_constructor_t* constructor;$/;"	m	struct:__anon41	access:public
constructor_pattern	testapp.c	/^const uint64_t constructor_pattern = 0xdeadcafebabebeef;$/;"	v
contact	scripts/damemtop	/^contact: dormando\\@rydia.net or memcached\\@googlegroups.com.$/;"	l
cq_init	thread.c	/^static void cq_init(CQ *cq) {$/;"	f	file:	signature:(CQ *cq)
cq_pop	thread.c	/^static CQ_ITEM *cq_pop(CQ *cq) {$/;"	f	file:	signature:(CQ *cq)
cq_push	thread.c	/^static void cq_push(CQ *cq, CQ_ITEM *item) {$/;"	f	file:	signature:(CQ *cq, CQ_ITEM *item)
cqi_free	thread.c	/^static void cqi_free(CQ_ITEM *item) {$/;"	f	file:	signature:(CQ_ITEM *item)
cqi_freelist	thread.c	/^static CQ_ITEM *cqi_freelist;$/;"	v	file:
cqi_freelist_lock	thread.c	/^static pthread_mutex_t cqi_freelist_lock;$/;"	v	file:
cqi_new	thread.c	/^static CQ_ITEM *cqi_new(void) {$/;"	f	file:	signature:(void)
crawl_complete	crawler.h	/^    bool crawl_complete;$/;"	m	struct:crawler_expired_data	access:public
crawler	memcached.h	/^} crawler;$/;"	t	typeref:struct:__anon52
crawler_client_t	crawler.c	/^} crawler_client_t;$/;"	t	typeref:struct:__anon49	file:
crawler_count	crawler.c	/^static int crawler_count = 0;$/;"	v	file:
crawler_deinit_func	crawler.c	/^typedef void (*crawler_deinit_func)(crawler_module_t *cm); \/\/ TODO: extra args?$/;"	t	file:
crawler_doneclass_func	crawler.c	/^typedef void (*crawler_doneclass_func)(crawler_module_t *cm, int slab_cls);$/;"	t	file:
crawler_eval_func	crawler.c	/^typedef void (*crawler_eval_func)(crawler_module_t *cm, item *it, uint32_t hv, int slab_cls);$/;"	t	file:
crawler_expired_data	crawler.h	/^struct crawler_expired_data {$/;"	s
crawler_expired_data::crawl_complete	crawler.h	/^    bool crawl_complete;$/;"	m	struct:crawler_expired_data	access:public
crawler_expired_data::crawlerstats	crawler.h	/^    crawlerstats_t crawlerstats[POWER_LARGEST];$/;"	m	struct:crawler_expired_data	access:public
crawler_expired_data::end_time	crawler.h	/^    rel_time_t end_time;$/;"	m	struct:crawler_expired_data	access:public
crawler_expired_data::is_external	crawler.h	/^    bool is_external; \/* whether this was an alloc local or remote to the module. *\/$/;"	m	struct:crawler_expired_data	access:public
crawler_expired_data::lock	crawler.h	/^    pthread_mutex_t lock;$/;"	m	struct:crawler_expired_data	access:public
crawler_expired_data::start_time	crawler.h	/^    rel_time_t start_time;$/;"	m	struct:crawler_expired_data	access:public
crawler_expired_doneclass	crawler.c	/^static void crawler_expired_doneclass(crawler_module_t *cm, int slab_cls) {$/;"	f	file:	signature:(crawler_module_t *cm, int slab_cls)
crawler_expired_doneclass	crawler.c	/^static void crawler_expired_doneclass(crawler_module_t *cm, int slab_cls);$/;"	p	file:	signature:(crawler_module_t *cm, int slab_cls)
crawler_expired_eval	crawler.c	/^static void crawler_expired_eval(crawler_module_t *cm, item *search, uint32_t hv, int i) {$/;"	f	file:	signature:(crawler_module_t *cm, item *search, uint32_t hv, int i)
crawler_expired_eval	crawler.c	/^static void crawler_expired_eval(crawler_module_t *cm, item *search, uint32_t hv, int i);$/;"	p	file:	signature:(crawler_module_t *cm, item *search, uint32_t hv, int i)
crawler_expired_finalize	crawler.c	/^static void crawler_expired_finalize(crawler_module_t *cm) {$/;"	f	file:	signature:(crawler_module_t *cm)
crawler_expired_finalize	crawler.c	/^static void crawler_expired_finalize(crawler_module_t *cm);$/;"	p	file:	signature:(crawler_module_t *cm)
crawler_expired_init	crawler.c	/^static int crawler_expired_init(crawler_module_t *cm, void *data) {$/;"	f	file:	signature:(crawler_module_t *cm, void *data)
crawler_expired_init	crawler.c	/^static int crawler_expired_init(crawler_module_t *cm, void *data);$/;"	p	file:	signature:(crawler_module_t *cm, void *data)
crawler_expired_mod	crawler.c	/^crawler_module_reg_t crawler_expired_mod = {$/;"	v
crawler_finalize_func	crawler.c	/^typedef void (*crawler_finalize_func)(crawler_module_t *cm);$/;"	t	file:
crawler_init_func	crawler.c	/^typedef int (*crawler_init_func)(crawler_module_t *cm, void *data); \/\/ TODO: init args?$/;"	t	file:
crawler_items_checked	items.c	/^    uint64_t crawler_items_checked;$/;"	m	struct:__anon45	file:	access:public
crawler_metadump_eval	crawler.c	/^static void crawler_metadump_eval(crawler_module_t *cm, item *it, uint32_t hv, int i) {$/;"	f	file:	signature:(crawler_module_t *cm, item *it, uint32_t hv, int i)
crawler_metadump_eval	crawler.c	/^static void crawler_metadump_eval(crawler_module_t *cm, item *search, uint32_t hv, int i);$/;"	p	file:	signature:(crawler_module_t *cm, item *search, uint32_t hv, int i)
crawler_metadump_finalize	crawler.c	/^static void crawler_metadump_finalize(crawler_module_t *cm) {$/;"	f	file:	signature:(crawler_module_t *cm)
crawler_metadump_finalize	crawler.c	/^static void crawler_metadump_finalize(crawler_module_t *cm);$/;"	p	file:	signature:(crawler_module_t *cm)
crawler_metadump_mod	crawler.c	/^crawler_module_reg_t crawler_metadump_mod = {$/;"	v
crawler_mod_regs	crawler.c	/^crawler_module_reg_t *crawler_mod_regs[3] = {$/;"	v
crawler_module_reg_t	crawler.c	/^} crawler_module_reg_t;$/;"	t	typeref:struct:__anon50	file:
crawler_module_t	crawler.c	/^typedef struct _crawler_module_t crawler_module_t;$/;"	t	typeref:struct:_crawler_module_t	file:
crawler_reclaimed	items.c	/^    uint64_t crawler_reclaimed;$/;"	m	struct:__anon45	file:	access:public
crawler_result_type	crawler.h	/^enum crawler_result_type {$/;"	g
crawler_run_type	memcached.h	/^enum crawler_run_type {$/;"	g
crawlers	crawler.c	/^static crawler crawlers[LARGEST_ID];$/;"	v	file:
crawlerstats	crawler.h	/^    crawlerstats_t crawlerstats[POWER_LARGEST];$/;"	m	struct:crawler_expired_data	access:public
crawlerstats_t	crawler.h	/^} crawlerstats_t;$/;"	t	typeref:struct:__anon4
crawls_persleep	memcached.h	/^    int crawls_persleep; \/* Number of LRU crawls to run before sleeping *\/$/;"	m	struct:settings	access:public
crc32c	crc32c.h	/^crc_func crc32c;$/;"	v
crc32c_hw	crc32c.c	/^static uint32_t crc32c_hw(uint32_t crc, const void *buf, size_t len)$/;"	f	file:	signature:(uint32_t crc, const void *buf, size_t len)
crc32c_hw_aarch64	crc32c.c	/^static uint32_t crc32c_hw_aarch64(uint32_t crc, const void* buf, size_t len)$/;"	f	file:	signature:(uint32_t crc, const void* buf, size_t len)
crc32c_init	crc32c.c	/^void crc32c_init(void) {$/;"	f	signature:(void)
crc32c_init	crc32c.h	/^void crc32c_init(void);$/;"	p	signature:(void)
crc32c_init_hw	crc32c.c	/^static void crc32c_init_hw(void)$/;"	f	file:	signature:(void)
crc32c_init_sw	crc32c.c	/^static void crc32c_init_sw(void)$/;"	f	file:	signature:(void)
crc32c_long	crc32c.c	/^static uint32_t crc32c_long[4][256];$/;"	v	file:
crc32c_once_hw	crc32c.c	/^static pthread_once_t crc32c_once_hw = PTHREAD_ONCE_INIT;$/;"	v	file:
crc32c_once_sw	crc32c.c	/^static pthread_once_t crc32c_once_sw = PTHREAD_ONCE_INIT;$/;"	v	file:
crc32c_shift	crc32c.c	/^static inline uint32_t crc32c_shift(uint32_t zeros[][256], uint32_t crc)$/;"	f	file:	signature:(uint32_t zeros[][256], uint32_t crc)
crc32c_short	crc32c.c	/^static uint32_t crc32c_short[4][256];$/;"	v	file:
crc32c_sw	crc32c.c	/^static uint32_t crc32c_sw(uint32_t crci, const void *buf, size_t len)$/;"	f	file:	signature:(uint32_t crci, const void *buf, size_t len)
crc32c_table	crc32c.c	/^static uint32_t crc32c_table[8][256];$/;"	v	file:
crc32c_zeros	crc32c.c	/^static void crc32c_zeros(uint32_t zeros[][256], size_t len)$/;"	f	file:	signature:(uint32_t zeros[][256], size_t len)
crc32c_zeros_op	crc32c.c	/^static void crc32c_zeros_op(uint32_t *even, size_t len)$/;"	f	file:	signature:(uint32_t *even, size_t len)
crc_func	crc32c.h	/^typedef uint32_t (*crc_func)(uint32_t crc, const void *buf, size_t len);$/;"	t
create_worker	thread.c	/^static void create_worker(void *(*func)(void *), void *arg) {$/;"	f	file:	signature:(void *(*func)(void *), void *arg)
curr_bytes	memcached.h	/^    uint64_t      curr_bytes;$/;"	m	struct:stats_state	access:public
curr_conns	memcached.h	/^    uint64_t      curr_conns;       \/\/ 记录了$/;"	m	struct:stats_state	access:public
curr_items	memcached.h	/^    uint64_t      curr_items;$/;"	m	struct:stats_state	access:public
current_test	stats.c	/^static char *current_test = "";$/;"	v	file:
current_time	memcached.c	/^volatile rel_time_t current_time;   \/\/ 这个全局变量用来记录当前时间,这是一个相对基准时间monotonic_start的偏移量$/;"	v
d_clsid	memcached.h	/^    int d_clsid;$/;"	m	struct:slab_rebalance	access:public
daemonize	daemon.c	/^int daemonize(int nochdir, int noclose)$/;"	f	signature:(int nochdir, int noclose)
daemonize	memcached.h	/^extern int daemonize(int nochdir, int noclose);$/;"	p	signature:(int nochdir, int noclose)
data	bipbuffer.h	/^    unsigned char data[];$/;"	m	struct:__anon47	access:public
data	crawler.c	/^    void *data; \/* opaque data pointer *\/$/;"	m	struct:_crawler_module_t	file:	access:public
data	extstore.h	/^    void *data; \/* user supplied data pointer *\/$/;"	m	struct:_obj_io	access:public
data	logger.h	/^    } data[];$/;"	m	struct:_logentry	typeref:union:_logentry::__anon58	access:public
data	memcached.h	/^    char data[];$/;"	m	struct:_strchunk	access:public
data	memcached.h	/^    } data[];$/;"	m	struct:_stritem	typeref:union:_stritem::__anon51	access:public
datadir	doc/Makefile	/^datadir = ${datarootdir}$/;"	m
datarootdir	doc/Makefile	/^datarootdir = ${prefix}\/share$/;"	m
datatype	protocol_binary.h	/^            uint8_t datatype;$/;"	m	struct:__anon11::__anon12	access:public
datatype	protocol_binary.h	/^            uint8_t datatype;$/;"	m	struct:__anon9::__anon10	access:public
dd	itoa_ljust.c	71;"	d	file:
decr	t/binary-extstore.t	/^sub decr {$/;"	s
decr	t/binary-sasl.t	/^sub decr {$/;"	s
decr	t/binary.t	/^sub decr {$/;"	s
default_entries	logger.c	/^static const entry_details default_entries[] = {$/;"	v	file:
delete	t/binary-extstore.t	/^sub delete {$/;"	s
delete	t/binary-sasl.t	/^sub delete {$/;"	s
delete	t/binary.t	/^sub delete {$/;"	s
delta	protocol_binary.h	/^                uint64_t delta;$/;"	m	struct:__anon26::__anon27::__anon28	access:public
delta_badval	t/binary-extstore.t	/^sub delta_badval {$/;"	s
delta_badval	t/binary-sasl.t	/^sub delta_badval {$/;"	s
delta_badval	t/binary.t	/^sub delta_badval {$/;"	s
delta_result_type	memcached.h	/^enum delta_result_type {$/;"	g
description	testapp.c	/^    const char *description;$/;"	m	struct:testcase	file:	access:public
destruct_data	testapp.c	/^static void *destruct_data = 0;$/;"	v	file:
destructor	cache.h	/^    cache_destructor_t* destructor;$/;"	m	struct:__anon41	access:public
detail_enabled	memcached.h	/^    int detail_enabled;     \/* nonzero if we're collecting detailed stats *\/$/;"	m	struct:settings	access:public
digits	itoa_ljust.c	/^static inline int digits( uint32_t u, unsigned k, int* d, char** p, int n ) {$/;"	f	file:	signature:( uint32_t u, unsigned k, int* d, char** p, int n )
direct_reclaims	items.c	/^    uint64_t direct_reclaims;$/;"	m	struct:__anon45	file:	access:public
dirty	slab_automove.c	/^    uint64_t dirty;$/;"	m	struct:window_data	file:	access:public
dirty	slab_automove_extstore.c	/^    uint64_t dirty;$/;"	m	struct:window_data	file:	access:public
dispatch_bin_command	memcached.c	/^static void dispatch_bin_command(conn *c) {$/;"	f	file:	signature:(conn *c)
dispatch_conn_new	memcached.h	/^void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags, int read_buffer_size, enum network_transport transport);$/;"	p	signature:(int sfd, enum conn_states init_state, int event_flags, int read_buffer_size, enum network_transport transport)
dispatch_conn_new	thread.c	/^void dispatch_conn_new(int sfd, enum conn_states init_state, int event_flags,$/;"	f	signature:(int sfd, enum conn_states init_state, int event_flags, int read_buffer_size, enum network_transport transport)
display	sizes.c	/^static void display(const char *name, size_t size) {$/;"	f	file:	signature:(const char *name, size_t size)
display_header	scripts/damemtop	/^sub display_header {$/;"	s
display_help_mode	scripts/damemtop	/^sub display_help_mode {$/;"	s
display_lines	scripts/damemtop	/^sub display_lines {$/;"	s
display_run	scripts/damemtop	/^sub display_run {$/;"	s
display_top_mode	scripts/damemtop	/^sub display_top_mode {$/;"	s
do_accept_new_conns	memcached.c	/^void do_accept_new_conns(const bool do_accept) {$/;"	f	signature:(const bool do_accept)
do_accept_new_conns	memcached.h	/^void do_accept_new_conns(const bool do_accept);$/;"	p	signature:(const bool do_accept)
do_add_delta	memcached.c	/^enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,$/;"	f	signature:(conn *c, const char *key, const size_t nkey, const bool incr, const int64_t delta, char *buf, uint64_t *cas, const uint32_t hv)
do_add_delta	memcached.h	/^enum delta_result_type do_add_delta(conn *c, const char *key,$/;"	p	signature:(conn *c, const char *key, const size_t nkey, const bool incr, const int64_t delta, char *buf, uint64_t *cas, const uint32_t hv)
do_assoc_move_next_bucket	assoc.h	/^void do_assoc_move_next_bucket(void);$/;"	p	signature:(void)
do_cache_alloc	cache.c	/^void* do_cache_alloc(cache_t *cache) {$/;"	f	signature:(cache_t *cache)
do_cache_alloc	cache.h	/^void* do_cache_alloc(cache_t* handle);$/;"	p	signature:(cache_t* handle)
do_cache_alloc	cache.h	10;"	d
do_cache_free	cache.c	/^void do_cache_free(cache_t *cache, void *ptr) {$/;"	f	signature:(cache_t *cache, void *ptr)
do_cache_free	cache.h	/^void do_cache_free(cache_t* handle, void* ptr);$/;"	p	signature:(cache_t* handle, void* ptr)
do_cache_free	cache.h	12;"	d
do_get_lru_size	items.c	/^unsigned int do_get_lru_size(uint32_t id) {$/;"	f	signature:(uint32_t id)
do_get_lru_size	items.h	/^unsigned int do_get_lru_size(uint32_t id);$/;"	p	signature:(uint32_t id)
do_item_alloc	items.c	/^item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags,$/;"	f	signature:(char *key, const size_t nkey, const unsigned int flags, const rel_time_t exptime, const int nbytes)
do_item_alloc	items.h	/^item *do_item_alloc(char *key, const size_t nkey, const unsigned int flags, const rel_time_t exptime, const int nbytes);$/;"	p	signature:(char *key, const size_t nkey, const unsigned int flags, const rel_time_t exptime, const int nbytes)
do_item_alloc_chunk	items.c	/^item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain) {$/;"	f	signature:(item_chunk *ch, const size_t bytes_remain)
do_item_alloc_chunk	items.h	/^item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain);$/;"	p	signature:(item_chunk *ch, const size_t bytes_remain)
do_item_alloc_pull	items.c	/^item *do_item_alloc_pull(const size_t ntotal, const unsigned int id) {$/;"	f	signature:(const size_t ntotal, const unsigned int id)
do_item_alloc_pull	items.h	/^item *do_item_alloc_pull(const size_t ntotal, const unsigned int id);$/;"	p	signature:(const size_t ntotal, const unsigned int id)
do_item_crawl_q	items.c	/^item *do_item_crawl_q(item *it) {$/;"	f	signature:(item *it)
do_item_crawl_q	items.h	/^item *do_item_crawl_q(item *it);$/;"	p	signature:(item *it)
do_item_get	items.c	/^item *do_item_get(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update) {$/;"	f	signature:(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update)
do_item_get	items.h	/^item *do_item_get(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update);$/;"	p	signature:(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update)
do_item_link	items.c	/^int do_item_link(item *it, const uint32_t hv) {$/;"	f	signature:(item *it, const uint32_t hv)
do_item_link	items.h	/^int  do_item_link(item *it, const uint32_t hv);     \/** may fail if transgresses limits *\/$/;"	p	signature:(item *it, const uint32_t hv)
do_item_link_q	items.c	/^static void do_item_link_q(item *it) { \/* item is the new head *\/$/;"	f	file:	signature:(item *it)
do_item_linktail_q	items.c	/^void do_item_linktail_q(item *it) { \/* item is the new tail *\/$/;"	f	signature:(item *it)
do_item_linktail_q	items.h	/^void do_item_linktail_q(item *it);$/;"	p	signature:(item *it)
do_item_remove	items.c	/^void do_item_remove(item *it) {$/;"	f	signature:(item *it)
do_item_remove	items.h	/^void do_item_remove(item *it);$/;"	p	signature:(item *it)
do_item_replace	items.c	/^int do_item_replace(item *it, item *new_it, const uint32_t hv) {$/;"	f	signature:(item *it, item *new_it, const uint32_t hv)
do_item_replace	items.h	/^int  do_item_replace(item *it, item *new_it, const uint32_t hv);$/;"	p	signature:(item *it, item *new_it, const uint32_t hv)
do_item_stats_add_crawl	items.c	/^void do_item_stats_add_crawl(const int i, const uint64_t reclaimed,$/;"	f	signature:(const int i, const uint64_t reclaimed, const uint64_t unfetched, const uint64_t checked)
do_item_stats_add_crawl	items.h	/^void do_item_stats_add_crawl(const int i, const uint64_t reclaimed,$/;"	p	signature:(const int i, const uint64_t reclaimed, const uint64_t unfetched, const uint64_t checked)
do_item_touch	items.c	/^item *do_item_touch(const char *key, size_t nkey, uint32_t exptime,$/;"	f	signature:(const char *key, size_t nkey, uint32_t exptime, const uint32_t hv, conn *c)
do_item_touch	items.h	/^item *do_item_touch(const char *key, const size_t nkey, uint32_t exptime, const uint32_t hv, conn *c);$/;"	p	signature:(const char *key, const size_t nkey, uint32_t exptime, const uint32_t hv, conn *c)
do_item_unlink	items.c	/^void do_item_unlink(item *it, const uint32_t hv) {$/;"	f	signature:(item *it, const uint32_t hv)
do_item_unlink	items.h	/^void do_item_unlink(item *it, const uint32_t hv);$/;"	p	signature:(item *it, const uint32_t hv)
do_item_unlink_nolock	items.c	/^void do_item_unlink_nolock(item *it, const uint32_t hv) {$/;"	f	signature:(item *it, const uint32_t hv)
do_item_unlink_nolock	items.h	/^void do_item_unlink_nolock(item *it, const uint32_t hv);$/;"	p	signature:(item *it, const uint32_t hv)
do_item_unlink_q	items.c	/^static void do_item_unlink_q(item *it) {$/;"	f	file:	signature:(item *it)
do_item_unlinktail_q	items.c	/^void do_item_unlinktail_q(item *it) {$/;"	f	signature:(item *it)
do_item_unlinktail_q	items.h	/^void do_item_unlinktail_q(item *it);$/;"	p	signature:(item *it)
do_item_update	items.c	/^void do_item_update(item *it) {$/;"	f	signature:(item *it)
do_item_update	items.h	/^void do_item_update(item *it);   \/** update LRU time to current and reposition *\/$/;"	p	signature:(item *it)
do_item_update_nolock	items.c	/^void do_item_update_nolock(item *it) {$/;"	f	signature:(item *it)
do_item_update_nolock	items.h	/^void do_item_update_nolock(item *it);$/;"	p	signature:(item *it)
do_lru_crawler_start	crawler.c	/^static int do_lru_crawler_start(uint32_t id, uint32_t remaining) {$/;"	f	file:	signature:(uint32_t id, uint32_t remaining)
do_run_logger_thread	logger.c	/^static volatile int do_run_logger_thread = 1;$/;"	v	file:
do_run_lru_crawler_thread	crawler.c	/^static volatile int do_run_lru_crawler_thread = 0;$/;"	v	file:
do_run_lru_maintainer_thread	items.c	/^static volatile int do_run_lru_maintainer_thread = 0;$/;"	v	file:
do_run_maintenance_thread	assoc.c	/^static volatile int do_run_maintenance_thread = 1;$/;"	v	file:
do_run_slab_rebalance_thread	slabs.c	/^static volatile int do_run_slab_rebalance_thread = 1;$/;"	v	file:
do_run_slab_thread	slabs.c	/^static volatile int do_run_slab_thread = 1;$/;"	v	file:
do_slabs_adjust_mem_limit	slabs.c	/^static bool do_slabs_adjust_mem_limit(size_t new_mem_limit) {$/;"	f	file:	signature:(size_t new_mem_limit)
do_slabs_alloc	slabs.c	/^static void *do_slabs_alloc(const size_t size, unsigned int id, uint64_t *total_bytes,$/;"	f	file:	signature:(const size_t size, unsigned int id, uint64_t *total_bytes, unsigned int flags)
do_slabs_free	slabs.c	/^static void do_slabs_free(void *ptr, const size_t size, unsigned int id) {$/;"	f	file:	signature:(void *ptr, const size_t size, unsigned int id)
do_slabs_free	slabs.c	/^static void do_slabs_free(void *ptr, const size_t size, unsigned int id);$/;"	p	file:	signature:(void *ptr, const size_t size, unsigned int id)
do_slabs_free_chunked	slabs.c	/^static void do_slabs_free_chunked(item *it, const size_t size) {$/;"	f	file:	signature:(item *it, const size_t size)
do_slabs_newslab	slabs.c	/^static int do_slabs_newslab(const unsigned int id) {$/;"	f	file:	signature:(const unsigned int id)
do_slabs_newslab	slabs.c	/^static int do_slabs_newslab(const unsigned int id);$/;"	p	file:	signature:(const unsigned int id)
do_slabs_reassign	slabs.c	/^static enum reassign_result_type do_slabs_reassign(int src, int dst) {$/;"	f	file:	signature:(int src, int dst)
do_slabs_stats	slabs.c	/^static void do_slabs_stats(ADD_STAT add_stats, void *c) {$/;"	f	file:	signature:(ADD_STAT add_stats, void *c)
do_store_item	memcached.c	/^enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {$/;"	f	signature:(item *it, int comm, conn *c, const uint32_t hv)
do_store_item	memcached.h	/^enum store_item_type do_store_item(item *item, int comm, conn* c, const uint32_t hv);$/;"	p	signature:(item *item, int comm, conn* c, const uint32_t hv)
docdir	doc/Makefile	/^docdir = ${datarootdir}\/doc\/${PACKAGE_TARNAME}$/;"	m
done	memcached.h	/^    uint8_t done;$/;"	m	struct:slab_rebalance	access:public
done	storage.c	/^    bool done;$/;"	m	struct:storage_compact_wrap	file:	access:public
doneclass	crawler.c	/^    crawler_doneclass_func doneclass; \/* runs once per sub-crawler completion. *\/$/;"	m	struct:__anon50	file:	access:public
drive_machine	memcached.c	/^static void drive_machine(conn *c) {$/;"	f	file:	signature:(conn *c)
drive_machine	memcached.c	/^static void drive_machine(conn *c);$/;"	p	file:	signature:(conn *c)
drop_privileges	linux_priv.c	/^void drop_privileges(void) {$/;"	f	signature:(void)
drop_privileges	memcached.h	/^    bool drop_privileges;   \/* Whether or not to drop unnecessary process privileges  标识是否需要丢弃多余的进程权限 *\/$/;"	m	struct:settings	access:public
drop_privileges	memcached.h	/^extern void drop_privileges(void);$/;"	p	signature:(void)
drop_privileges	memcached.h	763;"	d
drop_privileges	openbsd_priv.c	/^void drop_privileges() {$/;"	f
drop_privileges	solaris_priv.c	/^void drop_privileges(void) {$/;"	f	signature:(void)
drop_worker_privileges	linux_priv.c	/^void drop_worker_privileges(void) {$/;"	f	signature:(void)
drop_worker_privileges	memcached.h	/^extern void drop_worker_privileges(void);$/;"	p	signature:(void)
drop_worker_privileges	memcached.h	769;"	d
dropped	items.c	/^    uint64_t dropped;$/;"	m	struct:_lru_bump_buf	file:	access:public
dropped	logger.h	/^    uint64_t dropped; \/* entries dropped *\/$/;"	m	struct:_logger	access:public
dump_enabled	memcached.h	/^    bool dump_enabled;      \/* whether cachedump\/metadump commands work *\/$/;"	m	struct:settings	access:public
dvidir	doc/Makefile	/^dvidir = ${docdir}$/;"	m
e	extstore.c	/^    store_engine *e;$/;"	m	struct:__anon43	file:	access:public
e	extstore.c	/^    store_engine *e;$/;"	m	struct:__anon44	file:	access:public
eflags	logger.h	/^    uint16_t eflags; \/* flags this logger should log *\/$/;"	m	struct:_logger	access:public
eflags	logger.h	/^    uint16_t eflags; \/* flags we are interested in *\/$/;"	m	struct:__anon59	access:public
eflags	logger.h	/^    uint16_t eflags;$/;"	m	struct:__anon57	access:public
eflags	logger.h	/^    uint16_t eflags;$/;"	m	struct:_logentry	access:public
einval	t/binary-extstore.t	/^sub einval {$/;"	s
einval	t/binary.t	/^sub einval {$/;"	s
enable_large_pages	memcached.c	/^static int enable_large_pages(void) {$/;"	f	file:	signature:(void)
end	logger.h	/^        char end;$/;"	m	union:_logentry::__anon58	access:public
end	memcached.h	/^        char end;$/;"	m	union:_stritem::__anon51	access:public
end_time	crawler.h	/^    rel_time_t end_time;$/;"	m	struct:__anon4	access:public
end_time	crawler.h	/^    rel_time_t end_time;$/;"	m	struct:crawler_expired_data	access:public
ensure_iov_space	memcached.c	/^static int ensure_iov_space(conn *c) {$/;"	f	file:	signature:(conn *c)
ensure_iov_space	memcached.c	/^static int ensure_iov_space(conn *c);$/;"	p	file:	signature:(conn *c)
entry	logger.h	/^        void *entry; \/* probably an item *\/$/;"	m	union:_logentry::__anon58	access:public
entry_details	logger.h	/^} entry_details;$/;"	t	typeref:struct:__anon57
entry_map	logger.h	/^    const entry_details *entry_map;$/;"	m	struct:_logger	access:public
ev_flags	memcached.h	/^    short  ev_flags;    \/\/ 该连接session关联的event的标志集合        $/;"	m	struct:conn	access:public
eval	crawler.c	/^    crawler_eval_func eval; \/* runs on an item. *\/$/;"	m	struct:__anon50	file:	access:public
event	logger.h	/^    enum log_entry_subtype event;$/;"	m	struct:_logentry	typeref:enum:_logentry::log_entry_subtype	access:public
event	memcached.h	/^    struct event event; \/\/ 该连接session关联的event$/;"	m	struct:conn	typeref:struct:conn::event	access:public
event_flags	thread.c	/^    int               event_flags;$/;"	m	struct:conn_queue_item	file:	access:public
event_handler	memcached.c	/^static void event_handler(const int fd, const short which, void *arg);$/;"	p	file:	signature:(const int fd, const short which, void *arg)
event_handler	memcached.c	/^void event_handler(const int fd, const short which, void *arg) {$/;"	f	signature:(const int fd, const short which, void *arg)
event_init	configure	/^ event_init();$/;"	f
evict_to_free	memcached.h	/^    int evict_to_free;$/;"	m	struct:settings	access:public
evicted	items.c	/^    uint64_t evicted;$/;"	m	struct:__anon45	file:	access:public
evicted	items.h	/^    int64_t evicted;$/;"	m	struct:__anon3	access:public
evicted	slab_automove.c	/^    uint64_t evicted;$/;"	m	struct:window_data	file:	access:public
evicted	slab_automove_extstore.c	/^    uint64_t evicted;$/;"	m	struct:window_data	file:	access:public
evicted_active	items.c	/^    uint64_t evicted_active; \/* items evicted that should have been shuffled *\/$/;"	m	struct:__anon45	file:	access:public
evicted_nonzero	items.c	/^    uint64_t evicted_nonzero;$/;"	m	struct:__anon45	file:	access:public
evicted_time	items.c	/^    rel_time_t evicted_time;$/;"	m	struct:__anon45	file:	access:public
evicted_unfetched	items.c	/^    uint64_t evicted_unfetched; \/* items evicted but never touched *\/$/;"	m	struct:__anon45	file:	access:public
evictions_nomem	memcached.h	/^    uint32_t evictions_nomem;$/;"	m	struct:slab_rebalance	access:public
excess_free	slab_automove_extstore.c	/^    unsigned int excess_free;$/;"	m	struct:window_data	file:	access:public
exec_prefix	doc/Makefile	/^exec_prefix = ${prefix}$/;"	m
exists	t/binary-extstore.t	/^sub exists {$/;"	s
exists	t/binary-sasl.t	/^sub exists {$/;"	s
exists	t/binary.t	/^sub exists {$/;"	s
expand_bucket	assoc.c	/^static unsigned int expand_bucket = 0;$/;"	v	file:
expanding	assoc.c	/^static bool expanding = false;$/;"	v	file:
expiration	protocol_binary.h	/^                uint32_t expiration;$/;"	m	struct:__anon20::__anon21::__anon22	access:public
expiration	protocol_binary.h	/^                uint32_t expiration;$/;"	m	struct:__anon23::__anon24::__anon25	access:public
expiration	protocol_binary.h	/^                uint32_t expiration;$/;"	m	struct:__anon26::__anon27::__anon28	access:public
expiration	protocol_binary.h	/^                uint32_t expiration;$/;"	m	struct:__anon32::__anon33::__anon34	access:public
expiration	protocol_binary.h	/^                uint32_t expiration;$/;"	m	struct:__anon35::__anon36::__anon37	access:public
expired_unfetched	items.c	/^    uint64_t expired_unfetched; \/* items reclaimed but never touched *\/$/;"	m	struct:__anon45	file:	access:public
exptime	logger.h	/^    long long int exptime;$/;"	m	struct:logentry_eviction	access:public
exptime	logger.h	/^    long long int exptime;$/;"	m	struct:logentry_ext_write	access:public
exptime	memcached.h	/^    rel_time_t      exptime;    \/* expire time *\/$/;"	m	struct:__anon52	access:public
exptime	memcached.h	/^    rel_time_t      exptime;    \/* expire time *\/$/;"	m	struct:_stritem	access:public
ext_command	testapp.c	/^static off_t ext_command(char* buf,$/;"	f	file:	signature:(char* buf, size_t bufsz, uint8_t cmd, const void* ext, size_t extlen, const void* key, size_t keylen, const void* dta, size_t dtalen)
ext_compact_under	memcached.h	/^    unsigned int ext_compact_under; \/* when fewer than this many pages, compact *\/$/;"	m	struct:settings	access:public
ext_drop_under	memcached.h	/^    unsigned int ext_drop_under; \/* when fewer than this many pages, drop COLD items *\/$/;"	m	struct:settings	access:public
ext_drop_unread	memcached.h	/^    bool ext_drop_unread; \/* skip unread items during compaction *\/$/;"	m	struct:settings	access:public
ext_free_memchunks	memcached.h	/^    unsigned int ext_free_memchunks[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:settings	access:public
ext_item_age	memcached.h	/^    unsigned int ext_item_age; \/* max age of tail item before storing ext. *\/$/;"	m	struct:settings	access:public
ext_item_size	memcached.h	/^    unsigned int ext_item_size; \/* minimum size of items to store externally *\/$/;"	m	struct:settings	access:public
ext_low_ttl	memcached.h	/^    unsigned int ext_low_ttl; \/* remaining TTL below this uses own pages *\/$/;"	m	struct:settings	access:public
ext_max_frag	memcached.h	/^    double ext_max_frag; \/* ideal maximum page fragmentation *\/$/;"	m	struct:settings	access:public
ext_recache_rate	memcached.h	/^    unsigned int ext_recache_rate; \/* counter++ % recache_rate == 0 > recache *\/$/;"	m	struct:settings	access:public
ext_storage	memcached.c	/^void *ext_storage;$/;"	v
ext_wbuf_size	memcached.h	/^    unsigned int ext_wbuf_size; \/* read only note for the engine *\/$/;"	m	struct:settings	access:public
extlen	protocol_binary.h	/^            uint8_t extlen;$/;"	m	struct:__anon11::__anon12	access:public
extlen	protocol_binary.h	/^            uint8_t extlen;$/;"	m	struct:__anon9::__anon10	access:public
extstore_check	extstore.c	/^int extstore_check(void *ptr, unsigned int page_id, uint64_t page_version) {$/;"	f	signature:(void *ptr, unsigned int page_id, uint64_t page_version)
extstore_check	extstore.h	/^int extstore_check(void *ptr, unsigned int page_id, uint64_t page_version);$/;"	p	signature:(void *ptr, unsigned int page_id, uint64_t page_version)
extstore_close_page	extstore.c	/^void extstore_close_page(void *ptr, unsigned int page_id, uint64_t page_version) {$/;"	f	signature:(void *ptr, unsigned int page_id, uint64_t page_version)
extstore_close_page	extstore.h	/^void extstore_close_page(void *ptr, unsigned int page_id, uint64_t page_version);$/;"	p	signature:(void *ptr, unsigned int page_id, uint64_t page_version)
extstore_compact_lost	memcached.h	/^    uint64_t      extstore_compact_lost; \/* items lost because they were locked *\/$/;"	m	struct:stats	access:public
extstore_compact_rescues	memcached.h	/^    uint64_t      extstore_compact_rescues; \/* items re-written during compaction *\/$/;"	m	struct:stats	access:public
extstore_compact_skipped	memcached.h	/^    uint64_t      extstore_compact_skipped; \/* unhit items skipped during compaction *\/$/;"	m	struct:stats	access:public
extstore_conf	extstore.h	/^struct extstore_conf {$/;"	s
extstore_conf::io_depth	extstore.h	/^    unsigned int io_depth; \/\/ with normal I\/O, hits locks less. req'd for AIO$/;"	m	struct:extstore_conf	access:public
extstore_conf::io_threadcount	extstore.h	/^    unsigned int io_threadcount;$/;"	m	struct:extstore_conf	access:public
extstore_conf::page_buckets	extstore.h	/^    unsigned int page_buckets; \/\/ number of different writeable pages$/;"	m	struct:extstore_conf	access:public
extstore_conf::page_count	extstore.h	/^    unsigned int page_count;$/;"	m	struct:extstore_conf	access:public
extstore_conf::page_size	extstore.h	/^    unsigned int page_size; \/\/ ideally 64-256M in size$/;"	m	struct:extstore_conf	access:public
extstore_conf::wbuf_count	extstore.h	/^    unsigned int wbuf_count; \/\/ this might get locked to "2 per active page"$/;"	m	struct:extstore_conf	access:public
extstore_conf::wbuf_size	extstore.h	/^    unsigned int wbuf_size; \/\/ must divide cleanly into page_size$/;"	m	struct:extstore_conf	access:public
extstore_delete	extstore.c	/^int extstore_delete(void *ptr, unsigned int page_id, uint64_t page_version,$/;"	f	signature:(void *ptr, unsigned int page_id, uint64_t page_version, unsigned int count, unsigned int bytes)
extstore_delete	extstore.h	/^int extstore_delete(void *ptr, unsigned int page_id, uint64_t page_version, unsigned int count, unsigned int bytes);$/;"	p	signature:(void *ptr, unsigned int page_id, uint64_t page_version, unsigned int count, unsigned int bytes)
extstore_err	extstore.c	/^const char *extstore_err(enum extstore_res res) {$/;"	f	signature:(enum extstore_res res)
extstore_err	extstore.h	/^const char *extstore_err(enum extstore_res res);$/;"	p	signature:(enum extstore_res res)
extstore_get_page_data	extstore.c	/^void extstore_get_page_data(void *ptr, struct extstore_stats *st) {$/;"	f	signature:(void *ptr, struct extstore_stats *st)
extstore_get_page_data	extstore.h	/^void extstore_get_page_data(void *ptr, struct extstore_stats *st);$/;"	p	signature:(void *ptr, struct extstore_stats *st)
extstore_get_stats	extstore.c	/^void extstore_get_stats(void *ptr, struct extstore_stats *st) {$/;"	f	signature:(void *ptr, struct extstore_stats *st)
extstore_get_stats	extstore.h	/^void extstore_get_stats(void *ptr, struct extstore_stats *st);$/;"	p	signature:(void *ptr, struct extstore_stats *st)
extstore_init	extstore.c	/^void *extstore_init(char *fn, struct extstore_conf *cf,$/;"	f	signature:(char *fn, struct extstore_conf *cf, enum extstore_res *res)
extstore_init	extstore.h	/^void *extstore_init(char *fn, struct extstore_conf *cf, enum extstore_res *res);$/;"	p	signature:(char *fn, struct extstore_conf *cf, enum extstore_res *res)
extstore_io_thread	extstore.c	/^static void *extstore_io_thread(void *arg) {$/;"	f	file:	signature:(void *arg)
extstore_io_thread	extstore.c	/^static void *extstore_io_thread(void *arg);$/;"	p	file:	signature:(void *arg)
extstore_maint_thread	extstore.c	/^static void *extstore_maint_thread(void *arg) {$/;"	f	file:	signature:(void *arg)
extstore_maint_thread	extstore.c	/^static void *extstore_maint_thread(void *arg);$/;"	p	file:	signature:(void *arg)
extstore_page_data	extstore.h	/^struct extstore_page_data {$/;"	s
extstore_page_data::bucket	extstore.h	/^    unsigned int bucket;$/;"	m	struct:extstore_page_data	access:public
extstore_page_data::bytes_used	extstore.h	/^    uint64_t bytes_used;$/;"	m	struct:extstore_page_data	access:public
extstore_page_data::version	extstore.h	/^    uint64_t version;$/;"	m	struct:extstore_page_data	access:public
extstore_res	extstore.h	/^enum extstore_res {$/;"	g
extstore_run_maint	extstore.c	/^void extstore_run_maint(void *ptr) {$/;"	f	signature:(void *ptr)
extstore_run_maint	extstore.h	/^void extstore_run_maint(void *ptr);$/;"	p	signature:(void *ptr)
extstore_stats	extstore.h	/^struct extstore_stats {$/;"	s
extstore_stats::bytes_evicted	extstore.h	/^    uint64_t bytes_evicted;$/;"	m	struct:extstore_stats	access:public
extstore_stats::bytes_fragmented	extstore.h	/^    uint64_t bytes_fragmented; \/* see above comment *\/$/;"	m	struct:extstore_stats	access:public
extstore_stats::bytes_read	extstore.h	/^    uint64_t bytes_read; \/* wbuf - read -> bytes read from storage *\/$/;"	m	struct:extstore_stats	access:public
extstore_stats::bytes_used	extstore.h	/^    uint64_t bytes_used; \/* total number of bytes stored *\/$/;"	m	struct:extstore_stats	access:public
extstore_stats::bytes_written	extstore.h	/^    uint64_t bytes_written;$/;"	m	struct:extstore_stats	access:public
extstore_stats::objects_evicted	extstore.h	/^    uint64_t objects_evicted;$/;"	m	struct:extstore_stats	access:public
extstore_stats::objects_read	extstore.h	/^    uint64_t objects_read;$/;"	m	struct:extstore_stats	access:public
extstore_stats::objects_used	extstore.h	/^    uint64_t objects_used; \/* total number of objects stored *\/$/;"	m	struct:extstore_stats	access:public
extstore_stats::objects_written	extstore.h	/^    uint64_t objects_written;$/;"	m	struct:extstore_stats	access:public
extstore_stats::page_allocs	extstore.h	/^    uint64_t page_allocs;$/;"	m	struct:extstore_stats	access:public
extstore_stats::page_count	extstore.h	/^    uint64_t page_count; \/* total page count *\/$/;"	m	struct:extstore_stats	access:public
extstore_stats::page_data	extstore.h	/^    struct extstore_page_data *page_data;$/;"	m	struct:extstore_stats	typeref:struct:extstore_stats::extstore_page_data	access:public
extstore_stats::page_evictions	extstore.h	/^    uint64_t page_evictions;$/;"	m	struct:extstore_stats	access:public
extstore_stats::page_reclaims	extstore.h	/^    uint64_t page_reclaims;$/;"	m	struct:extstore_stats	access:public
extstore_stats::page_size	extstore.h	/^    uint64_t page_size; \/* size in bytes per page (supplied by caller) *\/$/;"	m	struct:extstore_stats	access:public
extstore_stats::pages_free	extstore.h	/^    uint64_t pages_free; \/* currently unallocated\/unused pages *\/$/;"	m	struct:extstore_stats	access:public
extstore_stats::pages_used	extstore.h	/^    uint64_t pages_used;$/;"	m	struct:extstore_stats	access:public
extstore_submit	extstore.c	/^int extstore_submit(void *ptr, obj_io *io) {$/;"	f	signature:(void *ptr, obj_io *io)
extstore_submit	extstore.h	/^int extstore_submit(void *ptr, obj_io *io);$/;"	p	signature:(void *ptr, obj_io *io)
extstore_write	extstore.c	/^void extstore_write(void *ptr, obj_io *io) {$/;"	f	signature:(void *ptr, obj_io *io)
extstore_write	extstore.h	/^void extstore_write(void *ptr, obj_io *io);$/;"	p	signature:(void *ptr, obj_io *io)
extstore_write_request	extstore.c	/^int extstore_write_request(void *ptr, unsigned int bucket, obj_io *io) {$/;"	f	signature:(void *ptr, unsigned int bucket, obj_io *io)
extstore_write_request	extstore.h	/^int extstore_write_request(void *ptr, unsigned int bucket, obj_io *io);$/;"	p	signature:(void *ptr, unsigned int bucket, obj_io *io)
factor	memcached.h	/^    double factor;          \/* chunk size growth factor *\/$/;"	m	struct:settings	access:public
fail	stats.c	/^static void fail(char *what) { printf("\\tFAIL: %s\\n", what); fflush(stdout); fail_count++; }$/;"	f	file:	signature:(char *what)
fail_count	stats.c	/^static int fail_count = 0;$/;"	v	file:
failed_flush	logger.h	/^    bool failed_flush; \/* recently failed to write out (EAGAIN), wait before retry *\/$/;"	m	struct:__anon59	access:public
fd	extstore.c	/^    int fd;$/;"	m	struct:_store_page	file:	access:public
fetcher_ratio	logger.h	/^    uint16_t fetcher_ratio; \/* log one out of every N fetches *\/$/;"	m	struct:_logger	access:public
fill_item_stats_automove	items.c	/^void fill_item_stats_automove(item_stats_automove *am) {$/;"	f	signature:(item_stats_automove *am)
fill_item_stats_automove	items.h	/^void fill_item_stats_automove(item_stats_automove *am);$/;"	p	signature:(item_stats_automove *am)
fill_slab_stats_automove	slabs.c	/^void fill_slab_stats_automove(slab_stats_automove *am) {$/;"	f	signature:(slab_stats_automove *am)
fill_slab_stats_automove	slabs.h	/^void fill_slab_stats_automove(slab_stats_automove *am);$/;"	p	signature:(slab_stats_automove *am)
final	jenkins_hash.c	114;"	d	file:
finalize	crawler.c	/^    crawler_finalize_func finalize; \/* runs once when all sub-crawlers are done. *\/$/;"	m	struct:__anon50	file:	access:public
find_optimal_spacing	scripts/damemtop	/^sub find_optimal_spacing {$/;"	s
fire_main_loop	scripts/damemtop	/^sub fire_main_loop {$/;"	s
flags	protocol_binary.h	/^                uint32_t flags;$/;"	m	struct:__anon17::__anon18::__anon19	access:public
flags	protocol_binary.h	/^                uint32_t flags;$/;"	m	struct:__anon23::__anon24::__anon25	access:public
flags	protocol_binary.h	/^                uint8_t  flags;$/;"	m	struct:__anon38::__anon39::__anon40	access:public
flush	t/binary-extstore.t	/^sub flush {$/;"	s
flush	t/binary-sasl.t	/^sub flush {$/;"	s
flush	t/binary.t	/^sub flush {$/;"	s
flush_command	testapp.c	/^static off_t flush_command(char* buf, size_t bufsz, uint8_t cmd, uint32_t exptime, bool use_extra) {$/;"	f	file:	signature:(char* buf, size_t bufsz, uint8_t cmd, uint32_t exptime, bool use_extra)
flush_enabled	memcached.h	/^    bool flush_enabled;     \/* flush_all enabled *\/$/;"	m	struct:settings	access:public
flush_socket	t/binary-extstore.t	/^sub flush_socket {$/;"	s
flush_socket	t/binary-sasl.t	/^sub flush_socket {$/;"	s
flush_socket	t/binary.t	/^sub flush_socket {$/;"	s
flushed	extstore.c	/^    bool flushed; \/* whether wbuf has been flushed to disk *\/$/;"	m	struct:__store_wbuf	file:	access:public
fmix32	murmur3_hash.c	/^static FORCE_INLINE uint32_t fmix32 ( uint32_t h )$/;"	f	file:	signature:( uint32_t h )
format	logger.h	/^    char *format;$/;"	m	struct:__anon57	access:public
format_column	scripts/damemtop	/^sub format_column {$/;"	s
format_commas	scripts/damemtop	/^sub format_commas {$/;"	s
format_percent	scripts/damemtop	/^sub format_percent {$/;"	s
free	extstore.c	/^    bool free; \/* on freelist *\/$/;"	m	struct:_store_page	file:	access:public
free	extstore.c	/^    unsigned int free;$/;"	m	struct:__store_wbuf	file:	access:public
free	slab_automove.h	/^    slab_automove_free_func free;$/;"	m	struct:__anon2	access:public
free_chunks	slabs.h	/^    long int free_chunks;$/;"	m	struct:__anon42	access:public
free_mem	slab_automove_extstore.c	/^    unsigned int free_mem[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon56	file:	access:public
free_port	t/lib/MemcachedTest.pm	/^sub free_port {$/;"	s
free_ratio	slab_automove_extstore.c	/^    double free_ratio;$/;"	m	struct:__anon56	file:	access:public
freecurr	cache.h	/^    int freecurr;$/;"	m	struct:__anon41	access:public
freetotal	cache.h	/^    int freetotal;$/;"	m	struct:__anon41	access:public
full	extstore.c	/^    bool full; \/* done writing to this page *\/$/;"	m	struct:__store_wbuf	file:	access:public
func_cl_dashL	compile	/^func_cl_dashL ()$/;"	f
func_cl_dashl	compile	/^func_cl_dashl ()$/;"	f
func_cl_wrapper	compile	/^func_cl_wrapper ()$/;"	f
func_file_conv	compile	/^func_file_conv ()$/;"	f
function	testapp.c	/^    TEST_FUNC function;$/;"	m	struct:testcase	file:	access:public
gat	t/binary-extstore.t	/^sub gat {$/;"	s
gat	t/binary.t	/^sub gat {$/;"	s
get	t/binary-extstore.t	/^sub get {$/;"	s
get	t/binary-sasl.t	/^sub get {$/;"	s
get	t/binary.t	/^sub get {$/;"	s
get_cas_id	items.c	/^uint64_t get_cas_id(void) {$/;"	f	signature:(void)
get_cas_id	items.h	/^uint64_t get_cas_id(void);$/;"	p	signature:(void)
get_multi	t/binary-extstore.t	/^sub get_multi {$/;"	s
get_multi	t/binary-sasl.t	/^sub get_multi {$/;"	s
get_multi	t/binary.t	/^sub get_multi {$/;"	s
get_object	cache.c	/^static inline void* get_object(void *ptr) {$/;"	f	file:	signature:(void *ptr)
get_page_from_global_pool	slabs.c	/^static void *get_page_from_global_pool(void) {$/;"	f	file:	signature:(void)
get_stats	slabs.c	/^bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c) {$/;"	f	signature:(const char *stat_type, int nkey, ADD_STAT add_stats, void *c)
get_stats	slabs.h	/^bool get_stats(const char *stat_type, int nkey, ADD_STAT add_stats, void *c);$/;"	p	signature:(const char *stat_type, int nkey, ADD_STAT add_stats, void *c)
get_window_data	slab_automove_extstore.c	/^static struct window_data *get_window_data(slab_automove *a, int class) {$/;"	f	file:	signature:(slab_automove *a, int class)
getblock32	murmur3_hash.c	/^static FORCE_INLINE uint32_t getblock32 ( const uint32_t * p, int i )$/;"	f	file:	signature:( const uint32_t * p, int i )
gf2_matrix_square	crc32c.c	/^static inline void gf2_matrix_square(uint32_t *square, uint32_t *mat)$/;"	f	file:	signature:(uint32_t *square, uint32_t *mat)
gf2_matrix_times	crc32c.c	/^static inline uint32_t gf2_matrix_times(uint32_t *mat, uint32_t vec)$/;"	f	file:	signature:(uint32_t *mat, uint32_t vec)
gid	logger.h	/^    uint64_t gid;$/;"	m	struct:_logentry	access:public
give_advice	missing	/^give_advice ()$/;"	f
global_page_pool_size	slabs.c	/^unsigned int global_page_pool_size(bool *mem_flag) {$/;"	f	signature:(bool *mem_flag)
global_page_pool_size	slabs.h	/^unsigned int global_page_pool_size(bool *mem_flag);$/;"	p	signature:(bool *mem_flag)
global_pool_check	slab_automove_extstore.c	/^static void global_pool_check(slab_automove *a) {$/;"	f	file:	signature:(slab_automove *a)
grow_slab_list	slabs.c	/^static int grow_slab_list (const unsigned int id) {$/;"	f	file:	signature:(const unsigned int id)
grow_slab_list	slabs.c	/^static int grow_slab_list (const unsigned int id);$/;"	p	file:	signature:(const unsigned int id)
grow_stats_buf	memcached.c	/^static bool grow_stats_buf(conn *c, size_t needed) {$/;"	f	file:	signature:(conn *c, size_t needed)
h_next	memcached.h	/^    struct _stritem *h_next;    \/* hash chain next *\/$/;"	m	struct:__anon52	typeref:struct:__anon52::_stritem	access:public
h_next	memcached.h	/^    struct _stritem *h_next;    \/* hash chain next *\/$/;"	m	struct:_stritem	typeref:struct:_stritem::_stritem	access:public
handle_binary_protocol_error	memcached.c	/^static void handle_binary_protocol_error(conn *c) {$/;"	f	file:	signature:(conn *c)
handle_logfile	scripts/start-memcached	/^sub handle_logfile$/;"	s
hash	hash.h	/^hash_func hash;$/;"	v
hash_algorithm	memcached.h	/^    char *hash_algorithm;     \/* Hash algorithm in use 记录了程序使用的hash算法名 *\/$/;"	m	struct:settings	access:public
hash_bulk_move	assoc.c	/^int hash_bulk_move = DEFAULT_HASH_BULK_MOVE;$/;"	v
hash_bytes	memcached.h	/^    uint64_t      hash_bytes;       \/* size used for hash tables *\/$/;"	m	struct:stats_state	access:public
hash_func	hash.h	/^typedef uint32_t (*hash_func)(const void *key, size_t length);$/;"	t
hash_init	hash.c	/^int hash_init(enum hashfunc_type type) {$/;"	f	signature:(enum hashfunc_type type)
hash_init	hash.h	/^int hash_init(enum hashfunc_type type);$/;"	p	signature:(enum hashfunc_type type)
hash_is_expanding	memcached.h	/^    bool          hash_is_expanding; \/* If the hash table is being expanded *\/$/;"	m	struct:stats_state	access:public
hash_power_level	memcached.h	/^    unsigned int  hash_power_level; \/* Better hope it's not over 9000 *\/$/;"	m	struct:stats_state	access:public
hashfunc_type	hash.h	/^enum hashfunc_type {$/;"	g
hashmask	assoc.c	38;"	d	file:
hashmask	thread.c	76;"	d	file:
hashpower	assoc.c	/^unsigned int hashpower = HASHPOWER_DEFAULT;$/;"	v
hashpower_init	memcached.h	/^    int hashpower_init;     \/* Starting hash power level *\/$/;"	m	struct:settings	access:public
hashsize	assoc.c	37;"	d	file:
hashsize	thread.c	75;"	d	file:
hdr_it	memcached.h	/^    item *hdr_it;             \/* original header item. *\/$/;"	m	struct:_io_wrap	access:public
hdrbuf	memcached.h	/^    unsigned char *hdrbuf; \/* udp packet headers *\/$/;"	m	struct:conn	access:public
hdrsize	memcached.h	/^    int    hdrsize;   \/* number of headers' worth of space is allocated *\/$/;"	m	struct:conn	access:public
head	memcached.h	/^    struct _stritem  *head;     \/* always points to the owner chunk *\/$/;"	m	struct:_strchunk	typeref:struct:_strchunk::_stritem	access:public
head	thread.c	/^    CQ_ITEM *head;$/;"	m	struct:conn_queue	file:	access:public
header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon13::__anon14	access:public
header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon20::__anon21	access:public
header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon23::__anon24	access:public
header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon26::__anon27	access:public
header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon32::__anon33	access:public
header	protocol_binary.h	/^            protocol_binary_request_header header;$/;"	m	struct:__anon35::__anon36	access:public
header	protocol_binary.h	/^            protocol_binary_response_header header;$/;"	m	struct:__anon15::__anon16	access:public
header	protocol_binary.h	/^            protocol_binary_response_header header;$/;"	m	struct:__anon17::__anon18	access:public
header	protocol_binary.h	/^            protocol_binary_response_header header;$/;"	m	struct:__anon29::__anon30	access:public
header	protocol_binary.h	/^            protocol_binary_response_header header;$/;"	m	struct:__anon38::__anon39	access:public
heads	items.c	/^static item *heads[LARGEST_ID];$/;"	v	file:
hexify	t/udp.t	/^sub hexify {$/;"	s
hickup_thread_running	testapp.c	/^volatile bool hickup_thread_running;$/;"	v
histo	crawler.h	/^    uint64_t histo[61];$/;"	m	struct:__anon4	access:public
hits_to_cold	items.c	/^    uint64_t hits_to_cold;$/;"	m	struct:__anon45	file:	access:public
hits_to_hot	items.c	/^    uint64_t hits_to_hot;$/;"	m	struct:__anon45	file:	access:public
hits_to_temp	items.c	/^    uint64_t hits_to_temp;$/;"	m	struct:__anon45	file:	access:public
hits_to_warm	items.c	/^    uint64_t hits_to_warm;$/;"	m	struct:__anon45	file:	access:public
host	doc/Makefile	/^host = x86_64-pc-linux-gnu$/;"	m
host	t/lib/MemcachedTest.pm	/^sub host { $_[0]{host} }$/;"	s
host_alias	doc/Makefile	/^host_alias = $/;"	m
host_cpu	doc/Makefile	/^host_cpu = x86_64$/;"	m
host_os	doc/Makefile	/^host_os = linux-gnu$/;"	m
host_triplet	doc/Makefile	/^host_triplet = x86_64-pc-linux-gnu$/;"	m
host_vendor	doc/Makefile	/^host_vendor = pc$/;"	m
hot_lru_pct	memcached.h	/^    int hot_lru_pct; \/* percentage of slab space for HOT_LRU *\/$/;"	m	struct:settings	access:public
hot_max_factor	memcached.h	/^    double hot_max_factor; \/* HOT tail age relative to COLD tail *\/$/;"	m	struct:settings	access:public
htmldir	doc/Makefile	/^htmldir = ${docdir}$/;"	m
htonll	util.c	/^uint64_t htonll(uint64_t val) {$/;"	f	signature:(uint64_t val)
htonll	util.h	/^extern uint64_t htonll(uint64_t);$/;"	p	signature:(uint64_t)
hv	items.c	/^    uint32_t hv;$/;"	m	struct:__anon46	file:	access:public
hv	items.h	/^    uint32_t hv;$/;"	m	struct:lru_pull_tail_return	access:public
iam_after	slab_automove.c	/^    item_stats_automove iam_after[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon48	file:	access:public
iam_after	slab_automove_extstore.c	/^    item_stats_automove iam_after[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon56	file:	access:public
iam_before	slab_automove.c	/^    item_stats_automove iam_before[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon48	file:	access:public
iam_before	slab_automove_extstore.c	/^    item_stats_automove iam_before[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon56	file:	access:public
icurr	memcached.h	/^    item   **icurr;$/;"	m	struct:conn	access:public
id	extstore.c	/^    unsigned short id;$/;"	m	struct:_store_page	file:	access:public
id	logger.h	/^    int id; \/* id number for watcher list *\/$/;"	m	struct:__anon59	access:public
idle_timeout	memcached.h	/^    int idle_timeout;       \/* Number of seconds to let connections idle *\/$/;"	m	struct:settings	access:public
ileft	memcached.h	/^    int    ileft;$/;"	m	struct:conn	access:public
ilist	memcached.h	/^    item   **ilist;   \/* list of items to write out *\/$/;"	m	struct:conn	access:public
includedir	doc/Makefile	/^includedir = ${prefix}\/include$/;"	m
incr	t/binary-extstore.t	/^sub incr {$/;"	s
incr	t/binary-sasl.t	/^sub incr {$/;"	s
incr	t/binary.t	/^sub incr {$/;"	s
incr_cas	t/binary-extstore.t	/^sub incr_cas {$/;"	s
incr_cas	t/binary.t	/^sub incr_cas {$/;"	s
infodir	doc/Makefile	/^infodir = ${datarootdir}\/info$/;"	m
init	crawler.c	/^    crawler_init_func init; \/* run before crawl starts *\/$/;"	m	struct:__anon50	file:	access:public
init	slab_automove.h	/^    slab_automove_init_func init;$/;"	m	struct:__anon2	access:public
init_cond	thread.c	/^static pthread_cond_t init_cond;    \/\/ 用于维护init_count变量的条件变量$/;"	v	file:
init_count	thread.c	/^static int init_count = 0;          \/\/ 记录了已经完成初始化的工作线程数量$/;"	v	file:
init_lock	thread.c	/^static pthread_mutex_t init_lock;   \/\/ 用于维护init_count变量的互斥锁$/;"	v	file:
init_lru_crawler	crawler.c	/^int init_lru_crawler(void *arg) {$/;"	f	signature:(void *arg)
init_lru_crawler	crawler.h	/^int init_lru_crawler(void *arg);$/;"	p	signature:(void *arg)
init_lru_maintainer	items.c	/^int init_lru_maintainer(void) {$/;"	f	signature:(void)
init_lru_maintainer	items.h	/^int init_lru_maintainer(void);$/;"	p	signature:(void)
init_sasl	sasl_defs.c	/^void init_sasl(void) {$/;"	f	signature:(void)
init_sasl	sasl_defs.h	/^void init_sasl(void);$/;"	p	signature:(void)
init_sasl	sasl_defs.h	18;"	d
init_sasl_conn	memcached.c	/^static void init_sasl_conn(conn *c) {$/;"	f	file:	signature:(conn *c)
init_state	thread.c	/^    enum conn_states  init_state;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::conn_states	file:	access:public
initial	protocol_binary.h	/^                uint64_t initial;$/;"	m	struct:__anon26::__anon27::__anon28	access:public
initial_pool_size	cache.c	/^const int initial_pool_size = 64;$/;"	v
inline_ascii_response	memcached.h	/^    bool inline_ascii_response; \/* pre-format the VALUE line for ASCII responses *\/$/;"	m	struct:settings	access:public
inline_reclaim	memcached.h	/^    uint32_t inline_reclaim;$/;"	m	struct:slab_rebalance	access:public
install_sh	doc/Makefile	/^install_sh = ${SHELL} \/home\/dormando\/d\/p\/danga\/git\/memcached\/install-sh$/;"	m
install_sh_DATA	doc/Makefile	/^install_sh_DATA = $(install_sh) -c -m 644$/;"	m
install_sh_PROGRAM	doc/Makefile	/^install_sh_PROGRAM = $(install_sh) -c$/;"	m
install_sh_SCRIPT	doc/Makefile	/^install_sh_SCRIPT = $(install_sh) -c$/;"	m
inter	memcached.h	/^    char *inter;$/;"	m	struct:settings	access:public
io	memcached.h	/^    obj_io io;$/;"	m	struct:_io_wrap	access:public
io	storage.c	/^    obj_io io;$/;"	m	struct:storage_compact_wrap	file:	access:public
io_cache	memcached.h	/^    cache_t *io_cache;          \/* IO objects *\/$/;"	m	struct:__anon54	access:public
io_depth	extstore.c	/^    unsigned int io_depth; \/* FIXME: Might cache into thr struct *\/$/;"	m	struct:store_engine	file:	access:public
io_depth	extstore.h	/^    unsigned int io_depth; \/\/ with normal I\/O, hits locks less. req'd for AIO$/;"	m	struct:extstore_conf	access:public
io_queued	memcached.h	/^    bool io_queued; \/* FIXME: debugging flag *\/$/;"	m	struct:conn	access:public
io_stack	extstore.c	/^    obj_io *io_stack; \/* IO's to use with submitting wbuf's *\/$/;"	m	struct:store_engine	file:	access:public
io_threadcount	extstore.c	/^    unsigned int io_threadcount; \/* count of IO threads *\/$/;"	m	struct:store_engine	file:	access:public
io_threadcount	extstore.h	/^    unsigned int io_threadcount;$/;"	m	struct:extstore_conf	access:public
io_threads	extstore.c	/^    store_io_thread *io_threads;$/;"	m	struct:store_engine	file:	access:public
io_wrap	memcached.h	/^} io_wrap;$/;"	t	typeref:struct:_io_wrap
io_wrapleft	memcached.h	/^    int io_wrapleft;$/;"	m	struct:conn	access:public
io_wraplist	memcached.h	/^    io_wrap *io_wraplist; \/* linked list of io_wraps *\/$/;"	m	struct:conn	access:public
iov	extstore.h	/^    struct iovec *iov; \/* alternatively, use this iovec *\/$/;"	m	struct:_obj_io	typeref:struct:_obj_io::iovec	access:public
iov	memcached.h	/^    struct iovec *iov;$/;"	m	struct:conn	typeref:struct:conn::iovec	access:public
iovcnt	extstore.h	/^    unsigned int iovcnt; \/* number of IOV's *\/$/;"	m	struct:_obj_io	access:public
iovec_count	memcached.h	/^    unsigned int iovec_count; \/* total number of iovecs *\/$/;"	m	struct:_io_wrap	access:public
iovec_data	memcached.h	/^    unsigned int iovec_data;  \/* specific index of data iovec *\/$/;"	m	struct:_io_wrap	access:public
iovec_start	memcached.h	/^    unsigned int iovec_start; \/* start of the iovecs for this IO *\/$/;"	m	struct:_io_wrap	access:public
iovsize	memcached.h	/^    int    iovsize;   \/* number of elements allocated in iov[] *\/$/;"	m	struct:conn	access:public
iovused	memcached.h	/^    int    iovused;   \/* number of elements used in iov[] *\/$/;"	m	struct:conn	access:public
is_external	crawler.h	/^    bool is_external; \/* whether this was an alloc local or remote to the module. *\/$/;"	m	struct:crawler_expired_data	access:public
is_numeric	scripts/damemtop	/^sub is_numeric {$/;"	s
isize	memcached.h	/^    int    isize;$/;"	m	struct:conn	access:public
it	items.c	/^    item *it;$/;"	m	struct:__anon46	file:	access:public
it	items.h	/^    item *it;$/;"	m	struct:lru_pull_tail_return	access:public
it_flags	logger.h	/^    uint16_t it_flags;$/;"	m	struct:logentry_eviction	access:public
it_flags	logger.h	/^    uint16_t it_flags;$/;"	m	struct:logentry_ext_write	access:public
it_flags	memcached.h	/^    uint8_t          it_flags;  \/* ITEM_* above. *\/$/;"	m	struct:_strchunk	access:public
it_flags	memcached.h	/^    uint8_t         it_flags;   \/* ITEM_* above *\/$/;"	m	struct:__anon52	access:public
it_flags	memcached.h	/^    uint8_t         it_flags;   \/* ITEM_* above *\/$/;"	m	struct:_stritem	access:public
item	memcached.h	/^    void   *item;     \/* for commands set\/add\/replace  *\/$/;"	m	struct:conn	access:public
item	memcached.h	/^} item;$/;"	t	typeref:struct:_stritem
item_alloc	memcached.h	/^item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes);$/;"	p	signature:(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes)
item_alloc	thread.c	/^item *item_alloc(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes) {$/;"	f	signature:(char *key, size_t nkey, int flags, rel_time_t exptime, int nbytes)
item_cachedump	items.c	/^char *item_cachedump(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes) {$/;"	f	signature:(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes)
item_cachedump	items.h	/^char *item_cachedump(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes);$/;"	p	signature:(const unsigned int slabs_clsid, const unsigned int limit, unsigned int *bytes)
item_chunk	memcached.h	/^} item_chunk;$/;"	t	typeref:struct:_strchunk
item_crawler_thread	crawler.c	/^static void *item_crawler_thread(void *arg) {$/;"	f	file:	signature:(void *arg)
item_crawler_tid	crawler.c	/^static pthread_t item_crawler_tid;$/;"	v	file:
item_free	items.c	/^void item_free(item *it) {$/;"	f	signature:(item *it)
item_free	items.h	/^void item_free(item *it);$/;"	p	signature:(item *it)
item_get	memcached.h	/^item *item_get(const char *key, const size_t nkey, conn *c, const bool do_update);$/;"	p	signature:(const char *key, const size_t nkey, conn *c, const bool do_update)
item_get	thread.c	/^item *item_get(const char *key, const size_t nkey, conn *c, const bool do_update) {$/;"	f	signature:(const char *key, const size_t nkey, conn *c, const bool do_update)
item_hdr	memcached.h	/^} item_hdr;$/;"	t	typeref:struct:__anon53
item_is_flushed	items.c	/^int item_is_flushed(item *it) {$/;"	f	signature:(item *it)
item_is_flushed	items.h	/^int item_is_flushed(item *it);$/;"	p	signature:(item *it)
item_link	memcached.h	/^int   item_link(item *it);$/;"	p	signature:(item *it)
item_link	thread.c	/^int item_link(item *item) {$/;"	f	signature:(item *item)
item_link_q	items.c	/^static void item_link_q(item *it) {$/;"	f	file:	signature:(item *it)
item_link_q	items.c	/^static void item_link_q(item *it);$/;"	p	file:	signature:(item *it)
item_link_q_warm	items.c	/^static void item_link_q_warm(item *it) {$/;"	f	file:	signature:(item *it)
item_lock	memcached.h	/^void item_lock(uint32_t hv);$/;"	p	signature:(uint32_t hv)
item_lock	thread.c	/^void item_lock(uint32_t hv) {$/;"	f	signature:(uint32_t hv)
item_lock_count	thread.c	/^static uint32_t item_lock_count;$/;"	v	file:
item_lock_hashpower	thread.c	/^unsigned int item_lock_hashpower;$/;"	v
item_locks	thread.c	/^static pthread_mutex_t *item_locks;$/;"	v	file:
item_lru_bump_buf_create	items.c	/^void *item_lru_bump_buf_create(void) {$/;"	f	signature:(void)
item_lru_bump_buf_create	items.h	/^void *item_lru_bump_buf_create(void);$/;"	p	signature:(void)
item_make_header	items.c	/^static size_t item_make_header(const uint8_t nkey, const unsigned int flags, const int nbytes,$/;"	f	file:	signature:(const uint8_t nkey, const unsigned int flags, const int nbytes, char *suffix, uint8_t *nsuffix)
item_remove	memcached.h	/^void  item_remove(item *it);$/;"	p	signature:(item *it)
item_remove	thread.c	/^void item_remove(item *item) {$/;"	f	signature:(item *item)
item_replace	memcached.h	/^int   item_replace(item *it, item *new_it, const uint32_t hv);$/;"	p	signature:(item *it, item *new_it, const uint32_t hv)
item_replace	thread.c	/^int item_replace(item *old_it, item *new_it, const uint32_t hv) {$/;"	f	signature:(item *old_it, item *new_it, const uint32_t hv)
item_size	slab_automove_extstore.c	/^    uint32_t item_size;$/;"	m	struct:__anon56	file:	access:public
item_size_max	memcached.h	/^    int item_size_max;        \/* Maximum item size *\/$/;"	m	struct:settings	access:public
item_size_ok	items.c	/^bool item_size_ok(const size_t nkey, const int flags, const int nbytes) {$/;"	f	signature:(const size_t nkey, const int flags, const int nbytes)
item_size_ok	items.h	/^bool item_size_ok(const size_t nkey, const int flags, const int nbytes);$/;"	p	signature:(const size_t nkey, const int flags, const int nbytes)
item_stats	items.c	/^void item_stats(ADD_STAT add_stats, void *c) {$/;"	f	signature:(ADD_STAT add_stats, void *c)
item_stats	items.h	/^void item_stats(ADD_STAT add_stats, void *c);$/;"	p	signature:(ADD_STAT add_stats, void *c)
item_stats_automove	items.h	/^} item_stats_automove;$/;"	t	typeref:struct:__anon3
item_stats_reset	items.c	/^void item_stats_reset(void) {$/;"	f	signature:(void)
item_stats_reset	items.h	/^void item_stats_reset(void);$/;"	p	signature:(void)
item_stats_sizes	items.c	/^void item_stats_sizes(ADD_STAT add_stats, void *c) {$/;"	f	signature:(ADD_STAT add_stats, void *c)
item_stats_sizes	items.h	/^void item_stats_sizes(ADD_STAT add_stats, void *c);$/;"	p	signature:(ADD_STAT add_stats, void *c)
item_stats_sizes_add	items.c	/^void item_stats_sizes_add(item *it) {$/;"	f	signature:(item *it)
item_stats_sizes_add	items.h	/^void item_stats_sizes_add(item *it);$/;"	p	signature:(item *it)
item_stats_sizes_disable	items.c	/^void item_stats_sizes_disable(ADD_STAT add_stats, void *c) {$/;"	f	signature:(ADD_STAT add_stats, void *c)
item_stats_sizes_disable	items.h	/^void item_stats_sizes_disable(ADD_STAT add_stats, void *c);$/;"	p	signature:(ADD_STAT add_stats, void *c)
item_stats_sizes_enable	items.c	/^void item_stats_sizes_enable(ADD_STAT add_stats, void *c) {$/;"	f	signature:(ADD_STAT add_stats, void *c)
item_stats_sizes_enable	items.h	/^void item_stats_sizes_enable(ADD_STAT add_stats, void *c);$/;"	p	signature:(ADD_STAT add_stats, void *c)
item_stats_sizes_init	items.c	/^void item_stats_sizes_init(void) {$/;"	f	signature:(void)
item_stats_sizes_init	items.h	/^void item_stats_sizes_init(void);$/;"	p	signature:(void)
item_stats_sizes_remove	items.c	/^void item_stats_sizes_remove(item *it) {$/;"	f	signature:(item *it)
item_stats_sizes_remove	items.h	/^void item_stats_sizes_remove(item *it);$/;"	p	signature:(item *it)
item_stats_sizes_status	items.c	/^bool item_stats_sizes_status(void) {$/;"	f	signature:(void)
item_stats_sizes_status	items.h	/^bool item_stats_sizes_status(void);$/;"	p	signature:(void)
item_stats_totals	items.c	/^void item_stats_totals(ADD_STAT add_stats, void *c) {$/;"	f	signature:(ADD_STAT add_stats, void *c)
item_stats_totals	items.h	/^void item_stats_totals(ADD_STAT add_stats, void *c);$/;"	p	signature:(ADD_STAT add_stats, void *c)
item_touch	memcached.h	/^item *item_touch(const char *key, const size_t nkey, uint32_t exptime, conn *c);$/;"	p	signature:(const char *key, const size_t nkey, uint32_t exptime, conn *c)
item_touch	thread.c	/^item *item_touch(const char *key, size_t nkey, uint32_t exptime, conn *c) {$/;"	f	signature:(const char *key, size_t nkey, uint32_t exptime, conn *c)
item_trylock	memcached.h	/^void *item_trylock(uint32_t hv);$/;"	p	signature:(uint32_t hv)
item_trylock	thread.c	/^void *item_trylock(uint32_t hv) {$/;"	f	signature:(uint32_t hv)
item_trylock_unlock	memcached.h	/^void item_trylock_unlock(void *arg);$/;"	p	signature:(void *arg)
item_trylock_unlock	thread.c	/^void item_trylock_unlock(void *lock) {$/;"	f	signature:(void *lock)
item_unlink	memcached.h	/^void  item_unlink(item *it);$/;"	p	signature:(item *it)
item_unlink	thread.c	/^void item_unlink(item *item) {$/;"	f	signature:(item *item)
item_unlink_q	items.c	/^static void item_unlink_q(item *it) {$/;"	f	file:	signature:(item *it)
item_unlink_q	items.c	/^static void item_unlink_q(item *it);$/;"	p	file:	signature:(item *it)
item_unlock	memcached.h	/^void item_unlock(uint32_t hv);$/;"	p	signature:(uint32_t hv)
item_unlock	thread.c	/^void item_unlock(uint32_t hv) {$/;"	f	signature:(uint32_t hv)
itemstats	items.c	/^static itemstats_t itemstats[LARGEST_ID];$/;"	v	file:
itemstats_t	items.c	/^} itemstats_t;$/;"	t	typeref:struct:__anon45	file:
itoa	itoa_ljust.c	/^static inline char* itoa(uint32_t u, char* p, int d, int n) {$/;"	f	file:	signature:(uint32_t u, char* p, int d, int n)
itoa_32	itoa_ljust.c	/^char* itoa_32(int32_t i, char* p) {$/;"	f	signature:(int32_t i, char* p)
itoa_32	itoa_ljust.h	/^char* itoa_32( int32_t i, char* buffer);$/;"	p	signature:( int32_t i, char* buffer)
itoa_64	itoa_ljust.c	/^char* itoa_64(int64_t i, char* p) {$/;"	f	signature:(int64_t i, char* p)
itoa_64	itoa_ljust.h	/^char* itoa_64( int64_t i, char* buffer);$/;"	p	signature:( int64_t i, char* buffer)
itoa_u32	itoa_ljust.c	/^char* itoa_u32(uint32_t u, char* p) {$/;"	f	signature:(uint32_t u, char* p)
itoa_u32	itoa_ljust.h	/^char* itoa_u32(uint32_t u, char* buffer);$/;"	p	signature:(uint32_t u, char* buffer)
itoa_u64	itoa_ljust.c	/^char* itoa_u64(uint64_t u, char* p) {$/;"	f	signature:(uint64_t u, char* p)
itoa_u64	itoa_ljust.h	/^char* itoa_u64(uint64_t u, char* buffer);$/;"	p	signature:(uint64_t u, char* buffer)
jenkins_hash	jenkins_hash.c	/^uint32_t jenkins_hash( const void *key, size_t length)$/;"	f	signature:( const void *key, size_t length)
jenkins_hash	jenkins_hash.c	/^uint32_t jenkins_hash($/;"	f	signature:( const void *key, size_t length)
jenkins_hash	jenkins_hash.h	/^uint32_t jenkins_hash(const void *key, size_t length);$/;"	p	signature:(const void *key, size_t length)
key	logger.h	/^    char key[];$/;"	m	struct:logentry_eviction	access:public
key	logger.h	/^    char key[];$/;"	m	struct:logentry_ext_write	access:public
key	logger.h	/^    char key[];$/;"	m	struct:logentry_item_get	access:public
key	logger.h	/^    char key[];$/;"	m	struct:logentry_item_store	access:public
key	t/stress-memcached.pl	/^sub key {$/;"	s
keylen	memcached.h	/^    int keylen;$/;"	m	struct:conn	access:public
keylen	protocol_binary.h	/^            uint16_t keylen;$/;"	m	struct:__anon11::__anon12	access:public
keylen	protocol_binary.h	/^            uint16_t keylen;$/;"	m	struct:__anon9::__anon10	access:public
l	memcached.h	/^    logger *l;                  \/* logger buffer *\/$/;"	m	struct:__anon54	access:public
last_cmd_time	memcached.h	/^    rel_time_t last_cmd_time;$/;"	m	struct:conn	access:public
last_io_thread	extstore.c	/^    unsigned int last_io_thread; \/* round robin the IO threads *\/$/;"	m	struct:store_engine	file:	access:public
last_memcheck_run	slab_automove_extstore.c	/^    rel_time_t last_memcheck_run;$/;"	m	struct:__anon56	file:	access:public
last_thread	thread.c	/^static int last_thread = -1;$/;"	v	file:
latime	logger.h	/^    uint32_t latime;$/;"	m	struct:logentry_eviction	access:public
latime	logger.h	/^    uint32_t latime;$/;"	m	struct:logentry_ext_write	access:public
len	extstore.h	/^    unsigned int len;     \/* for both modes *\/$/;"	m	struct:_obj_io	access:public
length	memcached.c	/^    size_t length;$/;"	m	struct:token_s	file:	access:public
libdir	doc/Makefile	/^libdir = ${exec_prefix}\/lib$/;"	m
libexecdir	doc/Makefile	/^libexecdir = ${exec_prefix}\/libexec$/;"	m
likely	memcached.h	777;"	d
limited_get	memcached.c	/^static inline item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch) {$/;"	f	file:	signature:(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch)
list_mechs	t/binary-sasl.t	/^sub list_mechs {$/;"	s
list_size	slabs.c	/^    unsigned int list_size; \/* size of prev array *\/$/;"	m	struct:__anon1	file:	access:public
listen_conn	memcached.c	/^static conn *listen_conn = NULL;$/;"	v	file:
listen_disabled_num	memcached.h	/^    uint64_t      listen_disabled_num;$/;"	m	struct:stats	access:public
load_config	scripts/damemtop	/^sub load_config {$/;"	s
local_transport	memcached.h	/^    local_transport, \/* Unix sockets*\/$/;"	e	enum:network_transport
localedir	doc/Makefile	/^localedir = ${datarootdir}\/locale$/;"	m
localstatedir	doc/Makefile	/^localstatedir = ${prefix}\/var$/;"	m
locations	sasl_defs.c	/^const char * const locations[] = {$/;"	v
lock	crawler.h	/^    pthread_mutex_t lock;$/;"	m	struct:crawler_expired_data	access:public
lock	storage.c	/^    pthread_mutex_t lock; \/\/ gates the bools.$/;"	m	struct:storage_compact_wrap	file:	access:public
lock	thread.c	/^    pthread_mutex_t lock;$/;"	m	struct:conn_queue	file:	access:public
log_entry_subtype	logger.h	/^enum log_entry_subtype {$/;"	g
log_entry_type	logger.h	/^enum log_entry_type {$/;"	g
log_watcher_sent	memcached.h	/^    uint64_t      log_watcher_sent; \/* logs sent to watcher buffers *\/$/;"	m	struct:stats	access:public
log_watcher_skipped	memcached.h	/^    uint64_t      log_watcher_skipped; \/* logs watchers missed *\/$/;"	m	struct:stats	access:public
log_worker_dropped	memcached.h	/^    uint64_t      log_worker_dropped; \/* logs dropped by worker threads *\/$/;"	m	struct:stats	access:public
log_worker_written	memcached.h	/^    uint64_t      log_worker_written; \/* logs written by worker threads *\/$/;"	m	struct:stats	access:public
logentry	logger.h	/^} logentry;$/;"	t	typeref:struct:_logentry
logentry_eviction	logger.h	/^struct logentry_eviction {$/;"	s
logentry_eviction::clsid	logger.h	/^    uint8_t clsid;$/;"	m	struct:logentry_eviction	access:public
logentry_eviction::exptime	logger.h	/^    long long int exptime;$/;"	m	struct:logentry_eviction	access:public
logentry_eviction::it_flags	logger.h	/^    uint16_t it_flags;$/;"	m	struct:logentry_eviction	access:public
logentry_eviction::key	logger.h	/^    char key[];$/;"	m	struct:logentry_eviction	access:public
logentry_eviction::latime	logger.h	/^    uint32_t latime;$/;"	m	struct:logentry_eviction	access:public
logentry_eviction::nkey	logger.h	/^    uint8_t nkey;$/;"	m	struct:logentry_eviction	access:public
logentry_ext_write	logger.h	/^struct logentry_ext_write {$/;"	s
logentry_ext_write::bucket	logger.h	/^    uint8_t bucket;$/;"	m	struct:logentry_ext_write	access:public
logentry_ext_write::clsid	logger.h	/^    uint8_t clsid;$/;"	m	struct:logentry_ext_write	access:public
logentry_ext_write::exptime	logger.h	/^    long long int exptime;$/;"	m	struct:logentry_ext_write	access:public
logentry_ext_write::it_flags	logger.h	/^    uint16_t it_flags;$/;"	m	struct:logentry_ext_write	access:public
logentry_ext_write::key	logger.h	/^    char key[];$/;"	m	struct:logentry_ext_write	access:public
logentry_ext_write::latime	logger.h	/^    uint32_t latime;$/;"	m	struct:logentry_ext_write	access:public
logentry_ext_write::nkey	logger.h	/^    uint8_t nkey;$/;"	m	struct:logentry_ext_write	access:public
logentry_item_get	logger.h	/^struct logentry_item_get {$/;"	s
logentry_item_get::clsid	logger.h	/^    uint8_t clsid;$/;"	m	struct:logentry_item_get	access:public
logentry_item_get::key	logger.h	/^    char key[];$/;"	m	struct:logentry_item_get	access:public
logentry_item_get::nkey	logger.h	/^    uint8_t nkey;$/;"	m	struct:logentry_item_get	access:public
logentry_item_get::was_found	logger.h	/^    uint8_t was_found;$/;"	m	struct:logentry_item_get	access:public
logentry_item_store	logger.h	/^struct logentry_item_store {$/;"	s
logentry_item_store::clsid	logger.h	/^    uint8_t clsid;$/;"	m	struct:logentry_item_store	access:public
logentry_item_store::cmd	logger.h	/^    int cmd;$/;"	m	struct:logentry_item_store	access:public
logentry_item_store::key	logger.h	/^    char key[];$/;"	m	struct:logentry_item_store	access:public
logentry_item_store::nkey	logger.h	/^    uint8_t nkey;$/;"	m	struct:logentry_item_store	access:public
logentry_item_store::status	logger.h	/^    int status;$/;"	m	struct:logentry_item_store	access:public
logentry_item_store::ttl	logger.h	/^    rel_time_t ttl;$/;"	m	struct:logentry_item_store	access:public
logger	logger.h	/^} logger;$/;"	t	typeref:struct:_logger
logger_add_watcher	logger.c	/^enum logger_add_watcher_ret logger_add_watcher(void *c, const int sfd, uint16_t f) {$/;"	f	signature:(void *c, const int sfd, uint16_t f)
logger_add_watcher	logger.h	/^enum logger_add_watcher_ret logger_add_watcher(void *c, const int sfd, uint16_t f);$/;"	p	signature:(void *c, const int sfd, uint16_t f)
logger_add_watcher_ret	logger.h	/^enum logger_add_watcher_ret {$/;"	g
logger_atomics_mutex	logger.c	/^pthread_mutex_t logger_atomics_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
logger_buf_size	memcached.h	/^    unsigned int logger_buf_size; \/* size of per-thread logger buffer *\/$/;"	m	struct:settings	access:public
logger_count	logger.c	/^static unsigned int logger_count = 0;$/;"	v	file:
logger_create	logger.c	/^logger *logger_create(void) {$/;"	f	signature:(void)
logger_create	logger.h	/^logger *logger_create(void);$/;"	p	signature:(void)
logger_get_gid	logger.c	/^static uint64_t logger_get_gid(void) {$/;"	f	file:	signature:(void)
logger_init	logger.c	/^void logger_init(void) {$/;"	f	signature:(void)
logger_init	logger.h	/^void logger_init(void);$/;"	p	signature:(void)
logger_key	logger.c	/^pthread_key_t logger_key;   \/\/ 定义了一个和线程私有logger关联的key$/;"	v
logger_link_q	logger.c	/^static void logger_link_q(logger *l) {$/;"	f	file:	signature:(logger *l)
logger_log	logger.c	/^enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...) {$/;"	f	signature:(logger *l, const enum log_entry_type event, const void *entry, ...)
logger_log	logger.h	/^enum logger_ret_type logger_log(logger *l, const enum log_entry_type event, const void *entry, ...);$/;"	p	signature:(logger *l, const enum log_entry_type event, const void *entry, ...)
logger_parse_entry_ret	logger.h	/^enum logger_parse_entry_ret {$/;"	g
logger_ret_type	logger.h	/^enum logger_ret_type {$/;"	g
logger_set_flags	logger.c	/^static void logger_set_flags(void) {$/;"	f	file:	signature:(void)
logger_stack_head	logger.c	/^static logger *logger_stack_head = NULL;$/;"	v	file:
logger_stack_lock	logger.c	/^pthread_mutex_t logger_stack_lock = PTHREAD_MUTEX_INITIALIZER;  \/\/ 定义了一个用于维护logger_stack的互斥锁$/;"	v
logger_stack_tail	logger.c	/^static logger *logger_stack_tail = NULL;$/;"	v	file:
logger_stats	logger.h	/^struct logger_stats {$/;"	s
logger_stats::watcher_sent	logger.h	/^    uint64_t watcher_sent;$/;"	m	struct:logger_stats	access:public
logger_stats::watcher_skipped	logger.h	/^    uint64_t watcher_skipped;$/;"	m	struct:logger_stats	access:public
logger_stats::worker_dropped	logger.h	/^    uint64_t worker_dropped;$/;"	m	struct:logger_stats	access:public
logger_stats::worker_written	logger.h	/^    uint64_t worker_written;$/;"	m	struct:logger_stats	access:public
logger_thread	logger.c	/^static void *logger_thread(void *arg) {$/;"	f	file:	signature:(void *arg)
logger_thread_close_watcher	logger.c	/^static void logger_thread_close_watcher(logger_watcher *w) {$/;"	f	file:	signature:(logger_watcher *w)
logger_thread_parse_entry	logger.c	/^static enum logger_parse_entry_ret logger_thread_parse_entry(logentry *e, struct logger_stats *ls,$/;"	f	file:	signature:(logentry *e, struct logger_stats *ls, char *scratch, int *scratch_len)
logger_thread_poll_watchers	logger.c	/^static int logger_thread_poll_watchers(int force_poll, int watcher) {$/;"	f	file:	signature:(int force_poll, int watcher)
logger_thread_poll_watchers	logger.c	/^static int logger_thread_poll_watchers(int force_poll, int watcher);$/;"	p	file:	signature:(int force_poll, int watcher)
logger_thread_read	logger.c	/^static int logger_thread_read(logger *l, struct logger_stats *ls) {$/;"	f	file:	signature:(logger *l, struct logger_stats *ls)
logger_thread_sum_stats	logger.c	/^static void logger_thread_sum_stats(struct logger_stats *ls) {$/;"	f	file:	signature:(struct logger_stats *ls)
logger_thread_write_entry	logger.c	/^static void logger_thread_write_entry(logentry *e, struct logger_stats *ls,$/;"	f	file:	signature:(logentry *e, struct logger_stats *ls, char *scratch, int scratch_len)
logger_tid	logger.c	/^static pthread_t logger_tid;\/\/ 记录了logger线程ID$/;"	v	file:
logger_watcher	logger.h	/^} logger_watcher;$/;"	t	typeref:struct:__anon59
logger_watcher_buf_size	memcached.h	/^    unsigned int logger_watcher_buf_size; \/* size of logger's per-watcher buffer *\/$/;"	m	struct:settings	access:public
logger_watcher_type	logger.h	/^enum logger_watcher_type {$/;"	g
lookuphost	testapp.c	/^static struct addrinfo *lookuphost(const char *hostname, in_port_t port)$/;"	f	file:	signature:(const char *hostname, in_port_t port)
lru_bump_async	items.c	/^static bool lru_bump_async(lru_bump_buf *b, item *it, uint32_t hv) {$/;"	f	file:	signature:(lru_bump_buf *b, item *it, uint32_t hv)
lru_bump_async	items.c	/^static bool lru_bump_async(lru_bump_buf *b, item *it, uint32_t hv);$/;"	p	file:	signature:(lru_bump_buf *b, item *it, uint32_t hv)
lru_bump_buf	items.c	/^} lru_bump_buf;$/;"	t	typeref:struct:_lru_bump_buf	file:
lru_bump_buf	memcached.h	/^    void *lru_bump_buf;         \/* async LRU bump buffer *\/$/;"	m	struct:__anon54	access:public
lru_bump_buf_create	items.h	/^void *lru_bump_buf_create(void);$/;"	p	signature:(void)
lru_bump_buf_link_q	items.c	/^static void lru_bump_buf_link_q(lru_bump_buf *b) {$/;"	f	file:	signature:(lru_bump_buf *b)
lru_bump_entry	items.c	/^} lru_bump_entry;$/;"	t	typeref:struct:__anon46	file:
lru_crawler	memcached.h	/^    bool lru_crawler;        \/* Whether or not to enable the autocrawler thread 标识是否已经使能LRU自动爬虫线程 *\/$/;"	m	struct:settings	access:public
lru_crawler_class_done	crawler.c	/^static void lru_crawler_class_done(int i) {$/;"	f	file:	signature:(int i)
lru_crawler_client_getbuf	crawler.c	/^static int lru_crawler_client_getbuf(crawler_client_t *c) {$/;"	f	file:	signature:(crawler_client_t *c)
lru_crawler_client_getbuf	crawler.c	/^static int lru_crawler_client_getbuf(crawler_client_t *c);$/;"	p	file:	signature:(crawler_client_t *c)
lru_crawler_close_client	crawler.c	/^static void lru_crawler_close_client(crawler_client_t *c) {$/;"	f	file:	signature:(crawler_client_t *c)
lru_crawler_cond	crawler.c	/^static pthread_cond_t  lru_crawler_cond = PTHREAD_COND_INITIALIZER;$/;"	v	file:
lru_crawler_crawl	crawler.c	/^enum crawler_result_type lru_crawler_crawl(char *slabs, const enum crawler_run_type type,$/;"	f	signature:(char *slabs, const enum crawler_run_type type, void *c, const int sfd, unsigned int remaining)
lru_crawler_crawl	crawler.h	/^enum crawler_result_type lru_crawler_crawl(char *slabs, enum crawler_run_type,$/;"	p	signature:(char *slabs, enum crawler_run_type, void *c, const int sfd, unsigned int remaining)
lru_crawler_initialized	crawler.c	/^static int lru_crawler_initialized = 0; \/\/ 标识LRU爬虫模块是否已经完成初始化$/;"	v	file:
lru_crawler_lock	crawler.c	/^static pthread_mutex_t lru_crawler_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
lru_crawler_pause	crawler.c	/^void lru_crawler_pause(void) {$/;"	f	signature:(void)
lru_crawler_pause	crawler.h	/^void lru_crawler_pause(void);$/;"	p	signature:(void)
lru_crawler_poll	crawler.c	/^static int lru_crawler_poll(crawler_client_t *c) {$/;"	f	file:	signature:(crawler_client_t *c)
lru_crawler_release_client	crawler.c	/^static void lru_crawler_release_client(crawler_client_t *c) {$/;"	f	file:	signature:(crawler_client_t *c)
lru_crawler_resume	crawler.c	/^void lru_crawler_resume(void) {$/;"	f	signature:(void)
lru_crawler_resume	crawler.h	/^void lru_crawler_resume(void);$/;"	p	signature:(void)
lru_crawler_running	memcached.h	/^    bool          lru_crawler_running; \/* crawl in progress *\/$/;"	m	struct:stats_state	access:public
lru_crawler_set_client	crawler.c	/^static int lru_crawler_set_client(crawler_module_t *cm, void *c, const int sfd) {$/;"	f	file:	signature:(crawler_module_t *cm, void *c, const int sfd)
lru_crawler_sleep	memcached.h	/^    int lru_crawler_sleep;  \/* Microsecond sleep between items *\/$/;"	m	struct:settings	access:public
lru_crawler_start	crawler.c	/^int lru_crawler_start(uint8_t *ids, uint32_t remaining,$/;"	f	signature:(uint8_t *ids, uint32_t remaining, const enum crawler_run_type type, void *data, void *c, const int sfd)
lru_crawler_start	crawler.h	/^int lru_crawler_start(uint8_t *ids, uint32_t remaining,$/;"	p	signature:(uint8_t *ids, uint32_t remaining, const enum crawler_run_type type, void *data, void *c, const int sfd)
lru_crawler_starts	memcached.h	/^    uint64_t      lru_crawler_starts; \/* Number of item crawlers kicked off *\/$/;"	m	struct:stats	access:public
lru_crawler_tocrawl	memcached.h	/^    uint32_t lru_crawler_tocrawl; \/* Number of items to crawl per run *\/$/;"	m	struct:settings	access:public
lru_hits	memcached.h	/^    uint64_t lru_hits[POWER_LARGEST];$/;"	m	struct:thread_stats	access:public
lru_locks	thread.c	/^pthread_mutex_t lru_locks[POWER_LARGEST];$/;"	v
lru_maintainer_bumps	items.c	/^static bool lru_maintainer_bumps(void) {$/;"	f	file:	signature:(void)
lru_maintainer_crawler_check	items.c	/^static void lru_maintainer_crawler_check(struct crawler_expired_data *cdata, logger *l) {$/;"	f	file:	signature:(struct crawler_expired_data *cdata, logger *l)
lru_maintainer_initialized	items.c	/^static int lru_maintainer_initialized = 0;$/;"	v	file:
lru_maintainer_juggle	items.c	/^static int lru_maintainer_juggle(const int slabs_clsid) {$/;"	f	file:	signature:(const int slabs_clsid)
lru_maintainer_juggles	memcached.h	/^    uint64_t      lru_maintainer_juggles; \/* number of LRU bg pokes *\/$/;"	m	struct:stats	access:public
lru_maintainer_lock	items.c	/^static pthread_mutex_t lru_maintainer_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
lru_maintainer_pause	items.c	/^void lru_maintainer_pause(void) {$/;"	f	signature:(void)
lru_maintainer_pause	items.h	/^void lru_maintainer_pause(void);$/;"	p	signature:(void)
lru_maintainer_resume	items.c	/^void lru_maintainer_resume(void) {$/;"	f	signature:(void)
lru_maintainer_resume	items.h	/^void lru_maintainer_resume(void);$/;"	p	signature:(void)
lru_maintainer_store	storage.c	/^int lru_maintainer_store(void *storage, const int clsid) {$/;"	f	signature:(void *storage, const int clsid)
lru_maintainer_store	storage.h	/^int lru_maintainer_store(void *storage, const int clsid);$/;"	p	signature:(void *storage, const int clsid)
lru_maintainer_thread	items.c	/^static void *lru_maintainer_thread(void *arg) {$/;"	f	file:	signature:(void *arg)
lru_maintainer_thread	memcached.h	/^    bool lru_maintainer_thread; \/* LRU maintainer background thread *\/$/;"	m	struct:settings	access:public
lru_maintainer_tid	items.c	/^static pthread_t lru_maintainer_tid;$/;"	v	file:
lru_pull_tail	items.c	/^int lru_pull_tail(const int orig_id, const int cur_lru,$/;"	f	signature:(const int orig_id, const int cur_lru, const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age, struct lru_pull_tail_return *ret_it)
lru_pull_tail	items.h	/^int lru_pull_tail(const int orig_id, const int cur_lru,$/;"	p	signature:(const int orig_id, const int cur_lru, const uint64_t total_bytes, const uint8_t flags, const rel_time_t max_age, struct lru_pull_tail_return *ret_it)
lru_pull_tail_return	items.h	/^struct lru_pull_tail_return {$/;"	s
lru_pull_tail_return::hv	items.h	/^    uint32_t hv;$/;"	m	struct:lru_pull_tail_return	access:public
lru_pull_tail_return::it	items.h	/^    item *it;$/;"	m	struct:lru_pull_tail_return	access:public
lru_segmented	memcached.h	/^    bool lru_segmented;     \/* Use split or flat LRU's *\/$/;"	m	struct:settings	access:public
lru_total_bumps_dropped	items.c	/^static uint64_t lru_total_bumps_dropped(void) {$/;"	f	file:	signature:(void)
lru_total_bumps_dropped	items.c	/^static uint64_t lru_total_bumps_dropped(void);$/;"	p	file:	signature:(void)
lru_type_map	items.c	/^static unsigned int lru_type_map[4] = {HOT_LRU, WARM_LRU, COLD_LRU, TEMP_LRU};$/;"	v	file:
lrutail_reflocked	items.c	/^    uint64_t lrutail_reflocked;$/;"	m	struct:__anon45	file:	access:public
lut	itoa_ljust.c	/^static const char lut[201] =$/;"	v	file:
magic	protocol_binary.h	/^            uint8_t magic;$/;"	m	struct:__anon11::__anon12	access:public
magic	protocol_binary.h	/^            uint8_t magic;$/;"	m	struct:__anon9::__anon10	access:public
main	config.guess	/^		main()$/;"	f
main	config.guess	/^	main ()$/;"	f
main	memcached.c	/^int main (int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	sizes.c	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	stats.c	/^main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	testapp.c	/^int main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	timedrun.c	/^int main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main_base	memcached.c	/^static struct event_base *main_base;    \/\/ 记录了主线程的event_base$/;"	v	typeref:struct:event_base	file:
main_loop	scripts/damemtop	/^sub main_loop {$/;"	s
maint_thread	extstore.c	/^    store_maint_thread *maint_thread;$/;"	m	struct:store_engine	file:	access:public
maintain_connections	scripts/damemtop	/^sub maintain_connections {$/;"	s
maintenance_cond	assoc.c	/^static pthread_cond_t maintenance_cond = PTHREAD_COND_INITIALIZER;$/;"	v	file:
maintenance_lock	assoc.c	/^static pthread_mutex_t maintenance_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
maintenance_tid	assoc.c	/^static pthread_t maintenance_tid;$/;"	v	file:
make_ascii_get_suffix	memcached.c	/^static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {$/;"	f	file:	signature:(char *suffix, item *it, bool return_cas, int nbytes)
make_dummy_depfile	depcomp	/^make_dummy_depfile ()$/;"	f
malloc_fails	memcached.h	/^    uint64_t      malloc_fails;$/;"	m	struct:stats	access:public
man1dir	doc/Makefile	/^man1dir = $(mandir)\/man1$/;"	m
man_MANS	doc/Makefile	/^man_MANS = memcached.1$/;"	m
mandir	doc/Makefile	/^mandir = ${datarootdir}\/man$/;"	m
max_age_ratio	slab_automove.c	/^    double max_age_ratio;$/;"	m	struct:__anon48	file:	access:public
max_age_ratio	slab_automove_extstore.c	/^    double max_age_ratio;$/;"	m	struct:__anon56	file:	access:public
max_fds	memcached.c	/^static int max_fds;$/;"	v	file:
max_results	protocol_binary.h	/^                uint32_t max_results;$/;"	m	struct:__anon38::__anon39::__anon40	access:public
maxbytes	memcached.h	/^    size_t maxbytes;$/;"	m	struct:settings	access:public
maxconns	memcached.h	/^    int maxconns;$/;"	m	struct:settings	access:public
maxconns_entered	memcached.h	/^    struct timeval maxconns_entered;  \/* last time maxconns entered *\/$/;"	m	struct:stats	typeref:struct:stats::timeval	access:public
maxconns_fast	memcached.h	/^    bool maxconns_fast;     \/* Whether or not to early close connections *\/$/;"	m	struct:settings	access:public
maxconns_handler	memcached.c	/^static void maxconns_handler(const int fd, const short which, void *arg) {$/;"	f	file:	signature:(const int fd, const short which, void *arg)
maxconnsevent	memcached.c	/^static struct event maxconnsevent;$/;"	v	typeref:struct:event	file:
maximize_sndbuf	memcached.c	/^static void maximize_sndbuf(const int sfd) {$/;"	f	file:	signature:(const int sfd)
mc_swap64	util.c	/^static uint64_t mc_swap64(uint64_t in) {$/;"	f	file:	signature:(uint64_t in)
mem_avail	slabs.c	/^static size_t mem_avail = 0;$/;"	v	file:
mem_base	slabs.c	/^static void *mem_base = NULL;$/;"	v	file:
mem_current	slabs.c	/^static void *mem_current = NULL;$/;"	v	file:
mem_get_is	t/lib/MemcachedTest.pm	/^sub mem_get_is {$/;"	s
mem_gets	t/lib/MemcachedTest.pm	/^sub mem_gets {$/;"	s
mem_gets_is	t/lib/MemcachedTest.pm	/^sub mem_gets_is {$/;"	s
mem_limit	slabs.c	/^static size_t mem_limit = 0;$/;"	v	file:
mem_limit_reached	slabs.c	/^static bool mem_limit_reached = false;$/;"	v	file:
mem_malloced	slabs.c	/^static size_t mem_malloced = 0;$/;"	v	file:
mem_stats	t/lib/MemcachedTest.pm	/^sub mem_stats {$/;"	s
memcached_sasl_pwdb	sasl_defs.c	/^static const char *memcached_sasl_pwdb;$/;"	v	file:
memcached_thread_init	memcached.h	/^void memcached_thread_init(int nthreads, void *arg);$/;"	p	signature:(int nthreads, void *arg)
memcached_thread_init	thread.c	/^void memcached_thread_init(int nthreads, void *arg) {$/;"	f	signature:(int nthreads, void *arg)
memcheck	slab_automove_extstore.c	/^static void memcheck(slab_automove *a) {$/;"	f	file:	signature:(slab_automove *a)
memory_allocate	slabs.c	/^static void *memory_allocate(size_t size) {$/;"	f	file:	signature:(size_t size)
memory_allocate	slabs.c	/^static void *memory_allocate(size_t size);$/;"	p	file:	signature:(size_t size)
memory_release	slabs.c	/^static void memory_release() {$/;"	f	file:
message	protocol_binary.h	/^        } message;$/;"	m	union:__anon13	typeref:struct:__anon13::__anon14	access:public
message	protocol_binary.h	/^        } message;$/;"	m	union:__anon15	typeref:struct:__anon15::__anon16	access:public
message	protocol_binary.h	/^        } message;$/;"	m	union:__anon17	typeref:struct:__anon17::__anon18	access:public
message	protocol_binary.h	/^        } message;$/;"	m	union:__anon20	typeref:struct:__anon20::__anon21	access:public
message	protocol_binary.h	/^        } message;$/;"	m	union:__anon23	typeref:struct:__anon23::__anon24	access:public
message	protocol_binary.h	/^        } message;$/;"	m	union:__anon26	typeref:struct:__anon26::__anon27	access:public
message	protocol_binary.h	/^        } message;$/;"	m	union:__anon29	typeref:struct:__anon29::__anon30	access:public
message	protocol_binary.h	/^        } message;$/;"	m	union:__anon32	typeref:struct:__anon32::__anon33	access:public
message	protocol_binary.h	/^        } message;$/;"	m	union:__anon35	typeref:struct:__anon35::__anon36	access:public
message	protocol_binary.h	/^        } message;$/;"	m	union:__anon38	typeref:struct:__anon38::__anon39	access:public
miss	memcached.h	/^    bool miss;                \/* signal a miss to unlink hdr_it *\/$/;"	m	struct:_io_wrap	access:public
miss	storage.c	/^    bool miss; \/\/ version flipped out from under us$/;"	m	struct:storage_compact_wrap	file:	access:public
mix	jenkins_hash.c	79;"	d	file:
mkdir_p	doc/Makefile	/^mkdir_p = $(MKDIR_P)$/;"	m
mkinstalldirs	doc/Makefile	/^mkinstalldirs = $(install_sh) -d$/;"	m
mod	crawler.c	/^    crawler_module_reg_t *mod;$/;"	m	struct:_crawler_module_t	file:	access:public
mode	extstore.h	/^    enum obj_io_mode mode;$/;"	m	struct:_obj_io	typeref:enum:_obj_io::obj_io_mode	access:public
mode	thread.c	/^    enum conn_queue_item_modes mode;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::conn_queue_item_modes	file:	access:public
move_status	slabs.c	/^enum move_status {$/;"	g	file:
moves_to_cold	items.c	/^    uint64_t moves_to_cold;$/;"	m	struct:__anon45	file:	access:public
moves_to_warm	items.c	/^    uint64_t moves_to_warm;$/;"	m	struct:__anon45	file:	access:public
moves_within_lru	items.c	/^    uint64_t moves_within_lru;$/;"	m	struct:__anon45	file:	access:public
msgbytes	memcached.h	/^    int    msgbytes;  \/* number of bytes in current msg *\/$/;"	m	struct:conn	access:public
msgcurr	memcached.h	/^    int    msgcurr;   \/* element in msglist[] being transmitted now *\/$/;"	m	struct:conn	access:public
msglist	memcached.h	/^    struct msghdr *msglist;$/;"	m	struct:conn	typeref:struct:conn::msghdr	access:public
msgsize	memcached.h	/^    int    msgsize;   \/* number of elements allocated in msglist[] *\/$/;"	m	struct:conn	access:public
msgused	memcached.h	/^    int    msgused;   \/* number of elements used in msglist[] *\/$/;"	m	struct:conn	access:public
mt_stats_lock	stats.c	/^void mt_stats_lock() { }$/;"	f
mt_stats_unlock	stats.c	/^void mt_stats_unlock() { }$/;"	f
mutation_ratio	logger.h	/^    uint16_t mutation_ratio; \/* log one out of every N mutations *\/$/;"	m	struct:_logger	access:public
mutex	cache.h	/^    pthread_mutex_t mutex;$/;"	m	struct:__anon41	access:public
mutex	extstore.c	/^    pthread_mutex_t mutex; \/* Need to be held for most operations *\/$/;"	m	struct:_store_page	file:	access:public
mutex	extstore.c	/^    pthread_mutex_t mutex; \/* covers internal stacks and variables *\/$/;"	m	struct:store_engine	file:	access:public
mutex	extstore.c	/^    pthread_mutex_t mutex;$/;"	m	struct:__anon43	file:	access:public
mutex	extstore.c	/^    pthread_mutex_t mutex;$/;"	m	struct:__anon44	file:	access:public
mutex	items.c	/^    pthread_mutex_t mutex;$/;"	m	struct:_lru_bump_buf	file:	access:public
mutex	logger.h	/^    pthread_mutex_t mutex; \/* guard for this + *buf *\/$/;"	m	struct:_logger	access:public
mutex	memcached.h	/^    pthread_mutex_t   mutex;    \/\/ 用于维护本结构的互斥锁$/;"	m	struct:thread_stats	access:public
mutex_lock	memcached.h	699;"	d
mutex_unlock	memcached.h	700;"	d
my_sasl_hostname	sasl_defs.c	/^char my_sasl_hostname[1025];$/;"	v
name	cache.h	/^    char *name;$/;"	m	struct:__anon41	access:public
nbytes	memcached.h	/^    int              nbytes;    \/* used. *\/$/;"	m	struct:_strchunk	access:public
nbytes	memcached.h	/^    int             nbytes;     \/* size of data *\/$/;"	m	struct:__anon52	access:public
nbytes	memcached.h	/^    int             nbytes;     \/* size of data *\/$/;"	m	struct:_stritem	access:public
needs_client	crawler.c	/^    bool needs_client; \/* whether or not to grab onto the remote client *\/$/;"	m	struct:__anon50	file:	access:public
needs_lock	crawler.c	/^    bool needs_lock; \/* whether or not we need the LRU lock held when eval is called *\/$/;"	m	struct:__anon50	file:	access:public
negotiating_prot	memcached.h	/^    negotiating_prot \/* Discovering the protocol *\/$/;"	e	enum:protocol
network_transport	memcached.h	/^enum network_transport {$/;"	g
new	t/binary-extstore.t	/^sub new {$/;"	s
new	t/binary-sasl.t	/^sub new {$/;"	s
new	t/binary.t	/^sub new {$/;"	s
new	t/lib/MemcachedTest.pm	/^sub new {$/;"	s
new_conn_queue	memcached.h	/^    struct conn_queue *new_conn_queue; \/* queue of new connections to handle 指向该线程关联的连接队列 *\/$/;"	m	struct:__anon54	typeref:struct:__anon54::conn_queue	access:public
new_memcached	t/lib/MemcachedTest.pm	/^sub new_memcached {$/;"	s
new_sock	t/lib/MemcachedTest.pm	/^sub new_sock {$/;"	s
new_socket	memcached.c	/^static int new_socket(struct addrinfo *ai) {$/;"	f	file:	signature:(struct addrinfo *ai)
new_socket	memcached.c	/^static int new_socket(struct addrinfo *ai);$/;"	p	file:	signature:(struct addrinfo *ai)
new_socket_unix	memcached.c	/^static int new_socket_unix(void) {$/;"	f	file:	signature:(void)
new_udp_sock	t/lib/MemcachedTest.pm	/^sub new_udp_sock {$/;"	s
next	extstore.c	/^    struct __store_wbuf *next;$/;"	m	struct:__store_wbuf	typeref:struct:__store_wbuf::__store_wbuf	file:	access:public
next	extstore.c	/^    struct _store_page *next;$/;"	m	struct:_store_page	typeref:struct:_store_page::_store_page	file:	access:public
next	extstore.h	/^    struct _obj_io *next;$/;"	m	struct:_obj_io	typeref:struct:_obj_io::_obj_io	access:public
next	items.c	/^    struct _lru_bump_buf *next;$/;"	m	struct:_lru_bump_buf	typeref:struct:_lru_bump_buf::_lru_bump_buf	file:	access:public
next	logger.h	/^    struct _logger *next;$/;"	m	struct:_logger	typeref:struct:_logger::_logger	access:public
next	memcached.h	/^    conn   *next;     \/* Used for generating a list of conn structures *\/$/;"	m	struct:conn	access:public
next	memcached.h	/^    struct _io_wrap *next;$/;"	m	struct:_io_wrap	typeref:struct:_io_wrap::_io_wrap	access:public
next	memcached.h	/^    struct _strchunk *next;     \/* points within its own chain. *\/$/;"	m	struct:_strchunk	typeref:struct:_strchunk::_strchunk	access:public
next	memcached.h	/^    struct _stritem *next;$/;"	m	struct:__anon52	typeref:struct:__anon52::_stritem	access:public
next	memcached.h	/^    struct _stritem *next;$/;"	m	struct:_stritem	typeref:struct:_stritem::_stritem	access:public
next	stats.c	/^    PREFIX_STATS *next;$/;"	m	struct:_prefix_stats	file:	access:public
next	thread.c	/^    CQ_ITEM          *next;$/;"	m	struct:conn_queue_item	file:	access:public
nkey	logger.h	/^    uint8_t nkey;$/;"	m	struct:logentry_eviction	access:public
nkey	logger.h	/^    uint8_t nkey;$/;"	m	struct:logentry_ext_write	access:public
nkey	logger.h	/^    uint8_t nkey;$/;"	m	struct:logentry_item_get	access:public
nkey	logger.h	/^    uint8_t nkey;$/;"	m	struct:logentry_item_store	access:public
nkey	memcached.h	/^    uint8_t         nkey;       \/* key length, w\/terminating null and padding *\/$/;"	m	struct:__anon52	access:public
nkey	memcached.h	/^    uint8_t         nkey;       \/* key length, w\/terminating null and padding *\/$/;"	m	struct:_stritem	access:public
noexp	crawler.h	/^    uint64_t noexp;$/;"	m	struct:__anon4	access:public
noop	t/binary-extstore.t	/^sub noop {$/;"	s
noop	t/binary-sasl.t	/^sub noop {$/;"	s
noop	t/binary.t	/^sub noop {$/;"	s
noreply	memcached.h	/^    bool   noreply;   \/* True if the reply should not be sent. *\/$/;"	m	struct:conn	access:public
not_found	t/binary-extstore.t	/^sub not_found {$/;"	s
not_found	t/binary-sasl.t	/^sub not_found {$/;"	s
not_found	t/binary.t	/^sub not_found {$/;"	s
notify_event	memcached.h	/^    struct event notify_event;  \/* listen event for notify pipe  该线程用于监听管道读事件的event实例 *\/$/;"	m	struct:__anon54	typeref:struct:__anon54::event	access:public
notify_receive_fd	memcached.h	/^    int notify_receive_fd;      \/* receiving end of notify pipe  记录了管道的接收端fd *\/$/;"	m	struct:__anon54	access:public
notify_send_fd	memcached.h	/^    int notify_send_fd;         \/* sending end of notify pipe  记录了管道的发生端fd *\/$/;"	m	struct:__anon54	access:public
nsuffix	memcached.h	/^    uint8_t         nsuffix;    \/* length of flags-and-length string *\/$/;"	m	struct:__anon52	access:public
nsuffix	memcached.h	/^    uint8_t         nsuffix;    \/* length of flags-and-length string *\/$/;"	m	struct:_stritem	access:public
ntohll	util.c	/^uint64_t ntohll(uint64_t val) {$/;"	f	signature:(uint64_t val)
ntohll	util.h	/^extern uint64_t ntohll(uint64_t);$/;"	p	signature:(uint64_t)
num_deletes	stats.c	/^    uint64_t      num_deletes;$/;"	m	struct:_prefix_stats	file:	access:public
num_gets	stats.c	/^    uint64_t      num_gets;$/;"	m	struct:_prefix_stats	file:	access:public
num_hits	stats.c	/^    uint64_t      num_hits;$/;"	m	struct:_prefix_stats	file:	access:public
num_prefixes	stats.c	/^static int num_prefixes = 0;$/;"	v	file:
num_sets	stats.c	/^    uint64_t      num_sets;$/;"	m	struct:_prefix_stats	file:	access:public
num_threads	memcached.h	/^    int num_threads;        \/* number of worker (without dispatcher) libevent threads to run 工作线程数量(0<n<=64) *\/$/;"	m	struct:settings	access:public
num_threads_per_udp	memcached.h	/^    int num_threads_per_udp; \/* number of worker threads serving each udp socket *\/$/;"	m	struct:settings	access:public
nz_strcmp	slabs.c	/^static int nz_strcmp(int nzlength, const char *nz, const char *z) {$/;"	f	file:	signature:(int nzlength, const char *nz, const char *z)
obj_count	extstore.c	/^    uint64_t obj_count; \/* _delete can decrease post-closing *\/$/;"	m	struct:_store_page	file:	access:public
obj_io	extstore.h	/^typedef struct _obj_io obj_io;$/;"	t	typeref:struct:_obj_io
obj_io_cb	extstore.h	/^typedef void (*obj_io_cb)(void *e, obj_io *io, int ret);$/;"	t
obj_io_mode	extstore.h	/^enum obj_io_mode {$/;"	g
objects_evicted	extstore.h	/^    uint64_t objects_evicted;$/;"	m	struct:extstore_stats	access:public
objects_read	extstore.h	/^    uint64_t objects_read;$/;"	m	struct:extstore_stats	access:public
objects_used	extstore.h	/^    uint64_t objects_used; \/* total number of objects stored *\/$/;"	m	struct:extstore_stats	access:public
objects_written	extstore.h	/^    uint64_t objects_written;$/;"	m	struct:extstore_stats	access:public
offset	extstore.c	/^    uint64_t offset; \/* starting address of page within fd *\/$/;"	m	struct:_store_page	file:	access:public
offset	extstore.c	/^    unsigned int offset; \/* offset into page this write starts at *\/$/;"	m	struct:__store_wbuf	file:	access:public
offset	extstore.h	/^    unsigned int offset;  \/* for read mode *\/$/;"	m	struct:_obj_io	access:public
offset	memcached.h	/^        size_t offset;$/;"	m	struct:conn::__anon55	access:public
offset	memcached.h	/^    unsigned int offset; \/* from IO header *\/$/;"	m	struct:__anon53	access:public
old_hashtable	assoc.c	/^static item** old_hashtable = 0;$/;"	v	file:
oldest_cas	memcached.h	/^    uint64_t oldest_cas; \/* ignore existing items with CAS values lower than this *\/$/;"	m	struct:settings	access:public
oldest_live	memcached.h	/^    rel_time_t oldest_live; \/* ignore existing items older than this *\/$/;"	m	struct:settings	access:public
oldincludedir	doc/Makefile	/^oldincludedir = \/usr\/include$/;"	m
opaque	memcached.h	/^    int opaque;$/;"	m	struct:conn	access:public
opaque	protocol_binary.h	/^            uint32_t opaque;$/;"	m	struct:__anon11::__anon12	access:public
opaque	protocol_binary.h	/^            uint32_t opaque;$/;"	m	struct:__anon9::__anon10	access:public
opcode	protocol_binary.h	/^            uint8_t opcode;$/;"	m	struct:__anon11::__anon12	access:public
opcode	protocol_binary.h	/^            uint8_t opcode;$/;"	m	struct:__anon9::__anon10	access:public
orig_clsid	memcached.h	/^    uint8_t          orig_clsid; \/* For obj hdr chunks slabs_clsid is fake. *\/$/;"	m	struct:_strchunk	access:public
out1	itoa_ljust.c	/^static inline char* out1(const char in, char* p) {$/;"	f	file:	signature:(const char in, char* p)
out2	itoa_ljust.c	/^static inline char* out2(const int d, char* p) {$/;"	f	file:	signature:(const int d, char* p)
out_of_memory	memcached.c	/^static void out_of_memory(conn *c, char *ascii_error) {$/;"	f	file:	signature:(conn *c, char *ascii_error)
out_string	memcached.c	/^static void out_string(conn *c, const char *str) {$/;"	f	file:	signature:(conn *c, const char *str)
outofmemory	items.c	/^    uint64_t outofmemory;$/;"	m	struct:__anon45	file:	access:public
outofmemory	items.h	/^    int64_t outofmemory;$/;"	m	struct:__anon3	access:public
pad	logger.h	/^    uint8_t pad;$/;"	m	struct:_logentry	access:public
page_allocs	extstore.h	/^    uint64_t page_allocs;$/;"	m	struct:extstore_stats	access:public
page_bucketcount	extstore.c	/^    unsigned int page_bucketcount; \/* count of potential page buckets *\/$/;"	m	struct:store_engine	file:	access:public
page_buckets	extstore.c	/^    store_page **page_buckets; \/* stack of pages currently allocated to each bucket *\/$/;"	m	struct:store_engine	file:	access:public
page_buckets	extstore.h	/^    unsigned int page_buckets; \/\/ number of different writeable pages$/;"	m	struct:extstore_conf	access:public
page_count	extstore.c	/^    unsigned int page_count;$/;"	m	struct:store_engine	file:	access:public
page_count	extstore.h	/^    uint64_t page_count; \/* total page count *\/$/;"	m	struct:extstore_stats	access:public
page_count	extstore.h	/^    unsigned int page_count;$/;"	m	struct:extstore_conf	access:public
page_data	extstore.h	/^    struct extstore_page_data *page_data;$/;"	m	struct:extstore_stats	typeref:struct:extstore_stats::extstore_page_data	access:public
page_evictions	extstore.h	/^    uint64_t page_evictions;$/;"	m	struct:extstore_stats	access:public
page_free	extstore.c	/^    unsigned int page_free; \/* unallocated pages *\/$/;"	m	struct:store_engine	file:	access:public
page_freelist	extstore.c	/^    store_page *page_freelist;$/;"	m	struct:store_engine	file:	access:public
page_id	extstore.h	/^    unsigned short page_id; \/* for read mode *\/$/;"	m	struct:_obj_io	access:public
page_id	memcached.h	/^    unsigned short page_id; \/* from IO header *\/$/;"	m	struct:__anon53	access:public
page_reclaims	extstore.h	/^    uint64_t page_reclaims;$/;"	m	struct:extstore_stats	access:public
page_size	extstore.c	/^    size_t page_size;$/;"	m	struct:store_engine	file:	access:public
page_size	extstore.h	/^    uint64_t page_size; \/* size in bytes per page (supplied by caller) *\/$/;"	m	struct:extstore_stats	access:public
page_size	extstore.h	/^    unsigned int page_size; \/\/ ideally 64-256M in size$/;"	m	struct:extstore_conf	access:public
page_version	extstore.h	/^    unsigned int page_version;     \/* page version for read mode *\/$/;"	m	struct:_obj_io	access:public
page_version	memcached.h	/^    unsigned int page_version; \/* from IO header *\/$/;"	m	struct:__anon53	access:public
pages	extstore.c	/^    store_page *pages; \/* directly addressable page list *\/$/;"	m	struct:store_engine	file:	access:public
pages_free	extstore.h	/^    uint64_t pages_free; \/* currently unallocated\/unused pages *\/$/;"	m	struct:extstore_stats	access:public
pages_used	extstore.h	/^    uint64_t pages_used;$/;"	m	struct:extstore_stats	access:public
pause_thread_types	memcached.h	/^enum pause_thread_types {$/;"	g
pause_threads	memcached.h	/^void pause_threads(enum pause_thread_types type);$/;"	p	signature:(enum pause_thread_types type)
pause_threads	thread.c	/^void pause_threads(enum pause_thread_types type) {$/;"	f	signature:(enum pause_thread_types type)
pdfdir	doc/Makefile	/^pdfdir = ${docdir}$/;"	m
perslab	slabs.c	/^    unsigned int perslab;   \/* how many items per slab *\/$/;"	m	struct:__anon1	file:	access:public
pkgdatadir	doc/Makefile	/^pkgdatadir = $(datadir)\/memcached$/;"	m
pkgincludedir	doc/Makefile	/^pkgincludedir = $(includedir)\/memcached$/;"	m
pkglibdir	doc/Makefile	/^pkglibdir = $(libdir)\/memcached$/;"	m
pkglibexecdir	doc/Makefile	/^pkglibexecdir = $(libexecdir)\/memcached$/;"	m
pool_filled_once	slab_automove_extstore.c	/^    bool pool_filled_once;$/;"	m	struct:__anon56	file:	access:public
pool_high	slab_automove_extstore.c	/^    uint32_t pool_high;$/;"	m	struct:window_global	file:	access:public
pool_low	slab_automove_extstore.c	/^    uint32_t pool_low;$/;"	m	struct:window_global	file:	access:public
port	memcached.h	/^    int port;$/;"	m	struct:settings	access:public
port	t/lib/MemcachedTest.pm	/^sub port { $_[0]{port} }$/;"	s
port	testapp.c	/^static in_port_t port;$/;"	v	file:
power_largest	slabs.c	/^static int power_largest;$/;"	v	file:
prefix	doc/Makefile	/^prefix = \/usr\/local$/;"	m
prefix	stats.c	/^    char         *prefix;$/;"	m	struct:_prefix_stats	file:	access:public
prefix_delimiter	memcached.h	/^    char prefix_delimiter;  \/* character that marks a key prefix (for stats) *\/$/;"	m	struct:settings	access:public
prefix_len	stats.c	/^    size_t        prefix_len;$/;"	m	struct:_prefix_stats	file:	access:public
prefix_stats	stats.c	/^static PREFIX_STATS *prefix_stats[PREFIX_HASH_SIZE];$/;"	v	file:
prev	items.c	/^    struct _lru_bump_buf *prev;$/;"	m	struct:_lru_bump_buf	typeref:struct:_lru_bump_buf::_lru_bump_buf	file:	access:public
prev	logger.h	/^    struct _logger *prev;$/;"	m	struct:_logger	typeref:struct:_logger::_logger	access:public
prev	memcached.h	/^    struct _strchunk *prev;     \/* can potentially point to the head. *\/$/;"	m	struct:_strchunk	typeref:struct:_strchunk::_strchunk	access:public
prev	memcached.h	/^    struct _stritem *prev;$/;"	m	struct:__anon52	typeref:struct:__anon52::_stritem	access:public
prev	memcached.h	/^    struct _stritem *prev;$/;"	m	struct:_stritem	typeref:struct:_stritem::_stritem	access:public
primary_hashtable	assoc.c	/^static item** primary_hashtable = 0;$/;"	v	file:
process_arithmetic_command	memcached.c	/^static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {$/;"	f	file:	signature:(conn *c, token_t *tokens, const size_t ntokens, const bool incr)
process_bin_append_prepend	memcached.c	/^static void process_bin_append_prepend(conn *c) {$/;"	f	file:	signature:(conn *c)
process_bin_complete_sasl_auth	memcached.c	/^static void process_bin_complete_sasl_auth(conn *c) {$/;"	f	file:	signature:(conn *c)
process_bin_delete	memcached.c	/^static void process_bin_delete(conn *c) {$/;"	f	file:	signature:(conn *c)
process_bin_flush	memcached.c	/^static void process_bin_flush(conn *c) {$/;"	f	file:	signature:(conn *c)
process_bin_get_or_touch	memcached.c	/^static void process_bin_get_or_touch(conn *c) {$/;"	f	file:	signature:(conn *c)
process_bin_sasl_auth	memcached.c	/^static void process_bin_sasl_auth(conn *c) {$/;"	f	file:	signature:(conn *c)
process_bin_stat	memcached.c	/^static void process_bin_stat(conn *c) {$/;"	f	file:	signature:(conn *c)
process_bin_update	memcached.c	/^static void process_bin_update(conn *c) {$/;"	f	file:	signature:(conn *c)
process_command	memcached.c	/^static void process_command(conn *c, char *command) {$/;"	f	file:	signature:(conn *c, char *command)
process_command	memcached.c	/^static void process_command(conn *c, char *command);$/;"	p	file:	signature:(conn *c, char *command)
process_delete_command	memcached.c	/^static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {$/;"	f	file:	signature:(conn *c, token_t *tokens, const size_t ntokens)
process_extstore_command	memcached.c	/^static void process_extstore_command(conn *c, token_t *tokens, const size_t ntokens) {$/;"	f	file:	signature:(conn *c, token_t *tokens, const size_t ntokens)
process_extstore_stats	memcached.c	/^static void process_extstore_stats(ADD_STAT add_stats, conn *c) {$/;"	f	file:	signature:(ADD_STAT add_stats, conn *c)
process_get_command	memcached.c	/^static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {$/;"	f	file:	signature:(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch)
process_lru_command	memcached.c	/^static void process_lru_command(conn *c, token_t *tokens, const size_t ntokens) {$/;"	f	file:	signature:(conn *c, token_t *tokens, const size_t ntokens)
process_memlimit_command	memcached.c	/^static void process_memlimit_command(conn *c, token_t *tokens, const size_t ntokens) {$/;"	f	file:	signature:(conn *c, token_t *tokens, const size_t ntokens)
process_misbehave_command	memcached.c	/^static void process_misbehave_command(conn *c) {$/;"	f	file:	signature:(conn *c)
process_slabs_automove_command	memcached.c	/^static void process_slabs_automove_command(conn *c, token_t *tokens, const size_t ntokens) {$/;"	f	file:	signature:(conn *c, token_t *tokens, const size_t ntokens)
process_started	memcached.c	/^time_t process_started;     \/* when the process was started  进程启动时间(墙上时间加偏移量得到) *\/$/;"	v
process_stat	memcached.c	/^static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {$/;"	f	file:	signature:(conn *c, token_t *tokens, const size_t ntokens)
process_stat_settings	memcached.c	/^static void process_stat_settings(ADD_STAT add_stats, void *c) {$/;"	f	file:	signature:(ADD_STAT add_stats, void *c)
process_stat_settings	memcached.c	/^static void process_stat_settings(ADD_STAT add_stats, void *c);$/;"	p	file:	signature:(ADD_STAT add_stats, void *c)
process_stats_conns	memcached.c	/^static void process_stats_conns(ADD_STAT add_stats, void *c) {$/;"	f	file:	signature:(ADD_STAT add_stats, void *c)
process_stats_detail	memcached.c	/^inline static void process_stats_detail(conn *c, const char *command) {$/;"	f	file:	signature:(conn *c, const char *command)
process_touch_command	memcached.c	/^static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {$/;"	f	file:	signature:(conn *c, token_t *tokens, const size_t ntokens)
process_update_command	memcached.c	/^static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {$/;"	f	file:	signature:(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas)
process_verbosity_command	memcached.c	/^static void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {$/;"	f	file:	signature:(conn *c, token_t *tokens, const size_t ntokens)
process_watch_command	memcached.c	/^static void process_watch_command(conn *c, token_t *tokens, const size_t ntokens) {$/;"	f	file:	signature:(conn *c, token_t *tokens, const size_t ntokens)
program_details	missing	/^program_details ()$/;"	f
program_transform_name	doc/Makefile	/^program_transform_name = s,x,x,$/;"	m
prot_text	memcached.c	/^static const char *prot_text(enum protocol prot) {$/;"	f	file:	signature:(enum protocol prot)
protocol	memcached.h	/^    enum protocol protocol;   \/* which protocol this connection speaks  该连接session使用的数据格式 *\/$/;"	m	struct:conn	typeref:enum:conn::protocol	access:public
protocol	memcached.h	/^enum protocol {$/;"	g
protocol_binary_command	protocol_binary.h	/^    } protocol_binary_command;$/;"	t	typeref:enum:__anon7
protocol_binary_datatypes	protocol_binary.h	/^    } protocol_binary_datatypes;$/;"	t	typeref:enum:__anon8
protocol_binary_magic	protocol_binary.h	/^    } protocol_binary_magic;$/;"	t	typeref:enum:__anon5
protocol_binary_request_add	protocol_binary.h	/^    typedef protocol_binary_request_set protocol_binary_request_add;$/;"	t
protocol_binary_request_append	protocol_binary.h	/^    typedef protocol_binary_request_no_extras protocol_binary_request_append;$/;"	t
protocol_binary_request_decr	protocol_binary.h	/^    typedef protocol_binary_request_incr protocol_binary_request_decr;$/;"	t
protocol_binary_request_delete	protocol_binary.h	/^    typedef protocol_binary_request_no_extras protocol_binary_request_delete;$/;"	t
protocol_binary_request_flush	protocol_binary.h	/^    } protocol_binary_request_flush;$/;"	t	typeref:union:__anon20
protocol_binary_request_gat	protocol_binary.h	/^    } protocol_binary_request_gat;$/;"	t	typeref:union:__anon35
protocol_binary_request_gatk	protocol_binary.h	/^    typedef protocol_binary_request_gat protocol_binary_request_gatk;$/;"	t
protocol_binary_request_gatkq	protocol_binary.h	/^    typedef protocol_binary_request_gat protocol_binary_request_gatkq;$/;"	t
protocol_binary_request_gatq	protocol_binary.h	/^    typedef protocol_binary_request_gat protocol_binary_request_gatq;$/;"	t
protocol_binary_request_get	protocol_binary.h	/^    typedef protocol_binary_request_no_extras protocol_binary_request_get;$/;"	t
protocol_binary_request_getk	protocol_binary.h	/^    typedef protocol_binary_request_no_extras protocol_binary_request_getk;$/;"	t
protocol_binary_request_getkq	protocol_binary.h	/^    typedef protocol_binary_request_no_extras protocol_binary_request_getkq;$/;"	t
protocol_binary_request_getq	protocol_binary.h	/^    typedef protocol_binary_request_no_extras protocol_binary_request_getq;$/;"	t
protocol_binary_request_header	protocol_binary.h	/^    } protocol_binary_request_header;$/;"	t	typeref:union:__anon9
protocol_binary_request_incr	protocol_binary.h	/^    } protocol_binary_request_incr;$/;"	t	typeref:union:__anon26
protocol_binary_request_no_extras	protocol_binary.h	/^    } protocol_binary_request_no_extras;$/;"	t	typeref:union:__anon13
protocol_binary_request_noop	protocol_binary.h	/^    typedef protocol_binary_request_no_extras protocol_binary_request_noop;$/;"	t
protocol_binary_request_prepend	protocol_binary.h	/^    typedef protocol_binary_request_no_extras protocol_binary_request_prepend;$/;"	t
protocol_binary_request_quit	protocol_binary.h	/^    typedef protocol_binary_request_no_extras protocol_binary_request_quit;$/;"	t
protocol_binary_request_rangeop	protocol_binary.h	/^    } protocol_binary_request_rangeop;$/;"	t	typeref:union:__anon38
protocol_binary_request_rappend	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rappend;$/;"	t
protocol_binary_request_rappendq	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rappendq;$/;"	t
protocol_binary_request_rdecr	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rdecr;$/;"	t
protocol_binary_request_rdecrq	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rdecrq;$/;"	t
protocol_binary_request_rdelete	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rdelete;$/;"	t
protocol_binary_request_rdeleteq	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rdeleteq;$/;"	t
protocol_binary_request_replace	protocol_binary.h	/^    typedef protocol_binary_request_set protocol_binary_request_replace;$/;"	t
protocol_binary_request_rget	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rget;$/;"	t
protocol_binary_request_rincr	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rincr;$/;"	t
protocol_binary_request_rincrq	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rincrq;$/;"	t
protocol_binary_request_rprepend	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rprepend;$/;"	t
protocol_binary_request_rprependq	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rprependq;$/;"	t
protocol_binary_request_rset	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rset;$/;"	t
protocol_binary_request_rsetq	protocol_binary.h	/^    typedef protocol_binary_request_rangeop protocol_binary_request_rsetq;$/;"	t
protocol_binary_request_set	protocol_binary.h	/^    } protocol_binary_request_set;$/;"	t	typeref:union:__anon23
protocol_binary_request_stats	protocol_binary.h	/^    typedef protocol_binary_request_no_extras protocol_binary_request_stats;$/;"	t
protocol_binary_request_touch	protocol_binary.h	/^    } protocol_binary_request_touch;$/;"	t	typeref:union:__anon32
protocol_binary_request_version	protocol_binary.h	/^    typedef protocol_binary_request_no_extras protocol_binary_request_version;$/;"	t
protocol_binary_response_add	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_add;$/;"	t
protocol_binary_response_append	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_append;$/;"	t
protocol_binary_response_decr	protocol_binary.h	/^    typedef protocol_binary_response_incr protocol_binary_response_decr;$/;"	t
protocol_binary_response_delete	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_delete;$/;"	t
protocol_binary_response_flush	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_flush;$/;"	t
protocol_binary_response_gat	protocol_binary.h	/^    typedef protocol_binary_response_get protocol_binary_response_gat;$/;"	t
protocol_binary_response_gatk	protocol_binary.h	/^    typedef protocol_binary_response_get protocol_binary_response_gatk;$/;"	t
protocol_binary_response_gatkq	protocol_binary.h	/^    typedef protocol_binary_response_get protocol_binary_response_gatkq;$/;"	t
protocol_binary_response_gatq	protocol_binary.h	/^    typedef protocol_binary_response_get protocol_binary_response_gatq;$/;"	t
protocol_binary_response_get	protocol_binary.h	/^    } protocol_binary_response_get;$/;"	t	typeref:union:__anon17
protocol_binary_response_getk	protocol_binary.h	/^    typedef protocol_binary_response_get protocol_binary_response_getk;$/;"	t
protocol_binary_response_getkq	protocol_binary.h	/^    typedef protocol_binary_response_get protocol_binary_response_getkq;$/;"	t
protocol_binary_response_getq	protocol_binary.h	/^    typedef protocol_binary_response_get protocol_binary_response_getq;$/;"	t
protocol_binary_response_header	protocol_binary.h	/^    } protocol_binary_response_header;$/;"	t	typeref:union:__anon11
protocol_binary_response_incr	protocol_binary.h	/^    } protocol_binary_response_incr;$/;"	t	typeref:union:__anon29
protocol_binary_response_no_extras	protocol_binary.h	/^    } protocol_binary_response_no_extras;$/;"	t	typeref:union:__anon15
protocol_binary_response_noop	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_noop;$/;"	t
protocol_binary_response_prepend	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_prepend;$/;"	t
protocol_binary_response_quit	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_quit;$/;"	t
protocol_binary_response_replace	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_replace;$/;"	t
protocol_binary_response_set	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_set;$/;"	t
protocol_binary_response_stats	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_stats;$/;"	t
protocol_binary_response_status	protocol_binary.h	/^    } protocol_binary_response_status;$/;"	t	typeref:enum:__anon6
protocol_binary_response_touch	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_touch;$/;"	t
protocol_binary_response_version	protocol_binary.h	/^    typedef protocol_binary_response_no_extras protocol_binary_response_version;$/;"	t
prototypes	configure	/^   function prototypes and stuff, but not '\\xHH' hex character constants.$/;"	f
psdir	doc/Makefile	/^psdir = ${docdir}$/;"	m
ptr	cache.h	/^    void **ptr;$/;"	m	struct:__anon41	access:public
queue	extstore.c	/^    obj_io *queue;$/;"	m	struct:__anon43	file:	access:public
queue_new_conn	thread.c	/^    queue_new_conn,   \/* brand new connection. *\/$/;"	e	enum:conn_queue_item_modes	file:
queue_redispatch	thread.c	/^    queue_redispatch, \/* redispatching from side thread *\/$/;"	e	enum:conn_queue_item_modes	file:
raw_command	testapp.c	/^static off_t raw_command(char* buf,$/;"	f	file:	signature:(char* buf, size_t bufsz, uint8_t cmd, const void* key, size_t keylen, const void* dta, size_t dtalen)
rbuf	memcached.h	/^    char   *rbuf;   \/** buffer to read commands into  指向一片读缓冲区 *\/$/;"	m	struct:conn	access:public
rbytes	memcached.h	/^    int    rbytes;  \/** how much data, starting from rcur, do we have unparsed  读缓冲区中尚未读取的数据长度 *\/$/;"	m	struct:conn	access:public
rcurr	memcached.h	/^    char   *rcurr;  \/** but if we parsed some already, this is where we stopped  读指针 *\/$/;"	m	struct:conn	access:public
read_ascii_response	testapp.c	/^static void read_ascii_response(char *buffer, size_t size) {$/;"	f	file:	signature:(char *buffer, size_t size)
read_buffer_size	thread.c	/^    int               read_buffer_size;$/;"	m	struct:conn_queue_item	file:	access:public
read_into_chunked_item	memcached.c	/^static int read_into_chunked_item(conn *c) {$/;"	f	file:	signature:(conn *c)
realtime	memcached.c	/^static rel_time_t realtime(const time_t exptime) {$/;"	f	file:	signature:(const time_t exptime)
reassign_result_type	slabs.h	/^enum reassign_result_type {$/;"	g
rebalance_tid	slabs.c	/^static pthread_t rebalance_tid;$/;"	v	file:
recache_counter	memcached.h	/^    unsigned int recache_counter;$/;"	m	struct:conn	access:public
recache_or_free	memcached.c	/^static void recache_or_free(conn *c, io_wrap *wrap) {$/;"	f	file:	signature:(conn *c, io_wrap *wrap)
reclaimed	crawler.h	/^    uint64_t reclaimed;$/;"	m	struct:__anon4	access:public
reclaimed	items.c	/^    uint64_t reclaimed;$/;"	m	struct:__anon45	file:	access:public
reclaimed	memcached.h	/^    uint64_t        reclaimed;  \/* items reclaimed during this crawl. *\/$/;"	m	struct:__anon52	access:public
redispatch_conn	memcached.h	/^void redispatch_conn(conn *c);$/;"	p	signature:(conn *c)
redispatch_conn	thread.c	/^void redispatch_conn(conn *c) {$/;"	f	signature:(conn *c)
redzone_pattern	cache.c	/^const uint64_t redzone_pattern = 0xdeadbeefcafebabe;$/;"	v
refcount	extstore.c	/^    unsigned int refcount;$/;"	m	struct:_store_page	file:	access:public
refcount	memcached.h	/^    unsigned short   refcount;  \/* used? *\/$/;"	m	struct:_strchunk	access:public
refcount	memcached.h	/^    unsigned short  refcount;$/;"	m	struct:__anon52	access:public
refcount	memcached.h	/^    unsigned short  refcount;$/;"	m	struct:_stritem	access:public
refcount_decr	memcached.h	747;"	d
refcount_incr	memcached.h	746;"	d
register_thread_initialized	thread.c	/^static void register_thread_initialized(void) {$/;"	f	file:	signature:(void)
rejected_conns	memcached.h	/^    uint64_t      rejected_conns;$/;"	m	struct:stats	access:public
rel_time_t	logger.h	/^typedef unsigned int rel_time_t;$/;"	t
relaxed	slab_automove_extstore.c	/^    unsigned int relaxed;$/;"	m	struct:window_data	file:	access:public
relaxed_privileges	memcached.h	/^    bool relaxed_privileges;   \/* Relax process restrictions when running testapp *\/$/;"	m	struct:settings	access:public
remaining	memcached.h	/^    uint32_t        remaining;  \/* Max keys to crawl per slab per invocation *\/$/;"	m	struct:__anon52	access:public
remove_pidfile	memcached.c	/^static void remove_pidfile(const char *pid_file) {$/;"	f	file:	signature:(const char *pid_file)
reopen_logfile	scripts/start-memcached	/^sub reopen_logfile$/;"	s
replace	t/binary-extstore.t	/^sub replace {$/;"	s
replace	t/binary-sasl.t	/^sub replace {$/;"	s
replace	t/binary.t	/^sub replace {$/;"	s
reqlen	logger.h	/^    int reqlen;$/;"	m	struct:__anon57	access:public
reqs_per_event	memcached.h	/^    int reqs_per_event;     \/* Maximum number of io to process on each$/;"	m	struct:settings	access:public
request	protocol_binary.h	/^        } request;$/;"	m	union:__anon9	typeref:struct:__anon9::__anon10	access:public
request_addr	memcached.h	/^    struct sockaddr_in6 request_addr; \/* udp: Who sent the most recent request  记录对端地址 *\/$/;"	m	struct:conn	typeref:struct:conn::sockaddr_in6	access:public
request_addr_size	memcached.h	/^    socklen_t request_addr_size;    \/\/ 记录对端地址长度$/;"	m	struct:conn	access:public
request_id	memcached.h	/^    int    request_id; \/* Incoming UDP request ID, if this is a UDP "connection" *\/$/;"	m	struct:conn	access:public
requested	slabs.c	/^    size_t requested; \/* The number of requested bytes *\/$/;"	m	struct:__anon1	file:	access:public
rescues	memcached.h	/^    uint32_t rescues;$/;"	m	struct:slab_rebalance	access:public
reserved	protocol_binary.h	/^                uint8_t  reserved;$/;"	m	struct:__anon38::__anon39::__anon40	access:public
reserved	protocol_binary.h	/^            uint16_t reserved;$/;"	m	struct:__anon9::__anon10	access:public
reserved_fds	memcached.h	/^    unsigned int  reserved_fds;     \/\/ 记录了保留的fd数量$/;"	m	struct:stats_state	access:public
reset_cmd_handler	memcached.c	/^static void reset_cmd_handler(conn *c) {$/;"	f	file:	signature:(conn *c)
response	protocol_binary.h	/^        } response;$/;"	m	union:__anon11	typeref:struct:__anon11::__anon12	access:public
restart	scripts/memcached.sysv	/^restart () {$/;"	f
ritem	memcached.h	/^    char   *ritem;  \/** when we read in an item's value, it goes here *\/$/;"	m	struct:conn	access:public
rlbytes	memcached.h	/^    int    rlbytes;$/;"	m	struct:conn	access:public
rot	jenkins_hash.c	33;"	d	file:
rotl32	murmur3_hash.c	/^static inline uint32_t rotl32 ( uint32_t x, int8_t r )$/;"	f	file:	signature:( uint32_t x, int8_t r )
rsize	memcached.h	/^    int    rsize;   \/** total allocated size of rbuf  读缓冲区长度 *\/$/;"	m	struct:conn	access:public
run	slab_automove.h	/^    slab_automove_run_func run;$/;"	m	struct:__anon2	access:public
run_complete	crawler.h	/^    bool run_complete;$/;"	m	struct:__anon4	access:public
run_test	stats.c	/^static void run_test(char *what, void (*func)(void)) {$/;"	f	file:	signature:(char *what, void (*func)(void))
runstatedir	doc/Makefile	/^runstatedir = ${localstatedir}\/run$/;"	m
s_clsid	memcached.h	/^    int s_clsid;$/;"	m	struct:slab_rebalance	access:public
safe_recv	testapp.c	/^static bool safe_recv(void *buf, size_t len) {$/;"	f	file:	signature:(void *buf, size_t len)
safe_recv_packet	testapp.c	/^static bool safe_recv_packet(void *buf, size_t size) {$/;"	f	file:	signature:(void *buf, size_t size)
safe_send	testapp.c	/^static void safe_send(const void* buf, size_t len, bool hickup)$/;"	f	file:	signature:(const void* buf, size_t len, bool hickup)
safe_strtod	util.c	/^bool safe_strtod(const char *str, double *out) {$/;"	f	signature:(const char *str, double *out)
safe_strtod	util.h	/^bool safe_strtod(const char *str, double *out);$/;"	p	signature:(const char *str, double *out)
safe_strtol	util.c	/^bool safe_strtol(const char *str, int32_t *out) {$/;"	f	signature:(const char *str, int32_t *out)
safe_strtol	util.h	/^bool safe_strtol(const char *str, int32_t *out);$/;"	p	signature:(const char *str, int32_t *out)
safe_strtoll	util.c	/^bool safe_strtoll(const char *str, int64_t *out) {$/;"	f	signature:(const char *str, int64_t *out)
safe_strtoll	util.h	/^bool safe_strtoll(const char *str, int64_t *out);$/;"	p	signature:(const char *str, int64_t *out)
safe_strtoul	util.c	/^bool safe_strtoul(const char *str, uint32_t *out) {$/;"	f	signature:(const char *str, uint32_t *out)
safe_strtoul	util.h	/^bool safe_strtoul(const char *str, uint32_t *out);$/;"	p	signature:(const char *str, uint32_t *out)
safe_strtoull	util.c	/^bool safe_strtoull(const char *str, uint64_t *out) {$/;"	f	signature:(const char *str, uint64_t *out)
safe_strtoull	util.h	/^bool safe_strtoull(const char *str, uint64_t *out);$/;"	p	signature:(const char *str, uint64_t *out)
sam_after	slab_automove.c	/^    slab_stats_automove sam_after[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon48	file:	access:public
sam_after	slab_automove_extstore.c	/^    slab_stats_automove sam_after[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon56	file:	access:public
sam_before	slab_automove.c	/^    slab_stats_automove sam_before[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon48	file:	access:public
sam_before	slab_automove_extstore.c	/^    slab_stats_automove sam_before[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:__anon56	file:	access:public
sanitycheck	memcached.c	/^static bool sanitycheck(void) {$/;"	f	file:	signature:(void)
sasl	memcached.h	/^    bool sasl;              \/* SASL on\/off 标识是否开启sasl功能,默认关闭 *\/$/;"	m	struct:settings	access:public
sasl_callback_ft	sasl_defs.c	/^typedef int (*sasl_callback_ft)(void);$/;"	t	file:
sasl_callbacks	sasl_defs.c	/^static sasl_callback_t sasl_callbacks[] = {$/;"	v	file:
sasl_conn	memcached.h	/^    sasl_conn_t *sasl_conn;$/;"	m	struct:conn	access:public
sasl_conn_t	sasl_defs.h	/^typedef void* sasl_conn_t;$/;"	t
sasl_dispose	sasl_defs.h	19;"	d
sasl_getconf	sasl_defs.c	/^static int sasl_getconf(void *context, const char **path)$/;"	f	file:	signature:(void *context, const char **path)
sasl_getprop	sasl_defs.h	24;"	d
sasl_listmech	sasl_defs.h	21;"	d
sasl_log	sasl_defs.c	/^static int sasl_log(void *context, int level, const char *message)$/;"	f	file:	signature:(void *context, int level, const char *message)
sasl_server_new	sasl_defs.h	20;"	d
sasl_server_start	sasl_defs.h	22;"	d
sasl_server_step	sasl_defs.h	23;"	d
sasl_server_userdb_checkpass	sasl_defs.c	/^static int sasl_server_userdb_checkpass(sasl_conn_t *conn,$/;"	f	file:	signature:(sasl_conn_t *conn, void *context, const char *user, const char *pass, unsigned passlen, struct propctx *propctx)
save_pid	memcached.c	/^static void save_pid(const char *pid_file) {$/;"	f	file:	signature:(const char *pid_file)
sbindir	doc/Makefile	/^sbindir = ${exec_prefix}\/sbin$/;"	m
sbytes	memcached.h	/^    int    sbytes;    \/* how many bytes to swallow *\/$/;"	m	struct:conn	access:public
seen	crawler.h	/^    uint64_t seen;$/;"	m	struct:__anon4	access:public
send_ascii_command	testapp.c	/^static void send_ascii_command(const char *buf) {$/;"	f	file:	signature:(const char *buf)
send_command	t/binary-extstore.t	/^sub send_command {$/;"	s
send_command	t/binary-sasl.t	/^sub send_command {$/;"	s
send_command	t/binary.t	/^sub send_command {$/;"	s
send_silent	t/binary-extstore.t	/^sub send_silent {$/;"	s
send_silent	t/binary-sasl.t	/^sub send_silent {$/;"	s
send_silent	t/binary.t	/^sub send_silent {$/;"	s
send_udp_request	t/udp.t	/^sub send_udp_request {$/;"	s
server_connect	scripts/memcached-tool	/^sub server_connect {$/;"	s
server_pid	testapp.c	/^static pid_t server_pid;$/;"	v	file:
server_socket	memcached.c	/^static int server_socket(const char *interface,$/;"	f	file:	signature:(const char *interface, int port, enum network_transport transport, FILE *portnumber_file)
server_socket_unix	memcached.c	/^static int server_socket_unix(const char *path, int access_mask) {$/;"	f	file:	signature:(const char *path, int access_mask)
server_sockets	memcached.c	/^static int server_sockets(int port, enum network_transport transport,$/;"	f	file:	signature:(int port, enum network_transport transport, FILE *portnumber_file)
server_stats	memcached.c	/^static void server_stats(ADD_STAT add_stats, conn *c) {$/;"	f	file:	signature:(ADD_STAT add_stats, conn *c)
server_stats	memcached.c	/^static void server_stats(ADD_STAT add_stats, conn *c);$/;"	p	file:	signature:(ADD_STAT add_stats, conn *c)
set	t/binary-extstore.t	/^sub set {$/;"	s
set	t/binary-sasl.t	/^sub set {$/;"	s
set	t/binary.t	/^sub set {$/;"	s
set_base_from	depcomp	/^set_base_from ()$/;"	f
set_dir_from	depcomp	/^set_dir_from ()$/;"	f
set_noreply_maybe	memcached.c	/^static inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)$/;"	f	file:	signature:(conn *c, token_t *tokens, size_t ntokens)
settings	memcached.c	/^struct settings settings;   \/\/ 定义了一个源自命令行的全局可访问的配置集合$/;"	v	typeref:struct:settings
settings	memcached.h	/^struct settings {$/;"	s
settings	slab_automove_extstore.c	/^    struct settings *settings;$/;"	m	struct:__anon56	typeref:struct:__anon56::settings	file:	access:public
settings	stats.c	/^struct settings settings;$/;"	v	typeref:struct:settings
settings::access	memcached.h	/^    int access;  \/* access mask (a la chmod) for unix domain socket *\/$/;"	m	struct:settings	access:public
settings::backlog	memcached.h	/^    int backlog;$/;"	m	struct:settings	access:public
settings::binding_protocol	memcached.h	/^    enum protocol binding_protocol; \/\/ sasl功能关联的协议类型$/;"	m	struct:settings	typeref:enum:settings::protocol	access:public
settings::chunk_size	memcached.h	/^    int chunk_size;$/;"	m	struct:settings	access:public
settings::crawls_persleep	memcached.h	/^    int crawls_persleep; \/* Number of LRU crawls to run before sleeping *\/$/;"	m	struct:settings	access:public
settings::detail_enabled	memcached.h	/^    int detail_enabled;     \/* nonzero if we're collecting detailed stats *\/$/;"	m	struct:settings	access:public
settings::drop_privileges	memcached.h	/^    bool drop_privileges;   \/* Whether or not to drop unnecessary process privileges  标识是否需要丢弃多余的进程权限 *\/$/;"	m	struct:settings	access:public
settings::dump_enabled	memcached.h	/^    bool dump_enabled;      \/* whether cachedump\/metadump commands work *\/$/;"	m	struct:settings	access:public
settings::evict_to_free	memcached.h	/^    int evict_to_free;$/;"	m	struct:settings	access:public
settings::ext_compact_under	memcached.h	/^    unsigned int ext_compact_under; \/* when fewer than this many pages, compact *\/$/;"	m	struct:settings	access:public
settings::ext_drop_under	memcached.h	/^    unsigned int ext_drop_under; \/* when fewer than this many pages, drop COLD items *\/$/;"	m	struct:settings	access:public
settings::ext_drop_unread	memcached.h	/^    bool ext_drop_unread; \/* skip unread items during compaction *\/$/;"	m	struct:settings	access:public
settings::ext_free_memchunks	memcached.h	/^    unsigned int ext_free_memchunks[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:settings	access:public
settings::ext_item_age	memcached.h	/^    unsigned int ext_item_age; \/* max age of tail item before storing ext. *\/$/;"	m	struct:settings	access:public
settings::ext_item_size	memcached.h	/^    unsigned int ext_item_size; \/* minimum size of items to store externally *\/$/;"	m	struct:settings	access:public
settings::ext_low_ttl	memcached.h	/^    unsigned int ext_low_ttl; \/* remaining TTL below this uses own pages *\/$/;"	m	struct:settings	access:public
settings::ext_max_frag	memcached.h	/^    double ext_max_frag; \/* ideal maximum page fragmentation *\/$/;"	m	struct:settings	access:public
settings::ext_recache_rate	memcached.h	/^    unsigned int ext_recache_rate; \/* counter++ % recache_rate == 0 > recache *\/$/;"	m	struct:settings	access:public
settings::ext_wbuf_size	memcached.h	/^    unsigned int ext_wbuf_size; \/* read only note for the engine *\/$/;"	m	struct:settings	access:public
settings::factor	memcached.h	/^    double factor;          \/* chunk size growth factor *\/$/;"	m	struct:settings	access:public
settings::flush_enabled	memcached.h	/^    bool flush_enabled;     \/* flush_all enabled *\/$/;"	m	struct:settings	access:public
settings::hash_algorithm	memcached.h	/^    char *hash_algorithm;     \/* Hash algorithm in use 记录了程序使用的hash算法名 *\/$/;"	m	struct:settings	access:public
settings::hashpower_init	memcached.h	/^    int hashpower_init;     \/* Starting hash power level *\/$/;"	m	struct:settings	access:public
settings::hot_lru_pct	memcached.h	/^    int hot_lru_pct; \/* percentage of slab space for HOT_LRU *\/$/;"	m	struct:settings	access:public
settings::hot_max_factor	memcached.h	/^    double hot_max_factor; \/* HOT tail age relative to COLD tail *\/$/;"	m	struct:settings	access:public
settings::idle_timeout	memcached.h	/^    int idle_timeout;       \/* Number of seconds to let connections idle *\/$/;"	m	struct:settings	access:public
settings::inline_ascii_response	memcached.h	/^    bool inline_ascii_response; \/* pre-format the VALUE line for ASCII responses *\/$/;"	m	struct:settings	access:public
settings::inter	memcached.h	/^    char *inter;$/;"	m	struct:settings	access:public
settings::item_size_max	memcached.h	/^    int item_size_max;        \/* Maximum item size *\/$/;"	m	struct:settings	access:public
settings::logger_buf_size	memcached.h	/^    unsigned int logger_buf_size; \/* size of per-thread logger buffer *\/$/;"	m	struct:settings	access:public
settings::logger_watcher_buf_size	memcached.h	/^    unsigned int logger_watcher_buf_size; \/* size of logger's per-watcher buffer *\/$/;"	m	struct:settings	access:public
settings::lru_crawler	memcached.h	/^    bool lru_crawler;        \/* Whether or not to enable the autocrawler thread 标识是否已经使能LRU自动爬虫线程 *\/$/;"	m	struct:settings	access:public
settings::lru_crawler_sleep	memcached.h	/^    int lru_crawler_sleep;  \/* Microsecond sleep between items *\/$/;"	m	struct:settings	access:public
settings::lru_crawler_tocrawl	memcached.h	/^    uint32_t lru_crawler_tocrawl; \/* Number of items to crawl per run *\/$/;"	m	struct:settings	access:public
settings::lru_maintainer_thread	memcached.h	/^    bool lru_maintainer_thread; \/* LRU maintainer background thread *\/$/;"	m	struct:settings	access:public
settings::lru_segmented	memcached.h	/^    bool lru_segmented;     \/* Use split or flat LRU's *\/$/;"	m	struct:settings	access:public
settings::maxbytes	memcached.h	/^    size_t maxbytes;$/;"	m	struct:settings	access:public
settings::maxconns	memcached.h	/^    int maxconns;$/;"	m	struct:settings	access:public
settings::maxconns_fast	memcached.h	/^    bool maxconns_fast;     \/* Whether or not to early close connections *\/$/;"	m	struct:settings	access:public
settings::num_threads	memcached.h	/^    int num_threads;        \/* number of worker (without dispatcher) libevent threads to run 工作线程数量(0<n<=64) *\/$/;"	m	struct:settings	access:public
settings::num_threads_per_udp	memcached.h	/^    int num_threads_per_udp; \/* number of worker threads serving each udp socket *\/$/;"	m	struct:settings	access:public
settings::oldest_cas	memcached.h	/^    uint64_t oldest_cas; \/* ignore existing items with CAS values lower than this *\/$/;"	m	struct:settings	access:public
settings::oldest_live	memcached.h	/^    rel_time_t oldest_live; \/* ignore existing items older than this *\/$/;"	m	struct:settings	access:public
settings::port	memcached.h	/^    int port;$/;"	m	struct:settings	access:public
settings::prefix_delimiter	memcached.h	/^    char prefix_delimiter;  \/* character that marks a key prefix (for stats) *\/$/;"	m	struct:settings	access:public
settings::relaxed_privileges	memcached.h	/^    bool relaxed_privileges;   \/* Relax process restrictions when running testapp *\/$/;"	m	struct:settings	access:public
settings::reqs_per_event	memcached.h	/^    int reqs_per_event;     \/* Maximum number of io to process on each$/;"	m	struct:settings	access:public
settings::sasl	memcached.h	/^    bool sasl;              \/* SASL on\/off 标识是否开启sasl功能,默认关闭 *\/$/;"	m	struct:settings	access:public
settings::shutdown_command	memcached.h	/^    bool shutdown_command; \/* allow shutdown command *\/$/;"	m	struct:settings	access:public
settings::slab_automove	memcached.h	/^    int slab_automove;     \/* Whether or not to automatically move slabs *\/$/;"	m	struct:settings	access:public
settings::slab_automove_freeratio	memcached.h	/^    double slab_automove_freeratio; \/* % of memory to hold free as buffer *\/$/;"	m	struct:settings	access:public
settings::slab_automove_ratio	memcached.h	/^    double slab_automove_ratio; \/* youngest must be within pct of oldest *\/$/;"	m	struct:settings	access:public
settings::slab_automove_window	memcached.h	/^    unsigned int slab_automove_window; \/* window mover for algorithm *\/$/;"	m	struct:settings	access:public
settings::slab_chunk_size_max	memcached.h	/^    int slab_chunk_size_max;  \/* Upper end for chunks within slab pages. *\/$/;"	m	struct:settings	access:public
settings::slab_page_size	memcached.h	/^    int slab_page_size;     \/* Slab's page units. *\/$/;"	m	struct:settings	access:public
settings::slab_reassign	memcached.h	/^    bool slab_reassign;     \/* Whether or not slab reassignment is allowed *\/$/;"	m	struct:settings	access:public
settings::socketpath	memcached.h	/^    char *socketpath;   \/* path to unix socket if using local socket  UNIX域套接字绑定地址 *\/$/;"	m	struct:settings	access:public
settings::tail_repair_time	memcached.h	/^    int tail_repair_time;   \/* LRU tail refcount leak repair time *\/$/;"	m	struct:settings	access:public
settings::temp_lru	memcached.h	/^    bool temp_lru; \/* TTL < temporary_ttl uses TEMP_LRU *\/$/;"	m	struct:settings	access:public
settings::temporary_ttl	memcached.h	/^    uint32_t temporary_ttl; \/* temporary LRU threshold *\/$/;"	m	struct:settings	access:public
settings::udpport	memcached.h	/^    int udpport;$/;"	m	struct:settings	access:public
settings::use_cas	memcached.h	/^    bool use_cas;$/;"	m	struct:settings	access:public
settings::verbose	memcached.h	/^    int verbose;$/;"	m	struct:settings	access:public
settings::warm_lru_pct	memcached.h	/^    int warm_lru_pct; \/* percentage of slab space for WARM_LRU *\/$/;"	m	struct:settings	access:public
settings::warm_max_factor	memcached.h	/^    double warm_max_factor; \/* WARM tail age relative to COLD tail *\/$/;"	m	struct:settings	access:public
settings_init	memcached.c	/^static void settings_init(void) {$/;"	f	file:	signature:(void)
settings_init	memcached.c	/^static void settings_init(void);$/;"	p	file:	signature:(void)
setup_thread	thread.c	/^static void setup_thread(LIBEVENT_THREAD *me) {$/;"	f	file:	signature:(LIBEVENT_THREAD *me)
sfd	crawler.c	/^    int sfd; \/* client fd. *\/$/;"	m	struct:__anon49	file:	access:public
sfd	logger.h	/^    int sfd; \/* client fd *\/$/;"	m	struct:__anon59	access:public
sfd	memcached.h	/^    int    sfd;     \/\/ 该连接session关联的fd$/;"	m	struct:conn	access:public
sfd	thread.c	/^    int               sfd;$/;"	m	struct:conn_queue_item	file:	access:public
sharedstatedir	doc/Makefile	/^sharedstatedir = ${prefix}\/com$/;"	m
show_help	scripts/damemtop	/^sub show_help {$/;"	s
shutdown_command	memcached.h	/^    bool shutdown_command; \/* allow shutdown command *\/$/;"	m	struct:settings	access:public
shutdown_memcached_server	testapp.c	/^static enum test_return shutdown_memcached_server(void) {$/;"	f	file:	signature:(void)
sidethread_conn_close	memcached.h	/^void sidethread_conn_close(conn *c);$/;"	p	signature:(conn *c)
sidethread_conn_close	thread.c	/^void sidethread_conn_close(conn *c) {$/;"	f	signature:(conn *c)
sig_handler	memcached.c	/^static void sig_handler(const int sig) {$/;"	f	file:	signature:(const int sig)
sigignore	memcached.c	/^static int sigignore(int sig) {$/;"	f	file:	signature:(int sig)
silent_incrdecr	t/binary-extstore.t	/^sub silent_incrdecr {$/;"	s
silent_incrdecr	t/binary-sasl.t	/^sub silent_incrdecr {$/;"	s
silent_incrdecr	t/binary.t	/^sub silent_incrdecr {$/;"	s
silent_mutation	t/binary-extstore.t	/^sub silent_mutation {$/;"	s
silent_mutation	t/binary-sasl.t	/^sub silent_mutation {$/;"	s
silent_mutation	t/binary.t	/^sub silent_mutation {$/;"	s
size	bipbuffer.h	/^    unsigned long int size;$/;"	m	struct:__anon47	access:public
size	extstore.c	/^    unsigned int size;$/;"	m	struct:__store_wbuf	file:	access:public
size	logger.h	/^    int size;$/;"	m	struct:_logentry	access:public
size	memcached.h	/^        size_t size;$/;"	m	struct:conn::__anon55	access:public
size	memcached.h	/^    int              size;      \/* available chunk space in bytes *\/$/;"	m	struct:_strchunk	access:public
size	protocol_binary.h	/^                uint16_t size;$/;"	m	struct:__anon38::__anon39::__anon40	access:public
size	slabs.c	/^    unsigned int size;      \/* sizes of items *\/$/;"	m	struct:__anon1	file:	access:public
sizes	items.c	/^static unsigned int sizes[LARGEST_ID];$/;"	v	file:
sizes_bytes	items.c	/^static uint64_t sizes_bytes[LARGEST_ID];$/;"	v	file:
skipped	logger.h	/^    uint64_t skipped; \/* lines skipped since last successful print *\/$/;"	m	struct:__anon59	access:public
sl_curr	slabs.c	/^    unsigned int sl_curr;   \/* total free items in list *\/$/;"	m	struct:__anon1	file:	access:public
slab_automove	memcached.h	/^    int slab_automove;     \/* Whether or not to automatically move slabs *\/$/;"	m	struct:settings	access:public
slab_automove	slab_automove.c	/^} slab_automove;$/;"	t	typeref:struct:__anon48	file:
slab_automove	slab_automove_extstore.c	/^} slab_automove;$/;"	t	typeref:struct:__anon56	file:
slab_automove_default	items.c	/^slab_automove_reg_t slab_automove_default = {$/;"	v
slab_automove_extstore	items.c	/^slab_automove_reg_t slab_automove_extstore = {$/;"	v
slab_automove_extstore_free	slab_automove_extstore.c	/^void slab_automove_extstore_free(void *arg) {$/;"	f	signature:(void *arg)
slab_automove_extstore_free	slab_automove_extstore.h	/^void slab_automove_extstore_free(void *arg);$/;"	p	signature:(void *arg)
slab_automove_extstore_init	slab_automove_extstore.c	/^void *slab_automove_extstore_init(struct settings *settings) {$/;"	f	signature:(struct settings *settings)
slab_automove_extstore_init	slab_automove_extstore.h	/^void *slab_automove_extstore_init(struct settings *settings);$/;"	p	signature:(struct settings *settings)
slab_automove_extstore_run	slab_automove_extstore.c	/^void slab_automove_extstore_run(void *arg, int *src, int *dst) {$/;"	f	signature:(void *arg, int *src, int *dst)
slab_automove_extstore_run	slab_automove_extstore.h	/^void slab_automove_extstore_run(void *arg, int *src, int *dst);$/;"	p	signature:(void *arg, int *src, int *dst)
slab_automove_free	slab_automove.c	/^void slab_automove_free(void *arg) {$/;"	f	signature:(void *arg)
slab_automove_free	slab_automove.h	/^void slab_automove_free(void *arg);$/;"	p	signature:(void *arg)
slab_automove_free_func	slab_automove.h	/^typedef void (*slab_automove_free_func)(void *arg);$/;"	t
slab_automove_freeratio	memcached.h	/^    double slab_automove_freeratio; \/* % of memory to hold free as buffer *\/$/;"	m	struct:settings	access:public
slab_automove_init	slab_automove.c	/^void *slab_automove_init(struct settings *settings) {$/;"	f	signature:(struct settings *settings)
slab_automove_init	slab_automove.h	/^void *slab_automove_init(struct settings *settings);$/;"	p	signature:(struct settings *settings)
slab_automove_init_func	slab_automove.h	/^typedef void *(*slab_automove_init_func)(struct settings *settings);$/;"	t
slab_automove_ratio	memcached.h	/^    double slab_automove_ratio; \/* youngest must be within pct of oldest *\/$/;"	m	struct:settings	access:public
slab_automove_reg_t	slab_automove.h	/^} slab_automove_reg_t;$/;"	t	typeref:struct:__anon2
slab_automove_run	slab_automove.c	/^void slab_automove_run(void *arg, int *src, int *dst) {$/;"	f	signature:(void *arg, int *src, int *dst)
slab_automove_run	slab_automove.h	/^void slab_automove_run(void *arg, int *src, int *dst);$/;"	p	signature:(void *arg, int *src, int *dst)
slab_automove_run_func	slab_automove.h	/^typedef void (*slab_automove_run_func)(void *arg, int *src, int *dst);$/;"	t
slab_automove_window	memcached.h	/^    unsigned int slab_automove_window; \/* window mover for algorithm *\/$/;"	m	struct:settings	access:public
slab_bulk_check	slabs.c	/^int slab_bulk_check = DEFAULT_SLAB_BULK_CHECK;$/;"	v
slab_chunk_size_max	memcached.h	/^    int slab_chunk_size_max;  \/* Upper end for chunks within slab pages. *\/$/;"	m	struct:settings	access:public
slab_end	memcached.h	/^    void *slab_end;$/;"	m	struct:slab_rebalance	access:public
slab_list	slabs.c	/^    void **slab_list;       \/* array of slab pointers *\/$/;"	m	struct:__anon1	file:	access:public
slab_page_size	memcached.h	/^    int slab_page_size;     \/* Slab's page units. *\/$/;"	m	struct:settings	access:public
slab_pos	memcached.h	/^    void *slab_pos;$/;"	m	struct:slab_rebalance	access:public
slab_reassign	memcached.h	/^    bool slab_reassign;     \/* Whether or not slab reassignment is allowed *\/$/;"	m	struct:settings	access:public
slab_reassign_busy_deletes	memcached.h	/^    uint64_t      slab_reassign_busy_deletes; \/* refcounted items killed *\/$/;"	m	struct:stats	access:public
slab_reassign_busy_items	memcached.h	/^    uint64_t      slab_reassign_busy_items; \/* valid temporarily unmovable *\/$/;"	m	struct:stats	access:public
slab_reassign_chunk_rescues	memcached.h	/^    uint64_t      slab_reassign_chunk_rescues; \/* chunked-item chunks recovered *\/$/;"	m	struct:stats	access:public
slab_reassign_evictions_nomem	memcached.h	/^    uint64_t      slab_reassign_evictions_nomem; \/* valid items lost during slab move *\/$/;"	m	struct:stats	access:public
slab_reassign_inline_reclaim	memcached.h	/^    uint64_t      slab_reassign_inline_reclaim; \/* valid items lost during slab move *\/$/;"	m	struct:stats	access:public
slab_reassign_rescues	memcached.h	/^    uint64_t      slab_reassign_rescues; \/* items rescued during slab move *\/$/;"	m	struct:stats	access:public
slab_reassign_running	memcached.h	/^    bool          slab_reassign_running; \/* slab reassign in progress *\/$/;"	m	struct:stats_state	access:public
slab_rebal	memcached.c	/^struct slab_rebalance slab_rebal;$/;"	v	typeref:struct:slab_rebalance
slab_rebalance	memcached.h	/^struct slab_rebalance {$/;"	s
slab_rebalance::busy_deletes	memcached.h	/^    uint32_t busy_deletes;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::busy_items	memcached.h	/^    uint32_t busy_items;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::busy_loops	memcached.h	/^    uint32_t busy_loops;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::chunk_rescues	memcached.h	/^    uint32_t chunk_rescues;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::d_clsid	memcached.h	/^    int d_clsid;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::done	memcached.h	/^    uint8_t done;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::evictions_nomem	memcached.h	/^    uint32_t evictions_nomem;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::inline_reclaim	memcached.h	/^    uint32_t inline_reclaim;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::rescues	memcached.h	/^    uint32_t rescues;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::s_clsid	memcached.h	/^    int s_clsid;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::slab_end	memcached.h	/^    void *slab_end;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::slab_pos	memcached.h	/^    void *slab_pos;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance::slab_start	memcached.h	/^    void *slab_start;$/;"	m	struct:slab_rebalance	access:public
slab_rebalance_alloc	slabs.c	/^static void *slab_rebalance_alloc(const size_t size, unsigned int id) {$/;"	f	file:	signature:(const size_t size, unsigned int id)
slab_rebalance_cond	slabs.c	/^static pthread_cond_t slab_rebalance_cond = PTHREAD_COND_INITIALIZER;$/;"	v	file:
slab_rebalance_cut_free	slabs.c	/^static void slab_rebalance_cut_free(slabclass_t *s_cls, item *it) {$/;"	f	file:	signature:(slabclass_t *s_cls, item *it)
slab_rebalance_finish	slabs.c	/^static void slab_rebalance_finish(void) {$/;"	f	file:	signature:(void)
slab_rebalance_move	slabs.c	/^static int slab_rebalance_move(void) {$/;"	f	file:	signature:(void)
slab_rebalance_signal	memcached.c	/^volatile int slab_rebalance_signal;$/;"	v
slab_rebalance_start	slabs.c	/^static int slab_rebalance_start(void) {$/;"	f	file:	signature:(void)
slab_rebalance_thread	slabs.c	/^static void *slab_rebalance_thread(void *arg) {$/;"	f	file:	signature:(void *arg)
slab_start	memcached.h	/^    void *slab_start;$/;"	m	struct:slab_rebalance	access:public
slab_stats	memcached.h	/^    struct slab_stats slab_stats[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:thread_stats	typeref:struct:thread_stats::slab_stats	access:public
slab_stats	memcached.h	/^struct slab_stats {$/;"	s
slab_stats_aggregate	memcached.h	/^void slab_stats_aggregate(struct thread_stats *stats, struct slab_stats *out);$/;"	p	signature:(struct thread_stats *stats, struct slab_stats *out)
slab_stats_aggregate	thread.c	/^void slab_stats_aggregate(struct thread_stats *stats, struct slab_stats *out) {$/;"	f	signature:(struct thread_stats *stats, struct slab_stats *out)
slab_stats_automove	slabs.h	/^} slab_stats_automove;$/;"	t	typeref:struct:__anon42
slabclass	slabs.c	/^static slabclass_t slabclass[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	v	file:
slabclass_t	slabs.c	/^} slabclass_t;$/;"	t	typeref:struct:__anon1	file:
slabs	slabs.c	/^    unsigned int slabs;     \/* how many slabs were allocated for this class *\/$/;"	m	struct:__anon1	file:	access:public
slabs_adjust_mem_limit	slabs.c	/^bool slabs_adjust_mem_limit(size_t new_mem_limit) {$/;"	f	signature:(size_t new_mem_limit)
slabs_adjust_mem_limit	slabs.h	/^bool slabs_adjust_mem_limit(size_t new_mem_limit);$/;"	p	signature:(size_t new_mem_limit)
slabs_adjust_mem_requested	slabs.c	/^void slabs_adjust_mem_requested(unsigned int id, size_t old, size_t ntotal)$/;"	f	signature:(unsigned int id, size_t old, size_t ntotal)
slabs_adjust_mem_requested	slabs.h	/^void slabs_adjust_mem_requested(unsigned int id, size_t old, size_t ntotal);$/;"	p	signature:(unsigned int id, size_t old, size_t ntotal)
slabs_alloc	slabs.c	/^void *slabs_alloc(size_t size, unsigned int id, uint64_t *total_bytes,$/;"	f	signature:(size_t size, unsigned int id, uint64_t *total_bytes, unsigned int flags)
slabs_alloc	slabs.h	/^void *slabs_alloc(const size_t size, unsigned int id, uint64_t *total_bytes, unsigned int flags);$/;"	p	signature:(const size_t size, unsigned int id, uint64_t *total_bytes, unsigned int flags)
slabs_available_chunks	slabs.c	/^unsigned int slabs_available_chunks(const unsigned int id, bool *mem_flag,$/;"	f	signature:(const unsigned int id, bool *mem_flag, uint64_t *total_bytes, unsigned int *chunks_perslab)
slabs_available_chunks	slabs.h	/^unsigned int slabs_available_chunks(unsigned int id, bool *mem_flag, uint64_t *total_bytes, unsigned int *chunks_perslab);$/;"	p	signature:(unsigned int id, bool *mem_flag, uint64_t *total_bytes, unsigned int *chunks_perslab)
slabs_clsid	memcached.h	/^    uint8_t          slabs_clsid; \/* Same as above. *\/$/;"	m	struct:_strchunk	access:public
slabs_clsid	memcached.h	/^    uint8_t         slabs_clsid;\/* which slab class we're in *\/$/;"	m	struct:__anon52	access:public
slabs_clsid	memcached.h	/^    uint8_t         slabs_clsid;\/* which slab class we're in *\/$/;"	m	struct:_stritem	access:public
slabs_clsid	slabs.c	/^unsigned int slabs_clsid(const size_t size) {$/;"	f	signature:(const size_t size)
slabs_clsid	slabs.h	/^unsigned int slabs_clsid(const size_t size);$/;"	p	signature:(const size_t size)
slabs_free	slabs.c	/^void slabs_free(void *ptr, size_t size, unsigned int id) {$/;"	f	signature:(void *ptr, size_t size, unsigned int id)
slabs_free	slabs.h	/^void slabs_free(void *ptr, size_t size, unsigned int id);$/;"	p	signature:(void *ptr, size_t size, unsigned int id)
slabs_init	slabs.c	/^void slabs_init(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes) {$/;"	f	signature:(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes)
slabs_init	slabs.h	/^void slabs_init(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes);$/;"	p	signature:(const size_t limit, const double factor, const bool prealloc, const uint32_t *slab_sizes)
slabs_lock	slabs.c	/^static pthread_mutex_t slabs_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
slabs_mlock	slabs.c	/^void slabs_mlock(void) {$/;"	f	signature:(void)
slabs_mlock	slabs.h	/^void slabs_mlock(void);$/;"	p	signature:(void)
slabs_moved	memcached.h	/^    uint64_t      slabs_moved;       \/* times slabs were moved around *\/$/;"	m	struct:stats	access:public
slabs_munlock	slabs.c	/^void slabs_munlock(void) {$/;"	f	signature:(void)
slabs_munlock	slabs.h	/^void slabs_munlock(void);$/;"	p	signature:(void)
slabs_preallocate	slabs.c	/^static void slabs_preallocate (const unsigned int maxslabs) {$/;"	f	file:	signature:(const unsigned int maxslabs)
slabs_preallocate	slabs.c	/^static void slabs_preallocate (const unsigned int maxslabs);$/;"	p	file:	signature:(const unsigned int maxslabs)
slabs_prefill_global	slabs.c	/^void slabs_prefill_global(void) {$/;"	f	signature:(void)
slabs_prefill_global	slabs.h	/^void slabs_prefill_global(void);$/;"	p	signature:(void)
slabs_reassign	slabs.c	/^enum reassign_result_type slabs_reassign(int src, int dst) {$/;"	f	signature:(int src, int dst)
slabs_reassign	slabs.h	/^enum reassign_result_type slabs_reassign(int src, int dst);$/;"	p	signature:(int src, int dst)
slabs_reassign_pick_any	slabs.c	/^static int slabs_reassign_pick_any(int dst) {$/;"	f	file:	signature:(int dst)
slabs_rebalance_lock	slabs.c	/^static pthread_mutex_t slabs_rebalance_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
slabs_rebalancer_pause	slabs.c	/^void slabs_rebalancer_pause(void) {$/;"	f	signature:(void)
slabs_rebalancer_pause	slabs.h	/^void slabs_rebalancer_pause(void);$/;"	p	signature:(void)
slabs_rebalancer_resume	slabs.c	/^void slabs_rebalancer_resume(void) {$/;"	f	signature:(void)
slabs_rebalancer_resume	slabs.h	/^void slabs_rebalancer_resume(void);$/;"	p	signature:(void)
slabs_set_storage	slabs.c	/^void slabs_set_storage(void *arg) {$/;"	f	signature:(void *arg)
slabs_set_storage	slabs.h	/^void slabs_set_storage(void *arg);$/;"	p	signature:(void *arg)
slabs_stats	slabs.c	/^void slabs_stats(ADD_STAT add_stats, void *c) {$/;"	f	signature:(ADD_STAT add_stats, void *c)
slabs_stats	slabs.h	/^void slabs_stats(ADD_STAT add_stats, void *c);$/;"	p	signature:(ADD_STAT add_stats, void *c)
sleep	t/lib/MemcachedTest.pm	/^sub sleep {$/;"	s
slots	slabs.c	/^    void *slots;           \/* list of item ptrs *\/$/;"	m	struct:__anon1	file:	access:public
sock	t/lib/MemcachedTest.pm	/^sub sock {$/;"	s
sock	testapp.c	/^static int sock;$/;"	v	file:
socketpath	memcached.h	/^    char *socketpath;   \/* path to unix socket if using local socket  UNIX域套接字绑定地址 *\/$/;"	m	struct:settings	access:public
spawn_and_wait	timedrun.c	/^static int spawn_and_wait(char **argv)$/;"	f	file:	signature:(char **argv)
split_slab_page_into_freelist	slabs.c	/^static void split_slab_page_into_freelist(char *ptr, const unsigned int id) {$/;"	f	file:	signature:(char *ptr, const unsigned int id)
srcdir	doc/Makefile	/^srcdir = .$/;"	m
start	scripts/memcached.sysv	/^start () {$/;"	f
start_assoc_maintenance_thread	assoc.c	/^int start_assoc_maintenance_thread() {$/;"	f
start_assoc_maintenance_thread	assoc.h	/^int start_assoc_maintenance_thread(void);$/;"	p	signature:(void)
start_conn_timeout_thread	memcached.c	/^static int start_conn_timeout_thread() {$/;"	f	file:
start_conn_timeout_thread	memcached.c	/^static int start_conn_timeout_thread();$/;"	p	file:
start_item_crawler_thread	crawler.c	/^int start_item_crawler_thread(void) {$/;"	f	signature:(void)
start_item_crawler_thread	crawler.h	/^int start_item_crawler_thread(void);$/;"	p	signature:(void)
start_logger_thread	logger.c	/^static int start_logger_thread(void) {$/;"	f	file:	signature:(void)
start_lru_maintainer_thread	items.c	/^int start_lru_maintainer_thread(void *arg) {$/;"	f	signature:(void *arg)
start_lru_maintainer_thread	items.h	/^int start_lru_maintainer_thread(void *arg);$/;"	p	signature:(void *arg)
start_memcached_server	testapp.c	/^static enum test_return start_memcached_server(void) {$/;"	f	file:	signature:(void)
start_server	testapp.c	/^static pid_t start_server(in_port_t *port_out, bool daemon, int timeout) {$/;"	f	file:	signature:(in_port_t *port_out, bool daemon, int timeout)
start_slab_maintenance_thread	slabs.c	/^int start_slab_maintenance_thread(void) {$/;"	f	signature:(void)
start_slab_maintenance_thread	slabs.h	/^int start_slab_maintenance_thread(void);$/;"	p	signature:(void)
start_storage_compact_thread	storage.c	/^int start_storage_compact_thread(void *arg) {$/;"	f	signature:(void *arg)
start_storage_compact_thread	storage.h	/^int start_storage_compact_thread(void *arg);$/;"	p	signature:(void *arg)
start_time	crawler.h	/^    rel_time_t start_time;$/;"	m	struct:__anon4	access:public
start_time	crawler.h	/^    rel_time_t start_time;$/;"	m	struct:crawler_expired_data	access:public
started_expanding	assoc.c	/^static bool started_expanding = false;$/;"	v	file:
state	memcached.h	/^    enum conn_states  state;    \/\/ 该链接session当前状态$/;"	m	struct:conn	typeref:enum:conn::conn_states	access:public
state_text	memcached.c	/^static const char *state_text(enum conn_states state) {$/;"	f	file:	signature:(enum conn_states state)
stats	extstore.c	/^    struct extstore_stats stats;$/;"	m	struct:store_engine	typeref:struct:store_engine::extstore_stats	file:	access:public
stats	memcached.c	/^struct stats stats;     \/\/ 定义了一个全局的统计模块$/;"	v	typeref:struct:stats
stats	memcached.h	/^    struct thread_stats stats;  \/* Stats generated by this thread  记录了该线程的统计信息 *\/$/;"	m	struct:__anon54	typeref:struct:__anon54::thread_stats	access:public
stats	memcached.h	/^    } stats;$/;"	m	struct:conn	typeref:struct:conn::__anon55	access:public
stats	memcached.h	/^struct stats {$/;"	s
stats	t/binary-extstore.t	/^sub stats {$/;"	s
stats	t/binary-sasl.t	/^sub stats {$/;"	s
stats	t/binary.t	/^sub stats {$/;"	s
stats::extstore_compact_lost	memcached.h	/^    uint64_t      extstore_compact_lost; \/* items lost because they were locked *\/$/;"	m	struct:stats	access:public
stats::extstore_compact_rescues	memcached.h	/^    uint64_t      extstore_compact_rescues; \/* items re-written during compaction *\/$/;"	m	struct:stats	access:public
stats::extstore_compact_skipped	memcached.h	/^    uint64_t      extstore_compact_skipped; \/* unhit items skipped during compaction *\/$/;"	m	struct:stats	access:public
stats::listen_disabled_num	memcached.h	/^    uint64_t      listen_disabled_num;$/;"	m	struct:stats	access:public
stats::log_watcher_sent	memcached.h	/^    uint64_t      log_watcher_sent; \/* logs sent to watcher buffers *\/$/;"	m	struct:stats	access:public
stats::log_watcher_skipped	memcached.h	/^    uint64_t      log_watcher_skipped; \/* logs watchers missed *\/$/;"	m	struct:stats	access:public
stats::log_worker_dropped	memcached.h	/^    uint64_t      log_worker_dropped; \/* logs dropped by worker threads *\/$/;"	m	struct:stats	access:public
stats::log_worker_written	memcached.h	/^    uint64_t      log_worker_written; \/* logs written by worker threads *\/$/;"	m	struct:stats	access:public
stats::lru_crawler_starts	memcached.h	/^    uint64_t      lru_crawler_starts; \/* Number of item crawlers kicked off *\/$/;"	m	struct:stats	access:public
stats::lru_maintainer_juggles	memcached.h	/^    uint64_t      lru_maintainer_juggles; \/* number of LRU bg pokes *\/$/;"	m	struct:stats	access:public
stats::malloc_fails	memcached.h	/^    uint64_t      malloc_fails;$/;"	m	struct:stats	access:public
stats::maxconns_entered	memcached.h	/^    struct timeval maxconns_entered;  \/* last time maxconns entered *\/$/;"	m	struct:stats	typeref:struct:stats::timeval	access:public
stats::rejected_conns	memcached.h	/^    uint64_t      rejected_conns;$/;"	m	struct:stats	access:public
stats::slab_reassign_busy_deletes	memcached.h	/^    uint64_t      slab_reassign_busy_deletes; \/* refcounted items killed *\/$/;"	m	struct:stats	access:public
stats::slab_reassign_busy_items	memcached.h	/^    uint64_t      slab_reassign_busy_items; \/* valid temporarily unmovable *\/$/;"	m	struct:stats	access:public
stats::slab_reassign_chunk_rescues	memcached.h	/^    uint64_t      slab_reassign_chunk_rescues; \/* chunked-item chunks recovered *\/$/;"	m	struct:stats	access:public
stats::slab_reassign_evictions_nomem	memcached.h	/^    uint64_t      slab_reassign_evictions_nomem; \/* valid items lost during slab move *\/$/;"	m	struct:stats	access:public
stats::slab_reassign_inline_reclaim	memcached.h	/^    uint64_t      slab_reassign_inline_reclaim; \/* valid items lost during slab move *\/$/;"	m	struct:stats	access:public
stats::slab_reassign_rescues	memcached.h	/^    uint64_t      slab_reassign_rescues; \/* items rescued during slab move *\/$/;"	m	struct:stats	access:public
stats::slabs_moved	memcached.h	/^    uint64_t      slabs_moved;       \/* times slabs were moved around *\/$/;"	m	struct:stats	access:public
stats::time_in_listen_disabled_us	memcached.h	/^    uint64_t      time_in_listen_disabled_us;  \/* elapsed time in microseconds while server unable to process new connections *\/$/;"	m	struct:stats	access:public
stats::total_conns	memcached.h	/^    uint64_t      total_conns;$/;"	m	struct:stats	access:public
stats::total_items	memcached.h	/^    uint64_t      total_items;$/;"	m	struct:stats	access:public
stats_init	memcached.c	/^static void stats_init(void) {$/;"	f	file:	signature:(void)
stats_init	memcached.c	/^static void stats_init(void);$/;"	p	file:	signature:(void)
stats_lock	thread.c	/^static pthread_mutex_t stats_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
stats_mutex	extstore.c	/^    pthread_mutex_t stats_mutex;$/;"	m	struct:store_engine	file:	access:public
stats_prefix_clear	stats.c	/^void stats_prefix_clear() {$/;"	f
stats_prefix_clear	stats.h	/^void stats_prefix_clear(void);$/;"	p	signature:(void)
stats_prefix_dump	stats.c	/^char *stats_prefix_dump(int *length) {$/;"	f	signature:(int *length)
stats_prefix_dump	stats.h	/^char *stats_prefix_dump(int *length);$/;"	p	signature:(int *length)
stats_prefix_find	stats.c	/^static PREFIX_STATS *stats_prefix_find(const char *key, const size_t nkey) {$/;"	f	file:	signature:(const char *key, const size_t nkey)
stats_prefix_init	stats.c	/^void stats_prefix_init() {$/;"	f
stats_prefix_init	stats.h	/^void stats_prefix_init(void);$/;"	p	signature:(void)
stats_prefix_record_delete	stats.c	/^void stats_prefix_record_delete(const char *key, const size_t nkey) {$/;"	f	signature:(const char *key, const size_t nkey)
stats_prefix_record_delete	stats.h	/^void stats_prefix_record_delete(const char *key, const size_t nkey);$/;"	p	signature:(const char *key, const size_t nkey)
stats_prefix_record_get	stats.c	/^void stats_prefix_record_get(const char *key, const size_t nkey, const bool is_hit) {$/;"	f	signature:(const char *key, const size_t nkey, const bool is_hit)
stats_prefix_record_get	stats.h	/^void stats_prefix_record_get(const char *key, const size_t nkey, const bool is_hit);$/;"	p	signature:(const char *key, const size_t nkey, const bool is_hit)
stats_prefix_record_set	stats.c	/^void stats_prefix_record_set(const char *key, const size_t nkey) {$/;"	f	signature:(const char *key, const size_t nkey)
stats_prefix_record_set	stats.h	/^void stats_prefix_record_set(const char *key, const size_t nkey);$/;"	p	signature:(const char *key, const size_t nkey)
stats_reset	memcached.c	/^static void stats_reset(void) {$/;"	f	file:	signature:(void)
stats_sizes_buckets	items.c	/^static int stats_sizes_buckets = 0;$/;"	v	file:
stats_sizes_cas_min	items.c	/^static uint64_t stats_sizes_cas_min = 0;$/;"	v	file:
stats_sizes_hist	items.c	/^static unsigned int *stats_sizes_hist = NULL;$/;"	v	file:
stats_sizes_lock	items.c	/^static pthread_mutex_t stats_sizes_lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v	file:
stats_state	memcached.c	/^struct stats_state stats_state;$/;"	v	typeref:struct:stats_state
stats_state	memcached.h	/^struct stats_state {$/;"	s
stats_state::accepting_conns	memcached.h	/^    bool          accepting_conns;  \/* whether we are currently accepting  标识我们当前是否处于listen状态 *\/$/;"	m	struct:stats_state	access:public
stats_state::conn_structs	memcached.h	/^    unsigned int  conn_structs;     \/\/ 记录了已经创建的连接session数量$/;"	m	struct:stats_state	access:public
stats_state::curr_bytes	memcached.h	/^    uint64_t      curr_bytes;$/;"	m	struct:stats_state	access:public
stats_state::curr_conns	memcached.h	/^    uint64_t      curr_conns;       \/\/ 记录了$/;"	m	struct:stats_state	access:public
stats_state::curr_items	memcached.h	/^    uint64_t      curr_items;$/;"	m	struct:stats_state	access:public
stats_state::hash_bytes	memcached.h	/^    uint64_t      hash_bytes;       \/* size used for hash tables *\/$/;"	m	struct:stats_state	access:public
stats_state::hash_is_expanding	memcached.h	/^    bool          hash_is_expanding; \/* If the hash table is being expanded *\/$/;"	m	struct:stats_state	access:public
stats_state::hash_power_level	memcached.h	/^    unsigned int  hash_power_level; \/* Better hope it's not over 9000 *\/$/;"	m	struct:stats_state	access:public
stats_state::lru_crawler_running	memcached.h	/^    bool          lru_crawler_running; \/* crawl in progress *\/$/;"	m	struct:stats_state	access:public
stats_state::reserved_fds	memcached.h	/^    unsigned int  reserved_fds;     \/\/ 记录了保留的fd数量$/;"	m	struct:stats_state	access:public
stats_state::slab_reassign_running	memcached.h	/^    bool          slab_reassign_running; \/* slab reassign in progress *\/$/;"	m	struct:stats_state	access:public
status	logger.h	/^    int status;$/;"	m	struct:logentry_item_store	access:public
status	protocol_binary.h	/^            uint16_t status;$/;"	m	struct:__anon11::__anon12	access:public
stop	scripts/memcached.sysv	/^stop () {$/;"	f
stop	t/lib/MemcachedTest.pm	/^sub stop {$/;"	s
stop_assoc_maintenance_thread	assoc.c	/^void stop_assoc_maintenance_thread() {$/;"	f
stop_assoc_maintenance_thread	assoc.h	/^void stop_assoc_maintenance_thread(void);$/;"	p	signature:(void)
stop_item_crawler_thread	crawler.c	/^int stop_item_crawler_thread(void) {$/;"	f	signature:(void)
stop_item_crawler_thread	crawler.h	/^int stop_item_crawler_thread(void);$/;"	p	signature:(void)
stop_lru_maintainer_thread	items.c	/^int stop_lru_maintainer_thread(void) {$/;"	f	signature:(void)
stop_lru_maintainer_thread	items.h	/^int stop_lru_maintainer_thread(void);$/;"	p	signature:(void)
stop_memcached_server	testapp.c	/^static enum test_return stop_memcached_server(void) {$/;"	f	file:	signature:(void)
stop_slab_maintenance_thread	slabs.c	/^void stop_slab_maintenance_thread(void) {$/;"	f	signature:(void)
stop_slab_maintenance_thread	slabs.h	/^void stop_slab_maintenance_thread(void);$/;"	p	signature:(void)
storage	crawler.c	/^static void *storage;$/;"	v	file:
storage	memcached.h	/^    void *storage;              \/* data object for storage system *\/$/;"	m	struct:__anon54	access:public
storage	slabs.c	/^static void *storage  = NULL;$/;"	v	file:
storage_command	testapp.c	/^static off_t storage_command(char*buf,$/;"	f	file:	signature:(char*buf, size_t bufsz, uint8_t cmd, const void* key, size_t keylen, const void* dta, size_t dtalen, uint32_t flags, uint32_t exp)
storage_compact_check	storage.c	/^static int storage_compact_check(void *storage, logger *l,$/;"	f	file:	signature:(void *storage, logger *l, uint32_t *page_id, uint64_t *page_version, uint64_t *page_size, bool *drop_unread)
storage_compact_pause	storage.c	/^void storage_compact_pause(void) {$/;"	f	signature:(void)
storage_compact_pause	storage.h	/^void storage_compact_pause(void);$/;"	p	signature:(void)
storage_compact_plock	storage.c	/^static pthread_mutex_t storage_compact_plock;$/;"	v	file:
storage_compact_readback	storage.c	/^static void storage_compact_readback(void *storage, logger *l,$/;"	f	file:	signature:(void *storage, logger *l, bool drop_unread, char *readback_buf, uint32_t page_id, uint64_t page_version, uint64_t read_size)
storage_compact_resume	storage.c	/^void storage_compact_resume(void) {$/;"	f	signature:(void)
storage_compact_resume	storage.h	/^void storage_compact_resume(void);$/;"	p	signature:(void)
storage_compact_thread	storage.c	/^static void *storage_compact_thread(void *arg) {$/;"	f	file:	signature:(void *arg)
storage_compact_tid	storage.c	/^static pthread_t storage_compact_tid;$/;"	v	file:
storage_compact_wrap	storage.c	/^struct storage_compact_wrap {$/;"	s	file:
storage_compact_wrap::done	storage.c	/^    bool done;$/;"	m	struct:storage_compact_wrap	file:	access:public
storage_compact_wrap::io	storage.c	/^    obj_io io;$/;"	m	struct:storage_compact_wrap	file:	access:public
storage_compact_wrap::lock	storage.c	/^    pthread_mutex_t lock; \/\/ gates the bools.$/;"	m	struct:storage_compact_wrap	file:	access:public
storage_compact_wrap::miss	storage.c	/^    bool miss; \/\/ version flipped out from under us$/;"	m	struct:storage_compact_wrap	file:	access:public
storage_compact_wrap::submitted	storage.c	/^    bool submitted;$/;"	m	struct:storage_compact_wrap	file:	access:public
store_engine	extstore.c	/^struct store_engine {$/;"	s	file:
store_engine	extstore.c	/^typedef struct store_engine store_engine;$/;"	t	typeref:struct:store_engine	file:
store_engine::io_depth	extstore.c	/^    unsigned int io_depth; \/* FIXME: Might cache into thr struct *\/$/;"	m	struct:store_engine	file:	access:public
store_engine::io_stack	extstore.c	/^    obj_io *io_stack; \/* IO's to use with submitting wbuf's *\/$/;"	m	struct:store_engine	file:	access:public
store_engine::io_threadcount	extstore.c	/^    unsigned int io_threadcount; \/* count of IO threads *\/$/;"	m	struct:store_engine	file:	access:public
store_engine::io_threads	extstore.c	/^    store_io_thread *io_threads;$/;"	m	struct:store_engine	file:	access:public
store_engine::last_io_thread	extstore.c	/^    unsigned int last_io_thread; \/* round robin the IO threads *\/$/;"	m	struct:store_engine	file:	access:public
store_engine::maint_thread	extstore.c	/^    store_maint_thread *maint_thread;$/;"	m	struct:store_engine	file:	access:public
store_engine::mutex	extstore.c	/^    pthread_mutex_t mutex; \/* covers internal stacks and variables *\/$/;"	m	struct:store_engine	file:	access:public
store_engine::page_bucketcount	extstore.c	/^    unsigned int page_bucketcount; \/* count of potential page buckets *\/$/;"	m	struct:store_engine	file:	access:public
store_engine::page_buckets	extstore.c	/^    store_page **page_buckets; \/* stack of pages currently allocated to each bucket *\/$/;"	m	struct:store_engine	file:	access:public
store_engine::page_count	extstore.c	/^    unsigned int page_count;$/;"	m	struct:store_engine	file:	access:public
store_engine::page_free	extstore.c	/^    unsigned int page_free; \/* unallocated pages *\/$/;"	m	struct:store_engine	file:	access:public
store_engine::page_freelist	extstore.c	/^    store_page *page_freelist;$/;"	m	struct:store_engine	file:	access:public
store_engine::page_size	extstore.c	/^    size_t page_size;$/;"	m	struct:store_engine	file:	access:public
store_engine::pages	extstore.c	/^    store_page *pages; \/* directly addressable page list *\/$/;"	m	struct:store_engine	file:	access:public
store_engine::stats	extstore.c	/^    struct extstore_stats stats;$/;"	m	struct:store_engine	typeref:struct:store_engine::extstore_stats	file:	access:public
store_engine::stats_mutex	extstore.c	/^    pthread_mutex_t stats_mutex;$/;"	m	struct:store_engine	file:	access:public
store_engine::version	extstore.c	/^    unsigned int version; \/* global version counter *\/$/;"	m	struct:store_engine	file:	access:public
store_engine::wbuf_stack	extstore.c	/^    _store_wbuf *wbuf_stack; \/* wbuf freelist *\/$/;"	m	struct:store_engine	file:	access:public
store_io_thread	extstore.c	/^} store_io_thread;$/;"	t	typeref:struct:__anon43	file:
store_item	memcached.h	/^enum store_item_type store_item(item *item, int comm, conn *c);$/;"	p	signature:(item *item, int comm, conn *c)
store_item	thread.c	/^enum store_item_type store_item(item *item, int comm, conn* c) {$/;"	f	signature:(item *item, int comm, conn* c)
store_item_type	memcached.h	/^enum store_item_type {$/;"	g
store_maint_thread	extstore.c	/^} store_maint_thread;$/;"	t	typeref:struct:__anon44	file:
store_page	extstore.c	/^} store_page;$/;"	t	typeref:struct:_store_page	file:
stress	t/stress-memcached.pl	/^sub stress {$/;"	s
subdir	doc/Makefile	/^subdir = doc$/;"	m
submitted	storage.c	/^    bool submitted;$/;"	m	struct:storage_compact_wrap	file:	access:public
substate	memcached.h	/^    enum bin_substates substate;$/;"	m	struct:conn	typeref:enum:conn::bin_substates	access:public
subtype	logger.h	/^    enum log_entry_subtype subtype;$/;"	m	struct:__anon57	typeref:enum:__anon57::log_entry_subtype	access:public
suffix_cache	memcached.h	/^    cache_t *suffix_cache;      \/* suffix cache *\/$/;"	m	struct:__anon54	access:public
suffixcurr	memcached.h	/^    char   **suffixcurr;$/;"	m	struct:conn	access:public
suffixleft	memcached.h	/^    int    suffixleft;$/;"	m	struct:conn	access:public
suffixlist	memcached.h	/^    char   **suffixlist;$/;"	m	struct:conn	access:public
suffixsize	memcached.h	/^    int    suffixsize;$/;"	m	struct:conn	access:public
supports_drop_priv	t/lib/MemcachedTest.pm	/^sub supports_drop_priv {$/;"	s
supports_extstore	t/lib/MemcachedTest.pm	/^sub supports_extstore {$/;"	s
supports_sasl	t/lib/MemcachedTest.pm	/^sub supports_sasl {$/;"	s
supports_udp	t/lib/MemcachedTest.pm	/^sub supports_udp {$/;"	s
sysconfdir	doc/Makefile	/^sysconfdir = ${prefix}\/etc$/;"	m
t	logger.h	/^    enum logger_watcher_type t; \/* stderr, client, syslog, etc *\/$/;"	m	struct:__anon59	typeref:enum:__anon59::logger_watcher_type	access:public
tail	thread.c	/^    CQ_ITEM *tail;$/;"	m	struct:conn_queue	file:	access:public
tail_repair_time	memcached.h	/^    int tail_repair_time;   \/* LRU tail refcount leak repair time *\/$/;"	m	struct:settings	access:public
tailrepairs	items.c	/^    uint64_t tailrepairs;$/;"	m	struct:__anon45	file:	access:public
tails	items.c	/^static item *tails[LARGEST_ID];$/;"	v	file:
target_alias	doc/Makefile	/^target_alias = $/;"	m
tcp_transport	memcached.h	/^    tcp_transport,$/;"	e	enum:network_transport
temp_lru	memcached.h	/^    bool temp_lru; \/* TTL < temporary_ttl uses TEMP_LRU *\/$/;"	m	struct:settings	access:public
temp_lru_size	items.c	/^static unsigned int temp_lru_size(int slabs_clsid) {$/;"	f	file:	signature:(int slabs_clsid)
temporary_ttl	memcached.h	/^    uint32_t temporary_ttl; \/* temporary LRU threshold *\/$/;"	m	struct:settings	access:public
test_binary_add	testapp.c	/^static enum test_return test_binary_add(void) {$/;"	f	file:	signature:(void)
test_binary_add_impl	testapp.c	/^static enum test_return test_binary_add_impl(const char *key, uint8_t cmd) {$/;"	f	file:	signature:(const char *key, uint8_t cmd)
test_binary_addq	testapp.c	/^static enum test_return test_binary_addq(void) {$/;"	f	file:	signature:(void)
test_binary_append	testapp.c	/^static enum test_return test_binary_append(void) {$/;"	f	file:	signature:(void)
test_binary_appendq	testapp.c	/^static enum test_return test_binary_appendq(void) {$/;"	f	file:	signature:(void)
test_binary_concat_impl	testapp.c	/^static enum test_return test_binary_concat_impl(const char *key, uint8_t cmd) {$/;"	f	file:	signature:(const char *key, uint8_t cmd)
test_binary_decr	testapp.c	/^static enum test_return test_binary_decr(void) {$/;"	f	file:	signature:(void)
test_binary_decr_impl	testapp.c	/^static enum test_return test_binary_decr_impl(const char* key, uint8_t cmd) {$/;"	f	file:	signature:(const char* key, uint8_t cmd)
test_binary_decrq	testapp.c	/^static enum test_return test_binary_decrq(void) {$/;"	f	file:	signature:(void)
test_binary_delete	testapp.c	/^static enum test_return test_binary_delete(void) {$/;"	f	file:	signature:(void)
test_binary_delete_impl	testapp.c	/^static enum test_return test_binary_delete_impl(const char *key, uint8_t cmd) {$/;"	f	file:	signature:(const char *key, uint8_t cmd)
test_binary_deleteq	testapp.c	/^static enum test_return test_binary_deleteq(void) {$/;"	f	file:	signature:(void)
test_binary_flush	testapp.c	/^static enum test_return test_binary_flush(void) {$/;"	f	file:	signature:(void)
test_binary_flush_impl	testapp.c	/^static enum test_return test_binary_flush_impl(const char *key, uint8_t cmd) {$/;"	f	file:	signature:(const char *key, uint8_t cmd)
test_binary_flushq	testapp.c	/^static enum test_return test_binary_flushq(void) {$/;"	f	file:	signature:(void)
test_binary_gat	testapp.c	/^static enum test_return test_binary_gat(void) {$/;"	f	file:	signature:(void)
test_binary_gatk	testapp.c	/^static enum test_return test_binary_gatk(void) {$/;"	f	file:	signature:(void)
test_binary_gatkq	testapp.c	/^static enum test_return test_binary_gatkq(void) {$/;"	f	file:	signature:(void)
test_binary_gatq	testapp.c	/^static enum test_return test_binary_gatq(void) {$/;"	f	file:	signature:(void)
test_binary_get	testapp.c	/^static enum test_return test_binary_get(void) {$/;"	f	file:	signature:(void)
test_binary_get_impl	testapp.c	/^static enum test_return test_binary_get_impl(const char *key, uint8_t cmd) {$/;"	f	file:	signature:(const char *key, uint8_t cmd)
test_binary_getk	testapp.c	/^static enum test_return test_binary_getk(void) {$/;"	f	file:	signature:(void)
test_binary_getkq	testapp.c	/^static enum test_return test_binary_getkq(void) {$/;"	f	file:	signature:(void)
test_binary_getq	testapp.c	/^static enum test_return test_binary_getq(void) {$/;"	f	file:	signature:(void)
test_binary_getq_impl	testapp.c	/^static enum test_return test_binary_getq_impl(const char *key, uint8_t cmd) {$/;"	f	file:	signature:(const char *key, uint8_t cmd)
test_binary_illegal	testapp.c	/^static enum test_return test_binary_illegal(void) {$/;"	f	file:	signature:(void)
test_binary_incr	testapp.c	/^static enum test_return test_binary_incr(void) {$/;"	f	file:	signature:(void)
test_binary_incr_impl	testapp.c	/^static enum test_return test_binary_incr_impl(const char* key, uint8_t cmd) {$/;"	f	file:	signature:(const char* key, uint8_t cmd)
test_binary_incrq	testapp.c	/^static enum test_return test_binary_incrq(void) {$/;"	f	file:	signature:(void)
test_binary_noop	testapp.c	/^static enum test_return test_binary_noop(void) {$/;"	f	file:	signature:(void)
test_binary_pipeline_hickup	testapp.c	/^static enum test_return test_binary_pipeline_hickup(void)$/;"	f	file:	signature:(void)
test_binary_pipeline_hickup_chunk	testapp.c	/^static enum test_return test_binary_pipeline_hickup_chunk(void *buffer, size_t buffersize) {$/;"	f	file:	signature:(void *buffer, size_t buffersize)
test_binary_prepend	testapp.c	/^static enum test_return test_binary_prepend(void) {$/;"	f	file:	signature:(void)
test_binary_prependq	testapp.c	/^static enum test_return test_binary_prependq(void) {$/;"	f	file:	signature:(void)
test_binary_quit	testapp.c	/^static enum test_return test_binary_quit(void) {$/;"	f	file:	signature:(void)
test_binary_quit_impl	testapp.c	/^static enum test_return test_binary_quit_impl(uint8_t cmd) {$/;"	f	file:	signature:(uint8_t cmd)
test_binary_quitq	testapp.c	/^static enum test_return test_binary_quitq(void) {$/;"	f	file:	signature:(void)
test_binary_replace	testapp.c	/^static enum test_return test_binary_replace(void) {$/;"	f	file:	signature:(void)
test_binary_replace_impl	testapp.c	/^static enum test_return test_binary_replace_impl(const char* key, uint8_t cmd) {$/;"	f	file:	signature:(const char* key, uint8_t cmd)
test_binary_replaceq	testapp.c	/^static enum test_return test_binary_replaceq(void) {$/;"	f	file:	signature:(void)
test_binary_set	testapp.c	/^static enum test_return test_binary_set(void) {$/;"	f	file:	signature:(void)
test_binary_set_impl	testapp.c	/^static enum test_return test_binary_set_impl(const char *key, uint8_t cmd) {$/;"	f	file:	signature:(const char *key, uint8_t cmd)
test_binary_setq	testapp.c	/^static enum test_return test_binary_setq(void) {$/;"	f	file:	signature:(void)
test_binary_stat	testapp.c	/^static enum test_return test_binary_stat(void) {$/;"	f	file:	signature:(void)
test_binary_version	testapp.c	/^static enum test_return test_binary_version(void) {$/;"	f	file:	signature:(void)
test_count	stats.c	/^static int test_count = 0;$/;"	v	file:
test_equals_int	stats.c	/^static void test_equals_int(char *what, int a, int b) { test_count++; if (a != b) fail(what); }$/;"	f	file:	signature:(char *what, int a, int b)
test_equals_ptr	stats.c	/^static void test_equals_ptr(char *what, void *a, void *b) { test_count++; if (a != b) fail(what); }$/;"	f	file:	signature:(char *what, void *a, void *b)
test_equals_str	stats.c	/^static void test_equals_str(char *what, const char *a, const char *b) { test_count++; if (strcmp(a, b)) fail(what); }$/;"	f	file:	signature:(char *what, const char *a, const char *b)
test_equals_ull	stats.c	/^static void test_equals_ull(char *what, uint64_t a, uint64_t b) { test_count++; if (a != b) fail(what); }$/;"	f	file:	signature:(char *what, uint64_t a, uint64_t b)
test_issue_101	testapp.c	/^static enum test_return test_issue_101(void) {$/;"	f	file:	signature:(void)
test_issue_102	testapp.c	/^static enum test_return test_issue_102(void) {$/;"	f	file:	signature:(void)
test_issue_161	testapp.c	/^static enum test_return test_issue_161(void)$/;"	f	file:	signature:(void)
test_issue_44	testapp.c	/^static enum test_return test_issue_44(void) {$/;"	f	file:	signature:(void)
test_issue_92	testapp.c	/^static enum test_return test_issue_92(void) {$/;"	f	file:	signature:(void)
test_notequals_ptr	stats.c	/^static void test_notequals_ptr(char *what, void *a, void *b) { test_count++; if (a == b) fail(what); }$/;"	f	file:	signature:(char *what, void *a, void *b)
test_notnull_ptr	stats.c	/^static void test_notnull_ptr(char *what, void *a) { test_count++; if (NULL == a) fail(what); }$/;"	f	file:	signature:(char *what, void *a)
test_prefix_dump	stats.c	/^static void test_prefix_dump() {$/;"	f	file:
test_prefix_find	stats.c	/^static void test_prefix_find() {$/;"	f	file:
test_prefix_record_delete	stats.c	/^static void test_prefix_record_delete() {$/;"	f	file:
test_prefix_record_get	stats.c	/^static void test_prefix_record_get() {$/;"	f	file:
test_prefix_record_set	stats.c	/^static void test_prefix_record_set() {$/;"	f	file:
test_return	testapp.c	/^enum test_return { TEST_SKIP, TEST_PASS, TEST_FAIL };$/;"	g	file:
test_safe_strtol	testapp.c	/^static enum test_return test_safe_strtol(void) {$/;"	f	file:	signature:(void)
test_safe_strtoll	testapp.c	/^static enum test_return test_safe_strtoll(void) {$/;"	f	file:	signature:(void)
test_safe_strtoul	testapp.c	/^static enum test_return test_safe_strtoul(void) {$/;"	f	file:	signature:(void)
test_safe_strtoull	testapp.c	/^static enum test_return test_safe_strtoull(void) {$/;"	f	file:	signature:(void)
test_varargs_macros	configure	/^  test_varargs_macros ();$/;"	f
test_vperror	testapp.c	/^static enum test_return test_vperror(void) {$/;"	f	file:	signature:(void)
testcase	testapp.c	/^struct testcase {$/;"	s	file:
testcase::description	testapp.c	/^    const char *description;$/;"	m	struct:testcase	file:	access:public
testcase::function	testapp.c	/^    TEST_FUNC function;$/;"	m	struct:testcase	file:	access:public
testcases	testapp.c	/^struct testcase testcases[] = {$/;"	v	typeref:struct:testcase
thread	memcached.h	/^    LIBEVENT_THREAD *thread; \/* Pointer to the thread object serving this connection *\/$/;"	m	struct:conn	access:public
thread_id	memcached.h	/^    pthread_t thread_id;        \/* unique ID of this thread  该线程ID *\/$/;"	m	struct:__anon54	access:public
thread_libevent_process	thread.c	/^static void thread_libevent_process(int fd, short which, void *arg) {$/;"	f	file:	signature:(int fd, short which, void *arg)
thread_libevent_process	thread.c	/^static void thread_libevent_process(int fd, short which, void *arg);$/;"	p	file:	signature:(int fd, short which, void *arg)
thread_stats	memcached.h	/^struct thread_stats {$/;"	s
thread_stats::lru_hits	memcached.h	/^    uint64_t lru_hits[POWER_LARGEST];$/;"	m	struct:thread_stats	access:public
thread_stats::mutex	memcached.h	/^    pthread_mutex_t   mutex;    \/\/ 用于维护本结构的互斥锁$/;"	m	struct:thread_stats	access:public
thread_stats::slab_stats	memcached.h	/^    struct slab_stats slab_stats[MAX_NUMBER_OF_SLAB_CLASSES];$/;"	m	struct:thread_stats	typeref:struct:thread_stats::slab_stats	access:public
threadlocal_stats_aggregate	memcached.h	/^void threadlocal_stats_aggregate(struct thread_stats *stats);$/;"	p	signature:(struct thread_stats *stats)
threadlocal_stats_aggregate	thread.c	/^void threadlocal_stats_aggregate(struct thread_stats *stats) {$/;"	f	signature:(struct thread_stats *stats)
threadlocal_stats_reset	memcached.h	/^void threadlocal_stats_reset(void);$/;"	p	signature:(void)
threadlocal_stats_reset	thread.c	/^void threadlocal_stats_reset(void) {$/;"	f	signature:(void)
threads	thread.c	/^static LIBEVENT_THREAD *threads;$/;"	v	file:
time	memcached.h	/^    rel_time_t      time;       \/* least recent access *\/$/;"	m	struct:__anon52	access:public
time	memcached.h	/^    rel_time_t      time;       \/* least recent access *\/$/;"	m	struct:_stritem	access:public
time_in_listen_disabled_us	memcached.h	/^    uint64_t      time_in_listen_disabled_us;  \/* elapsed time in microseconds while server unable to process new connections *\/$/;"	m	struct:stats	access:public
token_s	memcached.c	/^typedef struct token_s {$/;"	s	file:
token_s::length	memcached.c	/^    size_t length;$/;"	m	struct:token_s	file:	access:public
token_s::value	memcached.c	/^    char *value;$/;"	m	struct:token_s	file:	access:public
token_t	memcached.c	/^} token_t;$/;"	t	typeref:struct:token_s	file:
tokenize_command	memcached.c	/^static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {$/;"	f	file:	signature:(char *command, token_t *tokens, const size_t max_tokens)
too_big	t/binary-extstore.t	/^sub too_big {$/;"	s
too_big	t/binary-sasl.t	/^sub too_big {$/;"	s
too_big	t/binary.t	/^sub too_big {$/;"	s
top_build_prefix	doc/Makefile	/^top_build_prefix = ..\/$/;"	m
top_builddir	doc/Makefile	/^top_builddir = ..$/;"	m
top_srcdir	doc/Makefile	/^top_srcdir = ..$/;"	m
total_conns	memcached.h	/^    uint64_t      total_conns;$/;"	m	struct:stats	access:public
total_items	memcached.h	/^    uint64_t      total_items;$/;"	m	struct:stats	access:public
total_pages	slabs.h	/^    long int total_pages;$/;"	m	struct:__anon42	access:public
total_prefix_size	stats.c	/^static int total_prefix_size = 0;$/;"	v	file:
touch	t/binary-extstore.t	/^sub touch {$/;"	s
touch	t/binary.t	/^sub touch {$/;"	s
touch_command	testapp.c	/^static off_t touch_command(char* buf,$/;"	f	file:	signature:(char* buf, size_t bufsz, uint8_t cmd, const void* key, size_t keylen, uint32_t exptime)
transform	doc/Makefile	/^transform = $(program_transform_name)$/;"	m
transmit	memcached.c	/^static enum transmit_result transmit(conn *c) {$/;"	f	file:	signature:(conn *c)
transmit	memcached.c	/^static enum transmit_result transmit(conn *c);$/;"	p	file:	signature:(conn *c)
transmit_result	memcached.c	/^enum transmit_result {$/;"	g	file:
transport	memcached.h	/^    enum network_transport transport; \/* what transport is used by this connection  该连接session使用的协议类型 *\/$/;"	m	struct:conn	typeref:enum:conn::network_transport	access:public
transport	thread.c	/^    enum network_transport     transport;$/;"	m	struct:conn_queue_item	typeref:enum:conn_queue_item::network_transport	file:	access:public
try_read_command	memcached.c	/^static int try_read_command(conn *c) {$/;"	f	file:	signature:(conn *c)
try_read_command	memcached.c	/^static int try_read_command(conn *c);$/;"	p	file:	signature:(conn *c)
try_read_network	memcached.c	/^static enum try_read_result try_read_network(conn *c) {$/;"	f	file:	signature:(conn *c)
try_read_network	memcached.c	/^static enum try_read_result try_read_network(conn *c);$/;"	p	file:	signature:(conn *c)
try_read_result	memcached.c	/^enum try_read_result {$/;"	g	file:
try_read_udp	memcached.c	/^static enum try_read_result try_read_udp(conn *c) {$/;"	f	file:	signature:(conn *c)
try_read_udp	memcached.c	/^static enum try_read_result try_read_udp(conn *c);$/;"	p	file:	signature:(conn *c)
ttl	logger.h	/^    rel_time_t ttl;$/;"	m	struct:logentry_item_store	access:public
ttl_hourplus	crawler.h	/^    uint64_t ttl_hourplus;$/;"	m	struct:__anon4	access:public
tv	logger.h	/^    struct timeval tv; \/* not monotonic! *\/$/;"	m	struct:_logentry	typeref:struct:_logentry::timeval	access:public
ub1	assoc.c	/^typedef  unsigned       char ub1;   \/* unsigned 1-byte quantities *\/$/;"	t	file:
ub4	assoc.c	/^typedef  unsigned long  int  ub4;   \/* unsigned 4-byte quantities *\/$/;"	t	file:
udp_delete_test	t/udp.t	/^sub udp_delete_test {$/;"	s
udp_get_test	t/udp.t	/^sub udp_get_test {$/;"	s
udp_incr_decr_test	t/udp.t	/^sub udp_incr_decr_test {$/;"	s
udp_set_test	t/udp.t	/^sub udp_set_test {$/;"	s
udp_transport	memcached.h	/^    udp_transport$/;"	e	enum:network_transport
udpport	memcached.h	/^    int udpport;$/;"	m	struct:settings	access:public
udpport	t/lib/MemcachedTest.pm	/^sub udpport { $_[0]{udpport} }$/;"	s
unfetched	memcached.h	/^    uint64_t        unfetched;  \/* items reclaimed unfetched during this crawl. *\/$/;"	m	struct:__anon52	access:public
unlikely	memcached.h	778;"	d
update_event	memcached.c	/^static bool update_event(conn *c, const int new_flags) {$/;"	f	file:	signature:(conn *c, const int new_flags)
update_event	memcached.c	/^static bool update_event(conn *c, const int new_flags);$/;"	p	file:	signature:(conn *c, const int new_flags)
uriencode	util.c	/^bool uriencode(const char *src, char *dst, const size_t srclen, const size_t dstlen) {$/;"	f	signature:(const char *src, char *dst, const size_t srclen, const size_t dstlen)
uriencode	util.h	/^bool uriencode(const char *src, char *dst, const size_t srclen, const size_t dstlen);$/;"	p	signature:(const char *src, char *dst, const size_t srclen, const size_t dstlen)
uriencode_init	util.c	/^void uriencode_init(void) {$/;"	f	signature:(void)
uriencode_init	util.h	/^void uriencode_init(void);$/;"	p	signature:(void)
uriencode_map	util.c	/^static char *uriencode_map[256];$/;"	v	file:
uriencode_str	util.c	/^static char uriencode_str[768];$/;"	v	file:
usage	memcached.c	/^static void usage(void) {$/;"	f	file:	signature:(void)
usage_license	memcached.c	/^static void usage_license(void) {$/;"	f	file:	signature:(void)
use_cas	memcached.h	/^    bool use_cas;$/;"	m	struct:settings	access:public
used	memcached.h	/^    int              used;      \/* chunk space used *\/$/;"	m	struct:_strchunk	access:public
validate_response_header	testapp.c	/^static void validate_response_header(protocol_binary_response_no_extras *response,$/;"	f	file:	signature:(protocol_binary_response_no_extras *response, uint8_t cmd, uint16_t status)
value	memcached.c	/^    char *value;$/;"	m	struct:token_s	file:	access:public
value	protocol_binary.h	/^                uint64_t value;$/;"	m	struct:__anon29::__anon30::__anon31	access:public
verbose	memcached.h	/^    int verbose;$/;"	m	struct:settings	access:public
version	extstore.c	/^    unsigned int version; \/* global version counter *\/$/;"	m	struct:store_engine	file:	access:public
version	extstore.c	/^    unsigned int version;$/;"	m	struct:_store_page	file:	access:public
version	extstore.h	/^    uint64_t version;$/;"	m	struct:extstore_page_data	access:public
version	t/binary-extstore.t	/^sub version {$/;"	s
version	t/binary-sasl.t	/^sub version {$/;"	s
version	t/binary.t	/^sub version {$/;"	s
vperror	util.c	/^void vperror(const char *fmt, ...) {$/;"	f	signature:(const char *fmt, ...)
wait_for_early_second	t/expirations.t	/^sub wait_for_early_second {$/;"	s
wait_for_process	timedrun.c	/^static int wait_for_process(pid_t pid)$/;"	f	file:	signature:(pid_t pid)
wait_for_thread_registration	thread.c	/^static void wait_for_thread_registration(int nthreads) {$/;"	f	file:	signature:(int nthreads)
warm_lru_pct	memcached.h	/^    int warm_lru_pct; \/* percentage of slab space for WARM_LRU *\/$/;"	m	struct:settings	access:public
warm_max_factor	memcached.h	/^    double warm_max_factor; \/* WARM tail age relative to COLD tail *\/$/;"	m	struct:settings	access:public
was_found	logger.h	/^    uint8_t was_found;$/;"	m	struct:logentry_item_get	access:public
watcher_count	logger.c	/^int watcher_count = 0;$/;"	v
watcher_sent	logger.h	/^    uint64_t watcher_sent;$/;"	m	struct:logger_stats	access:public
watcher_skipped	logger.h	/^    uint64_t watcher_skipped;$/;"	m	struct:logger_stats	access:public
watchers	logger.c	/^logger_watcher *watchers[20];$/;"	v
watchers_pollfds	logger.c	/^struct pollfd watchers_pollfds[20];$/;"	v	typeref:struct:pollfd
wbuf	extstore.c	/^    _store_wbuf *wbuf; \/* currently active wbuf from the stack *\/$/;"	m	struct:_store_page	file:	access:public
wbuf	memcached.h	/^    char   *wbuf;   \/\/指向一片写缓冲区$/;"	m	struct:conn	access:public
wbuf_count	extstore.h	/^    unsigned int wbuf_count; \/\/ this might get locked to "2 per active page"$/;"	m	struct:extstore_conf	access:public
wbuf_new	extstore.c	/^static _store_wbuf *wbuf_new(size_t size) {$/;"	f	file:	signature:(size_t size)
wbuf_size	extstore.h	/^    unsigned int wbuf_size; \/\/ must divide cleanly into page_size$/;"	m	struct:extstore_conf	access:public
wbuf_stack	extstore.c	/^    _store_wbuf *wbuf_stack; \/* wbuf freelist *\/$/;"	m	struct:store_engine	file:	access:public
wbytes	memcached.h	/^    int    wbytes;  \/\/ 写缓冲区中已经写入的数据长度?$/;"	m	struct:conn	access:public
wcurr	memcached.h	/^    char   *wcurr;  \/\/ 写指针$/;"	m	struct:conn	access:public
which	memcached.h	/^    short  which;   \/** which events were just triggered *\/$/;"	m	struct:conn	access:public
window_cur	slab_automove.c	/^    uint32_t window_cur;$/;"	m	struct:__anon48	file:	access:public
window_cur	slab_automove_extstore.c	/^    uint32_t window_cur;$/;"	m	struct:__anon56	file:	access:public
window_data	slab_automove.c	/^    struct window_data *window_data;$/;"	m	struct:__anon48	typeref:struct:__anon48::window_data	file:	access:public
window_data	slab_automove.c	/^struct window_data {$/;"	s	file:
window_data	slab_automove_extstore.c	/^    struct window_data *window_data;$/;"	m	struct:__anon56	typeref:struct:__anon56::window_data	file:	access:public
window_data	slab_automove_extstore.c	/^struct window_data {$/;"	s	file:
window_data::age	slab_automove.c	/^    uint64_t age;$/;"	m	struct:window_data	file:	access:public
window_data::age	slab_automove_extstore.c	/^    uint64_t age;$/;"	m	struct:window_data	file:	access:public
window_data::dirty	slab_automove.c	/^    uint64_t dirty;$/;"	m	struct:window_data	file:	access:public
window_data::dirty	slab_automove_extstore.c	/^    uint64_t dirty;$/;"	m	struct:window_data	file:	access:public
window_data::evicted	slab_automove.c	/^    uint64_t evicted;$/;"	m	struct:window_data	file:	access:public
window_data::evicted	slab_automove_extstore.c	/^    uint64_t evicted;$/;"	m	struct:window_data	file:	access:public
window_data::excess_free	slab_automove_extstore.c	/^    unsigned int excess_free;$/;"	m	struct:window_data	file:	access:public
window_data::relaxed	slab_automove_extstore.c	/^    unsigned int relaxed;$/;"	m	struct:window_data	file:	access:public
window_global	slab_automove_extstore.c	/^    struct window_global *window_global;$/;"	m	struct:__anon56	typeref:struct:__anon56::window_global	file:	access:public
window_global	slab_automove_extstore.c	/^struct window_global {$/;"	s	file:
window_global::pool_high	slab_automove_extstore.c	/^    uint32_t pool_high;$/;"	m	struct:window_global	file:	access:public
window_global::pool_low	slab_automove_extstore.c	/^    uint32_t pool_low;$/;"	m	struct:window_global	file:	access:public
window_global_sum	slab_automove_extstore.c	/^static void window_global_sum(struct window_global *wg,$/;"	f	file:	signature:(struct window_global *wg, struct window_global *w, uint32_t size)
window_size	slab_automove.c	/^    uint32_t window_size;$/;"	m	struct:__anon48	file:	access:public
window_size	slab_automove_extstore.c	/^    uint32_t window_size;$/;"	m	struct:__anon56	file:	access:public
window_sum	slab_automove.c	/^static void window_sum(struct window_data *wd, struct window_data *w, uint32_t size) {$/;"	f	file:	signature:(struct window_data *wd, struct window_data *w, uint32_t size)
window_sum	slab_automove_extstore.c	/^static void window_sum(struct window_data *wd, struct window_data *w,$/;"	f	file:	signature:(struct window_data *wd, struct window_data *w, uint32_t size)
worker_dropped	logger.h	/^    uint64_t worker_dropped;$/;"	m	struct:logger_stats	access:public
worker_hang_lock	thread.c	/^static pthread_mutex_t worker_hang_lock;$/;"	v	file:
worker_libevent	thread.c	/^static void *worker_libevent(void *arg) {$/;"	f	file:	signature:(void *arg)
worker_written	logger.h	/^    uint64_t worker_written;$/;"	m	struct:logger_stats	access:public
write_and_free	memcached.c	/^static void write_and_free(conn *c, char *buf, int bytes) {$/;"	f	file:	signature:(conn *c, char *buf, int bytes)
write_and_free	memcached.c	/^static void write_and_free(conn *c, char *buf, int bytes);$/;"	p	file:	signature:(conn *c, char *buf, int bytes)
write_and_free	memcached.h	/^    void   *write_and_free; \/** free this memory after finishing writing *\/$/;"	m	struct:conn	access:public
write_and_go	memcached.h	/^    enum conn_states  write_and_go;$/;"	m	struct:conn	typeref:enum:conn::conn_states	access:public
write_bin_error	memcached.c	/^static void write_bin_error(conn *c, protocol_binary_response_status err,$/;"	f	file:	signature:(conn *c, protocol_binary_response_status err, const char *errstr, int swallow)
write_bin_error	memcached.c	/^static void write_bin_error(conn *c, protocol_binary_response_status err,$/;"	p	file:	signature:(conn *c, protocol_binary_response_status err, const char *errstr, int swallow)
write_bin_miss_response	memcached.c	/^static void write_bin_miss_response(conn *c, char *key, size_t nkey) {$/;"	f	file:	signature:(conn *c, char *key, size_t nkey)
write_bin_miss_response	memcached.c	/^static void write_bin_miss_response(conn *c, char *key, size_t nkey);$/;"	p	file:	signature:(conn *c, char *key, size_t nkey)
write_bin_response	memcached.c	/^static void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {$/;"	f	file:	signature:(conn *c, void *d, int hlen, int keylen, int dlen)
written	extstore.c	/^    unsigned int written; \/* item offsets can be past written if wbuf not flushed *\/$/;"	m	struct:_store_page	file:	access:public
written	logger.h	/^    uint64_t written; \/* entries written to the buffer *\/$/;"	m	struct:_logger	access:public
wsize	memcached.h	/^    int    wsize;   \/\/ 写缓冲区长度$/;"	m	struct:conn	access:public
xisspace	util.c	47;"	d	file:
