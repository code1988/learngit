                                    lua和C的通信约定
/*****************************************************************************************
1. 所有lua中的值由lua来管理（包括创建和回收）
2. C只有通过一系列API函数（实质就是通信协议）来操作lua中的值的权利
3. 栈是C和lua所有数据交互的平台
4. 一个C value入栈就是进入了lua的世界，lua会生成一个对应的结构并管理起来，成为lua value，从此就不再依赖这个C value
*****************************************************************************************/

                                    栈
/* ***************************************************************************************
1. lua的栈向上生长，即栈底在下，栈顶在上
2. lua的堆栈有2种索引方法：
    正数索引 - 栈底是1,然后往上逐渐+1直到栈顶（正数索引不需要知道栈的大小，就能知道栈底在哪）
    负数索引 - 栈顶是-1,然后往下逐渐-1直到栈底（负数索引不需要知道栈的大小，就能知道栈顶在哪）    
*****************************************************************************************/

                                    lua调用C
/* ***************************************************************************************
1. C函数必须遵循的格式       
    typedef int (lua_CFunction *)(lua_Stat *L)
                    
2. 相关的API函数
    void lua_register(lua_State *L,const char *name,lua_CFunction f)
    通过一个宏定义把C函数f注册到全局变量name中： 
        #define lua_register(L,n,f) (lua_pushcfuncton(L,f),lua_setglobal(L,n))
    具体的注册流程：
        创建C闭包，将C函数注册到该闭包  
        将C闭包压栈，此时位于栈顶  
        从栈顶弹出一个值，也就是C闭包,赋值给全局table中的元素name
        至此完成了C函数在lua全局table中的注册

    lua_to*(lua_State *L,int index)
    把索引处的"*"指定类型的lua值从栈中取出

    lua_push*(lua_State *L,C value)
    把一个"*"指定类型的C value压栈以便传递给lua
*****************************************************************************************/
