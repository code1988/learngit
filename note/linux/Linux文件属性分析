-----------------------------------------------------------------------------------------------------------------------
stat结构包含了一个文件有关的所有信息
struct stat {
    mode_t  st_mode;    // 文件类型 | set-user-ID/set-group-ID | 访问权限
    uid_t   st_uid;     // 文件所有者ID
    gid_t   st_gid;     // 文件组所有者ID
    off_t   st_size;    // 表示以字节为单位的文件长度，只对普通文件、目录文件、链接文件有意义
    nlink_t st_nlink;   // 文件的硬链接计数，只有当该值为0时，文件才可以被真正删除
    time_t  st_atime;   // 文件数据的最后访问时间
    time_t  st_mtime;   // 文件数据的最后修改时间
    time_t  st_ctime;   // i节点状态的最后修改时间
    dev_t   st_dev;     // 该文件所在的文件系统的设备号
    dev_t   st_rdev;    // 字符特殊文件和块特殊文件才有该值，代表实际设备的设备号
}

-----------------------------------------------------------------------------------------------------------------------
1. 用ls -l命令可以列出文件的所有信息，第一列表示文件类型：
    -   普通文件
    d   目录文件
    l   符号链接文件
    c   字符设备
    b   块设备
    s   套接字
    p   管道
    文件类型信息包含在stat结构的st_mode成员中，可以用S_IS*宏确定文件类型

2. linux权限机制采用ugo模式，u（user）表示所属用户，g（group）标识所属组，o（other）表示除了所属用户、所属组以外的其他用户
    u、g、o都有r、w、x三个权限，所以ugo模式是三类九种基本权限

    chown   修改文件的所属用户或组，用法如下：
            1). 若同时修改用户名和组名，则两者都写上
                    chown code5:code5 testfile
            2). 若只修改用户名，则去掉用户名后面的冒号和组名
                    chown code5 testfile
            3). 若只修改组名，则去掉冒号前面的用户名
                    chown :code5 testfile
            4). 若只修改用户名，组名采用登录时的组名，则去掉冒号后面的组名（这种不常用）
                    chown code5:
            备注： 上述用到的":"可以用"."替代;chown命令的操作权限为root

    chgrp   修改文件或目录的所属组
    文件访问权限信息也包含在stat结构的st_mode成员中

3. 内核会给每个进程关联三个和进程ID无关的用户ID(组ID同理):
        真实用户ID：就是登陆用户的uid，用来标识我们究竟是谁
        有效用户ID：用来决定我们对文件的访问权限
        保存的set-user-ID: 由exec函数拷贝有效用户ID而来，如果要执行的文件设置了set-user-ID位，则先根据文件所有者的用户ID设置进程的有效用户ID，然后再拷贝有效用户ID

    每个文件也都有一个所有者的用户ID和组ID，分别对应stat结构中的st_uid和st_gid.

    默认情况下，当执行一个程序文件时，进程的有效用户ID就是真实用户ID；
    但如果程序文件的st_mode字段中设置了set-user-ID位，当执行该文件时，进程的有效用户ID就会变成文件所有者的用户ID（st_uid）
    设置方法为"chmod u+x filename"或"chmod 4777 filename"

    注意： 拥有超级用户特权,意味着其有效用户ID必为0,其余两个用户ID随意!!!

    @函数名 ： int setuid(uid_t uid)
    @作用   ： 用来设置上面3种用户ID
    @规则   ： 若进程具有超级用户特权，则将3种用户ID全部设置为uid，且uid可以随意指定
               若进程没有超级用户特权，uid存在限制(必须为实际用户ID或保存的set-user-ID)，该函数才会将有效用户ID设置为uid

    综合上面这些规则，产生一种重要的应用场景，依次以/usr/bin/passwd和/usr/bin/sudo为例:
        文件/usr/bin/passwd所有者是root，而且设置了set-user-ID位，所以当任何进程执行了该文件后，都得到了超级用户特权，从而可以将新口令写入口令文件
        文件/usr/bin/sudo则更进一步，当任何进程执行了该文件得到超级用户特权后，还执行了setuid(ROOT_UID)，至此进程的3种用户ID全部变成了0,成为彻底的root用户

    @函数名 ： int seteuid(uid_t uid)
    @作用   ： 只用来设置有效用户ID
    @规则   ： 若进程具有超级用户特权，则只将有效用户ID设置为uid，且uid可以随意制定
               若进程没有超级用户特权，uid存在限制(必须为实际用户ID或保存的set-user-ID)，该函数才会将有效用户ID设置为uid，这种情况下其实和上面的setuid用法一样

