相比在编译期间显式链接，运行前隐式加载的方式，运行时显式链接并加载的方式显然更加灵活。
这种方式可以控制程序在需要时加载指定模块，甚至可以在不需要时卸载，从而减少程序启动时间和内存消耗，以及实现热更新这种功能。

linux上提供了以下4个api来支持共享对象的显式运行时访问：

void *dlopen(const char *filename, int flags)   加载一个共享对象, 同一个共享对象不会重复加载(只会递增一下计数器)
@filename   要加载的共享对象
            如果传入NULL则返回的句柄不但包括了主程序本身，还包括了程序启动时自动加载的共享对象，以及使用RTLD_GLOBAL方式的dlopen打开的共享对象
@flags      指定该共享对象中符号的解析方式，有2个标志必选其一：
                RTLD_LAZY       对该共享对象中的函数符号使用延迟绑定策略，而变量符号总是在该共享对象加载时就立即解析
                RTLD_NOW        加载时就解析完所有符号
            另有以下几个可选标志：
                RTLD_GLOBAL     指定该共享对象中的符号对在其后加载的共享对象可见(即便该共享对象使用了延迟绑定策略，这种向后可见性仍旧有效)
                RTLD_LOCAL      指定该共享对象中的符号对在其后加载的共享对象不可见(这也是RTLD_GLOBAL和RTLD_LOCAL都不指定时的缺省特性)

int dlclose(void *handle)   递减目标共享对象的引用计数，如果递减后为0则卸载该共享对象

void *dlsym(void *handle, const char *symbol)   从目标句柄包含的共享对象/可执行对象的动态符号表中查找目标符号，然后返回对应的运行时地址
@handle     除了可以是dlopen返回的句柄外，还可以是以下2个特殊的伪句柄：
                RTLD_DEFAULT    从全局作用域中按装载顺序查找目标符号，返回第一个
                                作用类似于传入一个特殊dlopen句柄(filename为NULL)，显然使用这个伪句柄的好处是可以省去dlopen和dlclose操作
                RTLD_NEXT       从全局作用域中按装载顺序查找目标符号，返回第二个

以下这个例子用来印证RTLD_GLOBAL的作用:
// hello.c
#include <stdio.h>

void say_hello(void)
{
    printf("hello!\n");
}

// say.c
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

typedef void(*say_t)(void);

void say(void)
{
    /* 等效代码
    void *handle = dlopen(NULL, RTLD_LAZY);     // filename为NULL意味着返回的句柄会包含事先使用RTLD_GLOBAL方式的dlopen打开的libhello.so
    if (!handle) {
        printf("%s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    say_t say = dlsym(handle, "say_hello");
    */
    say_t say = dlsym(RTLD_DEFAULT, "say_hello");
    if (!say) {
        printf("%s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    say();
}

// main.c
#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

typedef void(*say_t)(void);

int main(int argc,  char *argv[]) {
    void *handle = NULL;
#ifdef GLOBAL
    handle = dlopen("./libhello.so", RTLD_LAZY| RTLD_GLOBAL);   // RTLD_GLOBAL使得libhello.so中的符号对后续加载的共享对象可见
#elif LOCAL
    handle = dlopen("./libhello.so", RTLD_LAZY| RTLD_LOCAL);    // RTLD_LOCAL使得libhello.so中的符号对后续加载的共享对象不可见
#endif
    if (!handle) {
        printf("%s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    handle = dlopen("./libsay.so", RTLD_LAZY);
    if (!handle) {
        printf("%s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    say_t say = NULL;
    say = dlsym(handle, "say");
    if (!say) {
        printf("%s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    say();

    return 0;
}

$ gcc -Wall -D_GNU_SOURCE -fpic -shared say.c -o libsay.so
$ gcc -Wall -fpic -shared hello.c -o libhello.so
$ gcc -Wall main.c -o main -ldl -DGLOBAL
$ ./main
    hello!
$ gcc -Wall main.c -o main -ldl -DLOCAL
$ ./main
    undefined symbol: say_hello

