								IO多路复用
----------------------------------------------------------------------------------------------------
	IO多路复用是指内核一旦发现进程指定的一个或多个IO满足设定的条件（可读、可写等等），它就通知该进程.
	与多进程和多线程相比，这种技术的最大优势是系统开销少
----------------------------------------------------------------------------------------------------
								
								select模型
-------------------------------------------------------------------------------------------------------------
	1. select会修改传入的句柄集合fd_set，导致每次调用select都需要重新初始化fd_set,再将其从用户空间拷贝到内核空间
	2. 如果任何一个fd设定的条件被触发，select仅仅会返回，但并不告诉用户层是哪个fd，导致用户只能逐个fd遍历
	3. 支持的文件描述符fd数量太少了，缺省是 FD_SETSIZE = 1024,虽然可以手动修改，但由于select采用轮询的方式扫描
       fd来判断是否有哪个fd被触发，导致fd越多，性能越差
	4. select不是线程安全的"if a fd being monitored by select() is closed in another thread,the result is unspecified"
    5. select的触发方式是水平触发，意味着用户进程如果没有完成对一个已经触发的fd进行IO操作，那么之后每次调用select
       还是会将这些fd通知给用户进程

								poll模型
-------------------------------------------------------------------------------------------------------------
	poll的机制与select类似，相比select，poll最主要的改进，是采用链表管理fd，因此没有了监视的fd数量限制

                                epoll模型
-------------------------------------------------------------------------------------------------------------
    epoll和select/poll在调用接口上的不同：select/poll都只提供了一个函数，而epoll拆分为3个函数：
        1. 调用epoll_create创建一个epoll句柄
        2. 调用epoll_ctl向epoll句柄中注册需要监控的fd
        3. 调用epoll_wait收集被触发的fd
    epoll修复了select和poll的绝大部分缺陷：
    1. epoll每次调用epoll_ctl把新的事件注册到epoll句柄，而不是在epoll_wait时重复拷贝，epoll保证了每个fd只会被拷贝一次
    2. 在被触发返回时，epoll会告诉你具体哪个sock被触发了，不用再去遍历
    3. epoll是线程安全的

