1. 僵尸进程的产生
-----------------------------------------------------------------------------------------------------------------------
    每个进程退出的时候（调用exit），内核释放该进程所有的资源，但仍为其保留一定的信息，包括进程号、退出状态、运行时间等，
    直到父进程通过wait/waitpid来取时才彻底释放，这保证了父进程可以获取到子进程结束时的状态信息。

    备注：僵尸进程的父进程必然存在
          僵尸状态是每个子进程在结束的时候必经的阶段

2. 僵尸进程的危害
-----------------------------------------------------------------------------------------------------------------------
    但这样就导致了如果父进程不调用wait/waitpid的话，其进程号就会一直被占用，但系统所能使用的进程号是有限的，如果产生了大
    量的僵尸进程，系统将因为没有可用的进程号导致不能产生新的进程

3. 主动收尸方法
-----------------------------------------------------------------------------------------------------------------------
    [1]. 父进程直接调用wait/waitpid等待子进程结束，但这样会导致父进程挂起，干不了其他事
    [2]. 如果父进程关心子进程结束的状态信息，则可以为SIGCHLD信号安装一个handler，因为子进程结束时，内核会发这个信号给父
         进程，可以在handler中调用wait回收
    [3]. 如果父进程不关心子进程结束的状态信息，则可以用siginal(SIGCHLD,SIG_IGN)显式通知内核忽略该信号，那么子进程结束时，
         内核会负责回收，并不再给父进程发信号
    [4]. 父进程fork一个子进程，子进程fork一个孙进程，然后子进程退出（父进程记得回收），这样孙进程会被init接管，孙进程推
         出后，init进程会负责回收

    备注：通常采用第3种方式收尸

4. 被动补救方法
-----------------------------------------------------------------------------------------------------------------------
    由于僵尸进程的父进程必然存在，所以可以通过杀死僵尸进程的父进程，僵尸进程变成孤儿进程，那么init进程会自动接收它，为它
    收尸

