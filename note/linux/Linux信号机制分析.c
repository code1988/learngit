1. 信号的本质
    软中断信号，简称信号，用来通知进程发生了异步事件,是IPC机制中唯一的异步通信机制
    信号是在软件层次上对中断机制的一种模拟，所以进程收到一个信号和处理器收到一个中断请求可以说是一样的
    
    收到信号的进程对各种信号分为3种处理方法(通过系统调用signal来指定进程对某个信号的处理行为):
        [1]. 类似中断的处理程序。对于需要处理的信号，进程可以注册处理函数
        [2]. 忽略某个信号
        [3]. 保留系统的缺省操作去处理该信号

2. 信号的种类
    非实时信号：1-31，都是不可靠信号，不支持排队，所以信号可能丢失
    实时信号：32-63,都是可靠信号，支持排队，所以信号不会丢失

3. 信号在进程中注册
    进程控制块task_struct中有一块区域用于记录本进程的信号相关信息
    其中struct sigpending pending记录了本进程等待处理的信号队列（基于linux-3.10.49），定义如下：
        struct sigpending{
            struct list_head list;
            sigset_t signal;
        };
        signal域每一位对应一个信号，是待处理信号的集合
        list域指向sigqueue链表，记录了待处理信号的具体信息，定义如下：
            struct sigqueue{
                struct list_head list;
                int flags;
                siginfo_t info;
                struct user_struct *user;
            };
            对于非实时信号，每个信号在sigqueue链表中最多只能拥有1个节点（这就是信号丢失的根本原因）
            对于实时信号，如果接收到多个相同的信号，每个信号都会拥有一个新的节点
    
    信号在进程中注册，实质就是信号标记到signal域中，并且所携带的信息被记录到sigqueue链表的节点中。
    当一个实时信号发送给进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此，信号不会丢失
    当一个非实时信号发送给进程时，如果该信号已经在进程中注册，则该信号将被丢弃，造成信号丢失

4. 几个典型的应用例子
    signal(SIGPIPE,SIG_IGN) 
        - 这个函数的目的就是防止程序收到SIGPIPE信号后自动退出
        - 根据TCP/IP协议，当对端调用close时，本端收到FIN包，这时对本端调用第一次write，会收到一个RST响应
        - 调用第二次write，系统会发出SIGPIPE信号给进程，SIGPIPE信号的默认处理规则是终止，所以导致进程退出
        - 为了避免进程退出，可以给它设置SIG_IGN信号处理函数,作用是忽略该信号
        - 这样第二次调用write时，会返回-1,同时errno置为SIGPIPE,程序便能知道对端已经关闭

    signal(SIGCHLD,SIG_IGN)
    
