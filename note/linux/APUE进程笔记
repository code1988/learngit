                                            进程环境
----------------------------------------------------------------------------------------------------
1. 进程终止
    有5种方式可以使进程正常终止：
                1）从main返回
                2）调用exit
                3）调用_exit或_Exit
                4）最后一个线程从其启动例程返回
                5）最后一个线程调用pthread_exit

    exit/_exit/_Exit这3个函数的区别：_exit和_Exit立即进入内核,而exit则先执行一些清理动作(包括调用执行事先注册了的终止处理函数，fclose所有标准I/O等)，然后调用_exit/_Exit
                                     
    atexit函数用于注册终止处理函数，原型如下：
        int atexit(void (*func)(void))
    这些终止处理函数将由exit自动调用，exit调用它们的顺序和它们被注册时的顺序正好相反，也就是第一个注册的终止处理函数将会被最后调用

2. 环境变量
    每个进程在被创建的时候都会收到一张命令行参数表和一张环境变量表，通常两张表都位于本进程存储空间的顶部（栈之上）
    
    获取环境变量的方法：
        char *getenv(const char *name);     // 函数返回一个指针，指向name=value字符串中的value
    修改环境变量的方法：
        int setenv(const char *name,const char *value,int rewrite); // 开辟一块堆内存，放入name=value字符串.如果环境中name已经存在，则根据rewrite值决定是否进行覆盖
        int putenv(char *str);                                      // 将形式为name=value的字符串地址(字符串空间不能是在栈上分配的)直接放到环境表中，如果name已经存在，则先删除原来的定义
        int unsetenv(const char *name);                             // 删除name的环境变量，即使不存在也不返回错误
    
3. 非局部跳转
    不同于普通C语言的goto语句在一个函数内进行跳转，非局部跳转可以在栈上进行跨函数跳转，从而返回到当前函数调用路径上的某个函数中。通过2个函数来实现：
            int setjmp(jmp_buf env);            // 直接调用时返回0；从longjmp调用时返回非0值
            void longjmp(jmp_buf env,int val);  // 调用该函数可以返回到上次执行setjmp的位置
    参数env包含了恢复栈状态的所有信息，由setjmp生成导出，由longjmp导入恢复，所以参数env必须是全局性质的;
    根据返回值的不同，一个setjmp可以对应多一个longjmp，因为setjmp的返回值对应了longjmp传入的val.
----------------------------------------------------------------------------------------------------

                                            进程控制
----------------------------------------------------------------------------------------------------
1. 进程ID
    每个进程都由一个非负整数来唯一标识，这就叫进程ID。
    以下是常见的特殊进程ID：
            ID为0的进程通常是调度进程，属于内核的一部分，所以用户态敲"ps"是看不到的；
            ID为1的进程通常是init进程，内核在完成初始化后就会调用该进程进一步执行具体系统(比如debian)的初始化，不同于0号进程，init进程属于用户态进程，并且拥有root权限。

2. 进程创建
    linux下主要实现了3种进程创建函数：
        [1]. pid_t fork(void)
        作为标准的进程创建方式，fork创建的子进程会获得父进程数据段、栈、堆的副本，只有正文段始终是共享的。
        以上这种早期的fork实现方式存在执行效率低下的问题，所以linux采用了COW技术:
                在fork时并不执行对父进程数据段、栈、堆的拷贝，而是父子进程共享这些区域(实际就是共享原本只属于父进程的物理页面)，并且这些被共享区域的访问权限被改为只读。
                当父进程和子进程中的任何一个试图修改这些共享的物理页面时，就产生一个page_fault,内核在异常处理函数中会对这块导致page_fault的物理页面取消共享，并为写进程
                分配新的物理页面并标记为可写(至于原来的物理页面如果内核判定只有一个属主时，也会将其访问权限改回可写)，这样父子进程就各自拥有一块内容相同的物理页面。
        需要注意的一点就是以上这种COW技术按"页"为单位实施，所以更具灵活性。
