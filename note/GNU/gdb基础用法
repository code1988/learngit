											GDB通用命令 
***************************************************************************************************
. b [行号/函数名/+offset/-offset/address/if ...]
   在指定行 / 函数名 / 当前行的前面/后面offset行 / 指定内存地址 / 条件成立时 设置断点

. b *func
   在函数的第一条汇编指令处打断点

. info program
   查看gdb停住的原因

. info sharedlibrary
   查看当前加载的共享库

. info proc mappings
   查看进程的内存映射信息

. info registers
   查看常用寄存器的值

. print(p)[/x] variable/function/register
   查看变量/函数/寄存器值
   可选附加命令"/x"表示十六进制打印

. delete breakpoints [断点号]
   断点号为“info b”中的第一栏，若缺省断点号则意味着删除所有断点
   	
. backtrace(bt)
  查看当前的函数调用栈

. set args xx
  单独设置程序的命令行参数

. show args ...
  查看程序的命令行参数

. start [arguments]
  运行到main函数处停止
  可以携带命令行参数

. return [val]
  直接从当前函数返回，可以在后面携带自定义的返回值

. call 函数
  调用函数

. disassemble [/m] func
  反汇编目标函数，可以增加"/m"选项将函数代码和汇编指令映射起来

. x/nfu address
  x命令用来打印内存地址address上的值
  n: 输出的单元个数
  f: 输出的格式，支持的格式有x(16进制)、s(字符串)、c(字符)、d(10进制)
  u: 单元长度，支持的长度有b(1byte)、h(2byte)、w(4byte)、g(8byte)

. set disassembly-flavor intel
  修改该选项可以使gdb在x86平台上输出intel格式的汇编指令(缺省使用AT&T格式)

. set print pretty on
  开启该选项会使print输出更加规整，比如打印结构体变量时会进行层次化显示

. set print object on
  开启该选项会使print按照变量实际派生类型进行打印(缺省是按照变量的声明类型打印)

. set follow-fork-mode child
  修改该选项会使gdb跟踪子进程流程(缺省会跟踪父进程)

. set detach-on-fork off
  关闭该选项会使gdb同时跟踪父子进程，并且在调试一个进程时，另一个处于挂起状态(缺省只会跟踪其中一个)

. set scheduler-locking on
  开启该选项会对当前调试线程上锁，从而使其他线程暂停执行(缺省在调试一个线程时其他线程都会同时执行)

. 组合命令： info inferiors ; inferiors process-id (不是系统pid)
  查看父进程和所有子进程信息，然后切换当前调试的进程

. 组合命令： info threads ; thread thread-id (不是系统tid)
  查看所有线程信息，然后切换当前调试的线程

. 组合命令： info signals ; handle <signal> stop/nostop print/noprint pass/nopass
   查看gdb如何处理收到的信号，然后设置目标信号发生时的行为

***************************************************************************************************

                                        GDB调试进阶用法
***************************************************************************************************
***************************************************************************************************
1. gdb调试运行中的程序
    有3种启动调试的方法：
            [1]. 通过程序和PID来绑定： "gdb 可执行文件 pid" 
            [2]. 先获取程序的PID，然后直接绑定PID： "gdb -p/--pid PID"
            [3]. 先启动gdb后，通过attach绑定PID："(gdb) attach PID"
                 可以使用detach来取消绑定的进程

2. gdb调试宏
    gcc编译时默认不包含调试信息，即使加了-g选项，产生的调试信息中也仍旧不会包含宏信息，解决的办法是
    改加-ggdb3选项。
    在gdb环境下，有以下几条命令可用于调试宏：
            [1]. info macro 宏名                    - 显示指定宏的定义，并显示这个宏定义在代码的何处
            [2]. macro expand 宏名(如果有,带参数)   - 展开指定宏
            [3]. macro define 宏名 宏定义           - gdb中动态定义一个具体的宏
            [4]. macro list                         - 列出所有通过[3]动态定义的宏
            [5]. macro undef 宏名                   - 删除通过[3]动态定义的宏，不能删除代码中定义的宏

3. gdb调试coredump文件
    有2种调试方法：
    [1]. 命令行直接输入：    gdb 可执行文件 core文件
    [2]. 先启动gdb后，通过file命令加载可执行文件的符号表，通过core命令加载coredump文件
         
    使用任一方式，执行bt/where就可以看到产生coredump的地方

***************************************************************************************************

									    GDB调试时的注意点	
***************************************************************************************************
***************************************************************************************************
1. gdb调试过程中有时需要看某个变量var的值，但"p var"时，却出现"optimized out"消息，这是由于该变量在
   编译时被优化掉了。
   解决方法就是设置编译时优化等级为-O0

