							"="、":="、"?="、"+="四种赋值符号的用法
----------------------------------------------------------------------------------------
"="用法：会将整个Makefile展开后，再决定变量的值，即变量的值将会是整个makefie中最后被指定的值。
例：
	x = foo
	y = $(x)bar
	x = xyz
	此例中，y的值将会是xyzbar,而不是foobar
	
":="用法：表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。
例：
	x := foo
	y := $(x)bar
	x := xyz
	此例中，y的值将会是foobar，而不是xyzbar

"?="用法，表示如果没有被赋值过就赋予等号后面的值，即只有当变量还没有被定义过的时候，才会将右边的值赋给变量
例：
	x := foo
	x ?=xyz
	此时 x的值为foo
	x :=foo
	y ?= $(x)bar
	此时 y的值为foobar
	x :=
	x ?= foo
	此时x的值为空
----------------------------------------------------------------------------------------

							VPATH和vpath的用法
----------------------------------------------------------------------------------------
make时默认只会在当前目录下查找依赖对象和最终目标，使用VPATH或vpath的目的就是当make在当前目录下找不到时，继而到所指定的目录中去寻找

VPATH是makefile的预定义变量，使用格式如下：
	VPATH = dir1:dir2:...

	备注：类似于shell中的环境变量PATH，目录之间用":"分隔
		  被指定的目录中的依赖对象生成的中间文件(比如.c生成的.o)会跑到当前目录下

vpath是maleficent的关键字，使用格式如下：
	vpath [匹配模式] [搜索路径]

	备注：匹配模式中必须包含"%"表示匹配长度任意的非空字符串
		  vpath相对于VPATH的优点是可以在不同的搜索目录中采用不同的匹配规则，意味着得到的结果是经过过滤的

需要注意的是，VPATH/vpath是用来告知make的，仅用于make对依赖对象的搜索，而不是告知gcc，所以还得为gcc指定预编译时的头文件搜索路径
----------------------------------------------------------------------------------------

1. makefile规则的命令中，"@"符号可以加在每行shell命令头部，表示执行make时不打印该命令本身
2. "-"符号可以加在shell命令和一些关键字前(比如-rm、-include)，表示即便某些操作出现了问题，也忽略掉，继续执行后面的命令
3. makefile在启动时会自动读取当前系统中的环境变量,如$(PWD)就是当前路径
4. makefile标准的变量引用是用$()，但是makefile的执行离不开shell环境，因此使用${}也可以访问
5. 如果makefile第一条规则中的目标有很多个，那么第一个目标会成为最终目标
