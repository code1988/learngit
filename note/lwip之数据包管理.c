											数据包结构
/*****************************************************************************************************************
struct pbuf
{
	struct pbuf *next;	// 指向下一个pbuf结构
	void *payload		// 数据指针，指向该pbuf所记录的数据区域
	u16_t tot_len;		// 当前pbuf和后续所有pbuf中包含的数据总长
	u16_t len;			// 当前pbuf单元记录的数据长度
	u8_t type;			// 当前pbuf单元的类型
	u8_t flags;			// 状态位，未用到
	u16_t ref;			// 指向该pbuf的指针数，即该pbuf被引用的次数
}
next:一个数据包需要多个pbuf结构才能完全描述	，这些pbuf结构就组成了一张链表，通过next实现
payload:数据区域可以是紧跟在pbuf结构后的RAM空间，也可以是ROM中的空间，由type字段决定
type:表示pbuf的类型，定义如下
		typedef enum{
			PBUF_RAM,	// pbuf与其描述的数据处于同一连续内存堆中
			PBUF_ROM,	// pbuf描述的数据在ROM中
			PBUF_REF,	// pbuf描述的数据在RAM中，但位置与pbuf结构所处位置无关
			PBUF_POOL	// pbuf与其描述的数据处于同一内存池中
		}pbuf_type;

*****************************************************************************************************************/
											数据包申请、释放
/*****************************************************************************************************************
数据包申请函数有二个重要参数，一个是想申请的数据包pbuf类型，另一个是该数据包是在协议栈哪一层被申请的。
申请函数根据层次的不同，会在pbuf数据区前预留出相应的offset值，层次定义如下
																		typedef enum{
																			PBUF_TRANSTPORT,	// 传输层
																			PBUF_IP,			// 网络层
																			PBUF_LINK,			// 链路层
																			PBUF_RAW			// 原始层，不预留任何空间
																		}pbuf_layer
struct pbuf *pbuf_alloc(pbuf_layer layer,u16_t length,pbuf_type type)
{
	struct pbuf *p,*q,*r;
	u16_t offset;
	s32_t rem_len;
	
	
}	
	
*****************************************************************************************************************/
