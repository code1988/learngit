1. chunk(代码块)，可以是一条语句，也可以是一系列语句的集合，还可以是函数。
   chunk拥有独立的"词法域"，意味着chunk内部声明的局部变量和局部函数，仅在该chunk内可见。
   chunk的定义方式主要有以下几种：
            [1]. do ... end 可以显式定义一个chunk的作用范围
            [2]. 在交互模式下，通常一行就是一个chunk
            [3]. 一个字符串
            [4]. 一个文件
   
2. 加载一个外部的lua代码块需要使用loadfile/loadstring函数，这两个函数主要是将lua代码块编译成一种中间形式，然后整体作为一个匿名函数返回。
   加载一个程序块仅仅相当于定义了一个函数体是整个代码块的匿名函数，并且该匿名函数具有可变长实参。
   需要注意的就是，由于在这个过程中代码块并不会被运行，所以代码块中的函数尚未被定义。

   dofile这个函数内部不但调用了loadfile，还进一步调用了创建的匿名函数，所以就相当于运行了整个外部lua代码块文件。
   需要注意到就是，在这个过程中代码块中的语句被执行，包括其中的函数就会作为一条赋值语句被定义，从此才可以被调用。

   比较dofile和loadfile，两者的使用差别主要是：
            [1]. dofile一次调用即可完成加载和运行，适合用在简单任务中;
            [2]. loadfile在出现错误时会返回错误值，可以自定义错误处理方法;
            [3]. 对于需要多次运行的文件，通过loadfile加载后，就可以反复调用它的匿名函数，实现一次编译多次使用。

1. lua的模块类似于一个封装库，以API接口的形式在其他地方被调用，模块的结构就是一个table的结构
    例：
        -- 模块文件的文件名 test.lua
        local M = {}        
        _G[...] = M         
        function M.fun()
            print("hello")
        end
        return M
        备注：  ...就是传递给模块的模块名，这里就是"test"
            在全局环境_G这个table里，添加一个以"test"作为索引的元素，内容是M
            于是当我们直接调用模块名test时，其实就是在调用_G["test"]的内容M
        问题：  实际编程中，return M语句的省略似乎并没有产生错误提示
        
        对于使用5.2版本以下的lua，模块文件还可以使用以下定义方法：
        module(...,package.seeall)
        function fun()
            print("hello")
        end
        备注：  module(...,package,seeall)函数相当于实现了
                    local M = {}
                    _G[...] = M
                    setmetatable(M,{__index = _G})
                    setfenv(1,M)
                    ...
                    return M
        问题：  module函数5.3之后被彻底抛弃，官方给出原因是会污染全局环境变量

2. lua通过一个require的函数来加载模块，require函数定义如下:
	require("模块名")
	备注：	因为模块有可能是lua库或c库，所以模块名不能包含扩展名;
			该函数会返回一个由模块函数组成的table

	require函数的加载原则：
		用模块名替换package.path中的每个“？”，然后检查是否存在这样一个文件;
		如果找不到，接着在package.cpath中找
