1. 所谓"迭代器"，就是一种可以遍历某个集合中所有元素的机制，在lua中迭代器通常表示为函数，而具体的实现有很多种。
   整个迭代的过程基本如下：
            首先是通过迭代器工厂创建迭代器;
            然后每次调用这个迭代器时，它就会从指定的集合中返回下一个元素;
            直到最后一个元素返回后，迭代器就会返回nil，以此表示迭代结束。

2. 闭包是一种最典型的迭代器函数，因为闭包中的"非局部的变量"可以用来在每次调用之间保持一些状态，从而使闭包可以记住每次迭代所在的位置。

3. lua中的泛型for天然就是为迭代而设计的，其语法格式如下：
            for <var-list> in <exp-list> do
                <body>
            end
            备注：<var-list>是变量名列表，用来存储迭代器函数的返回值，其中的第一个变量固定称为"控制变量"，当它为nil时迭代结束;
                  <exp-list>是表达式列表，通常只有一个，即对迭代器工厂的调用。
   泛型for的执行流程如下：
            [1]. 对关键字"in"后面的表达式求值，该表达式通常会返回3个值供for保存，迭代器函数、恒定状态、控制变量的初值 
            [2]. 将恒定状态(比如要遍历的table)和控制变量作为实参，调用迭代器函数
            [3]. 将迭代器函数的返回值赋给变量列表，如果控制变量为nil，则迭代结束
            [4]. 如果控制变量是有效值，则执行循环体，随后再次调用迭代器函数，执行下一次迭代

4. 泛型for中的迭代器函数可以是一种自身不保存任何状态的普通函数，又叫做"无状态迭代器"，每次迭代都是根据恒定状态和控制变量来遍历每个元素。
   这种"无状态迭代器"的优点显而易见，它将状态保存在泛型for中，不需要创建任何新的对象，所以尽可能尝试编写这种迭代器。
   
5. 泛型for中的迭代器函数也可以是闭包，这通常意味着迭代器需要保存很多状态，而泛型for只提供了一个恒定状态和一个控制变量用于状态的保存，使用闭包可以优雅的解决这个问题。

6. 有复杂状态的迭代器除了可以通过闭包实现，还可以将这些复杂状态全部打包为一个table，保存在恒定状态中，这也意味着迭代器不再需要泛型for提供的控制变量了。
   

            

